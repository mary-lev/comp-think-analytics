repo_name,issue_title,comment_user,comment_text,comment_datetime
comp-think/2018-2019,"Lecture ""Greedy algorithms"", exercise 1",hizclick,"here is what this code does:
it takes all coins as  sorted input list, so the maximum coin is at index 0. Then it checks if the amount is included in the first index value  if not it will pop it out from the  list. If it is included then that coin will be inserted to the result list. 
```
def test_change(amount,coins,expected):
    if expected == change(amount,coins):
        return True
    else:
        return False
def change(amount, coins, result=list()):
    if amount== 0:
        return result
    else:
        if len(coins)>0:
            maximum_coin = coins[0]
            if amount>= maximum_coin:
                result.append(maximum_coin)
                amount= round(amount- maximum_coin, 2)
                return change(amount,coins)
            else:
                if result:
                    coins.pop(0)
                    return change(amount,coins)
    return result
print(test_change(6.44,[2,1,0.5,0.2,0.1,0.05,0.02,0.01],[2,2,2,0.2,0.2,0.02,0.02]))

```",2018-12-20T17:12:22+00:00
comp-think/2018-2019,"Lecture ""Greedy algorithms"", exercise 1",essepuntato,"Hi all,

I'm posting here my take on the exercise - you can find the source of this [online](https://comp-think.github.io/2018-2019/python/return_change.py) as usual.

```
# Test case for the algorithm
def test_return_change(amount, expected):
    result = return_change(amount)
    if expected == result:
        return True
    else:
        return False


# Code of the algorithm
def return_change(amount):
    result = {}
    coins = [2.0, 1.0, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01]

    for coin in coins:
        while float_diff(amount, coin) >= 0:
            amount = float_diff(amount, coin)

            if coin not in result:
                result[coin] = 0
            result[coin] = result[coin] + 1

    return result


def float_diff(f1, f2):
    return round(f1 - f2, 2)


change = 2.76
print(test_return_change(5.00, {2.0: 2, 1.0: 1}))
print(test_return_change(2.76, {2.0: 1, 0.5: 1, 0.2:1, 0.05:1, 0.01: 1}))
```

Note that I've used an ancillay function I've developed called `float_diff`, so as to address one [well-known issue](https://docs.python.org/3/tutorial/floatingpoint.html) of Python with floating numbers.",2018-12-22T09:27:04+00:00
comp-think/2018-2019,"Lecture ""Backtracking algorithms"", exercise 1",delfimpandiani,"I am not quite sure if my solution solves the efficiency problem in the way the prompt asks, but it does bring efficiency to the algorithm. I tried to implement various ideas but only ended up with one working one. 

First, I thought it might be nice to apply dynamic programming, by creating a ""bad moves"" list or dictionary that would be appended every time a leaf-lose case was encountered, and which would be checked every time a new move was to be executed. But then I realized that this was unhelpful, as the same exact move (with the board in the same exact state) would not be executed more than once in one specific run of the game. 

So then I developed a different idea, based on the previous tree exercises, and specifically on the recursive breadth_first_visit. Basically, with the execution as it is provided by Silvio, the algorithm is a depth_first_visit (i.e., enters each branch deeply until its last descendant with no children -- a leaf-lose case --is found, and then backtracks one generation, and so on successively). This means that the algorithm has to spend a lot of resources not only by going deeply into each branch, but also by only checking one descendant per generation (to see if it is a leaf-win). The point is that the leaf-win case might be in a higher up in a generation of the tree already created, but that simply has not been checked yet. So, my idea is to do a breadth-first visit through all siblings of each of the built generations, so as to not waste time going too deeply before checking if the leaf-win already exists in the tree. 

For this, I only edited the solve() code (and recycled the recursive breadth_visit_first algorithm from last exercise):

```
def solve(pegs, holes, last_move=Node(""start"")):

    result = None
    breadth_search = breadth_first_visit(last_move)
    for move in breadth_search:
        if len(pegs) == 1 and (3, 2) in pegs:  # leaf-win base case
            result = move
        else:
            move.children = valid_moves(pegs, holes)
            if len(move.children) == 0:  # leaf-lose base case
                undo_move(move, pegs, holes)  # backtracking
            else:  # recursive step
                possible_moves = deque(move.children)
                while result is None and len(possible_moves) > 0:
                    current_move = possible_moves.pop()
                    apply_move(current_move, pegs, holes)
                    result = solve(pegs, holes, current_move)
                if result is None:
                    undo_move(move, pegs, holes)  # backtracking
        return result


def breadth_first_visit(input, queue=[]):
    if queue:
        queue.remove(queue[0])
    breadth_result = [input]
    queue.extend(input.children)
    if queue:
        breadth_result.extend(breadth_first_visit(queue[0]))
    return breadth_result
```

What this means is that, while the tree is being created in a recursive depth_first way, the checking for the leaf_win case is done recursively in a breadth_first way. This, in turn, means that no time is wasted in building each branch depth all the way to the leaf if a leaf-win case is already present in the tree.

",2018-12-15T12:39:51+00:00
comp-think/2018-2019,"Lecture ""Backtracking algorithms"", exercise 1",hizclick,"Here I have proposed a solution, by applying dynamic programming concept. First, I create a list and put all unsuccessful moves in it. So, before searching for the possible moves from the current position the algorithm checks if the last move was successful or not. If it is already in the list it will call undo_move() function if not it will check possible moves from the current position. 

```
def solve(pegs, holes, last_move=Node(""start""), unsuccessful_move=list()):
	result = None
	if len(pegs) == 1 and (3, 2) in pegs:  # leaf-win base case
		result = last_move
	else:
		last_move.children = valid_moves(pegs, holes)
		if last_move.children not in unsuccessful_move:
			if len(last_move.children) == 0:  # leaf-lose base case
				unsuccessful_move.append(last_move)
				undo_move(last_move, pegs, holes)  # backtracking
			else:  # recursive step
				possible_moves = deque(last_move.children)

				while result is None and len(possible_moves) > 0:
					current_move = possible_moves.pop()
					apply_move(current_move, pegs, holes)
					result = solve(pegs, holes, current_move, unsuccessful_move)

				if result is None:
					unsuccessful_move.append(last_move.children)
					undo_move(last_move, pegs, holes)  # backtracking'
		else:
			undo_move(last_move, pegs, holes)
		
	return result

```
",2018-12-16T00:12:19+00:00
comp-think/2018-2019,"Lecture ""Backtracking algorithms"", exercise 1",essepuntato,"Hi all,

I'm posting here my take on the exercise - you can find the source of this [online](https://comp-think.github.io/2018-2019/python/peg_solitaire_dp.py) as usual. I've reused all the code of the implementation proposed in the lecture notes, except the function `solve` which has been appropriately extended.

```
from peg_solitaire import create_6x6_square_board, valid_moves, apply_move, undo_move, test_solve


# Code of the algorithm
def solve(pegs, holes, last_move=Node(""start""), no_win=list()):
    result = None

    if pegs not in no_win:
        no_win.append(set(pegs))

        if len(pegs) == 1 and (3, 2) in pegs:  # leaf-win base case
            result = last_move
        else:
            last_move.children = valid_moves(pegs, holes)

            if len(last_move.children) == 0:  # leaf-lose base case
                undo_move(last_move, pegs, holes)  # backtracking
            else:  # recursive step
                possible_moves = deque(last_move.children)

                while result is None and len(possible_moves) > 0:
                    current_move = possible_moves.pop()
                    apply_move(current_move, pegs, holes)
                    result = solve(pegs, holes, current_move, no_win)

                if result is None:
                    undo_move(last_move, pegs, holes)  # backtracking
    else:
        undo_move(last_move, pegs, holes)  # backtracking

    return result


pegs, holes = create_6x6_square_board()
print(test_solve(pegs, holes, (3, 2)))
```

A comment on @delfimpandiani take:

> the same exact move (with the board in the same exact state) would not be executed more than once in one specific run of the game.

It is true that a particular node in the tree of moves will be reached just once. However, each node is actually identified by the sequence of moves that bring to a particular board configuration, and not by the board configuration itself. In fact, it is possible to reach the same board configuration from different branches of the tree of moves. Thus, that ""no win"" list should not record the *bad moves*, but rather the *bad configurations* of the board, that you are sure have no solution. In this way, a depth-first visit of the tree of moves still works quite well, since the dynamic programming check is done on the board configurations (which are reacheable by different branches) and not on the chain of moves (which are unique, indeed).",2018-12-22T09:20:22+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 2",SeverinJB,"```
from networkx import MultiDiGraph

movie_graph = MultiDiGraph()

# Actors
movie_graph.add_node(""Brad Pitt"")
movie_graph.add_node(""Eva Green"")
movie_graph.add_node(""George Clooney"")
movie_graph.add_node(""Catherine Zeta-Jones"")
movie_graph.add_node(""Johnny Depp"")
movie_graph.add_node(""Helena Bonham Carter"")

# Movies
movie_graph.add_node(""Ocean's Twelve"")
movie_graph.add_node(""Fight Club"")
movie_graph.add_node(""Dark Shadows"")

# Cast Ocean's Twelve
movie_graph.add_edge(""Brad Pitt"", ""Ocean's Twelve"")
movie_graph.add_edge(""Catherine Zeta-Jones"", ""Ocean's Twelve"")
movie_graph.add_edge(""George Clooney"", ""Ocean's Twelve"")

# Cast Fight Club
movie_graph.add_edge(""Brad Pitt"", ""Fight Club"")
movie_graph.add_edge(""Helena Bonham Carter"", ""Fight Club"")

# Cast Dark Shadows
movie_graph.add_edge(""Johnny Depp"", ""Dark Shadows"")
movie_graph.add_edge(""Helena Bonham Carter"", ""Dark Shadows"")
movie_graph.add_edge(""Eva Green"", ""Dark Shadows"")

print(movie_graph.nodes())
print(movie_graph.edges())
```",2018-12-12T16:30:10+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 2",EleonoraPeruch,"```
# Ocean's Twelve
# George Clooney
# Brad Pitt
# Catherine Zeta-Jones

# Fight Club
# Brad Pitt
# Helena Bonham Carter

# Dark Shadows
# Johnny Depp
# Helena Bonham Carter
# Eva Green

from networkx import DiGraph

# create a new graph
actor_and_movie = DiGraph() # I use DiGraph since there is only one edge between each two nodes

# create nodes for actors
actor_and_movie.add_node(""Brad Pitt"")
actor_and_movie.add_node(""Eva Green"")
actor_and_movie.add_node(""George Clooney"")
actor_and_movie.add_node(""Catherine Zeta-Jones"")
actor_and_movie.add_node(""Johnny Depp"")
actor_and_movie.add_node(""Helena Bonham Carter"")

# create nodes for movies
actor_and_movie.add_node(""Ocean's Twelve"")
actor_and_movie.add_node(""Fight Club"")
actor_and_movie.add_node(""Dark Shadows"")

# create edges between each actor and the movies in which he acted
actor_and_movie.add_edge(""Brad Pitt"", ""Ocean's Twelve"")
actor_and_movie.add_edge(""Brad Pitt"", ""Fight Club"")
actor_and_movie.add_edge(""Eva Green"", ""Dark Shadows"")
actor_and_movie.add_edge(""George Clooney"", ""Ocean's Twelve"")
actor_and_movie.add_edge(""Catherine Zeta-Jones"",""Ocean's Twelve"")
actor_and_movie.add_edge(""Johnny Depp"", ""Dark Shadows"")
actor_and_movie.add_edge(""Helena Bonham Carter"", ""Fight Club"")
actor_and_movie.add_edge(""Helena Bonham Carter"", ""Dark Shadows"")

print(actor_and_movie.nodes())
print(actor_and_movie.edges())

['Brad Pitt', 'Eva Green', 'George Clooney', 'Catherine Zeta-Jones', 'Johnny Depp', 'Helena Bonham Carter', ""Ocean's Twelve"", 'Fight Club', 'Dark Shadows']
[('Brad Pitt', ""Ocean's Twelve""), ('Brad Pitt', 'Fight Club'), ('Eva Green', 'Dark Shadows'), ('George Clooney', ""Ocean's Twelve""), ('Catherine Zeta-Jones', ""Ocean's Twelve""), ('Johnny Depp', 'Dark Shadows'), ('Helena Bonham Carter', 'Fight Club'), ('Helena Bonham Carter', 'Dark Shadows')]

```",2018-12-12T18:36:56+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 2",andreamust,"```

from networkx import MultiDiGraph

my_cinema_graph = MultiDiGraph()

my_cinema_graph.add_node(1, name = ""Brad"", surname = ""Pitt"")
my_cinema_graph.add_node(2, name = ""Eva"", surname = ""Green"")
my_cinema_graph.add_node(3, name = ""George"", surname = ""Clooney"")
my_cinema_graph.add_node(4, name = ""Catherine"", surname = ""Zeta-Jones"")
my_cinema_graph.add_node(5, name = ""Johnny"", surname = ""Depp"")
my_cinema_graph.add_node(6, name = ""Helena"", surname = ""Bohnam Carter"")

my_cinema_graph.add_node('x', title = ""Ocean's Twelve"")
my_cinema_graph.add_node('y', title = ""Fight Club"")
my_cinema_graph.add_node('z', title = ""Dark Shadows"")


my_cinema_graph.add_edge(1, 'x')
my_cinema_graph.add_edge(1, 'y')
my_cinema_graph.add_edge(2, 'z')
my_cinema_graph.add_edge(3, 'x')
my_cinema_graph.add_edge(4, 'x')
my_cinema_graph.add_edge(5, 'z')
my_cinema_graph.add_edge(6, 'y')
my_cinema_graph.add_edge(6, 'z')

```
@essepuntato is there a way to print only the attributes without the node identifiers?
",2018-12-13T12:20:46+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 2",saraarmaroli,"from networkx import DiGraph
actor_movie = DiGraph()

#actors nodes
actor_movie.add_node(""Brad Pitt"")
actor_movie.add_node(""Eva Green"")
actor_movie.add_node(""George Clooney"")
actor_movie.add_node(""Catherine Zeta Jones"")
actor_movie.add_node(""Johnny Depp"")
actor_movie.add_node(""Helena Bonham Carter"")

#movies nodes
actor_movie.add_node(""Ocean's Twelve"")
actor_movie.add_node(""Fight Club"")
actor_movie.add_node(""Dark Shadows"")

#edges
actor_movie.add_edge(""Brad Pitt"", ""Ocean's Twelve"")
actor_movie.add_edge(""Brad Pitt"", ""Fight Club"")
actor_movie.add_edge(""Eva Green"", ""Dark Shadows"")
actor_movie.add_edge(""George Clooney"", ""Ocean's Twelve"")
actor_movie.add_edge(""Catherine Zeta Jones"", ""Ocean's Twelve"")
actor_movie.add_edge(""Johnny Depp"", ""Dark Shadows"")
actor_movie.add_edge(""Helena Bonham Carter"", ""Fight Club"")
actor_movie.add_edge(""Helena Bonham Carter"", ""Dark Shadow"")

print(actor_movie.nodes())
print(actor_movie.edges())
['Brad Pitt', 'Eva Green', 'George Clooney', 'Catherine Zeta Jones', 'Johnny Depp', 'Helena Bonham Carter', ""Ocean's Twelve"", 'Fight Club', 'Dark Shadows', 'Dark Shadow']
[('Brad Pitt', ""Ocean's Twelve""), ('Brad Pitt', 'Fight Club'), ('Eva Green', 'Dark Shadows'), ('George Clooney', ""Ocean's Twelve""), ('Catherine Zeta Jones', ""Ocean's Twelve""), ('Johnny Depp', 'Dark Shadows'), ('Helena Bonham Carter', 'Fight Club'), ('Helena Bonham Carter', 'Dark Shadow')]
",2018-12-13T15:01:12+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 2",MilenaCorbellini,"````
from networkx import MultiDiGraph
movies_graph= MultiDiGraph()
#Actors
movies_graph.add_node(""Brad Pit"")
movies_graph.add_node(""Eva Green"")
movies_graph.add_node(""George Clooney"")
movies_graph.add_node(""Chaterine Zeta-Jones"")
movies_graph.add_node(""Jonny Deep"")
movies_graph.add_node(""Helena Bonham Carter"")
#Movies
movies_graph.add_node(""Ocean's Twelve"")
movies_graph.add_node(""Fight Club"")
movies_graph.add_node(""Dark Shadows"")

movies_graph.add_edge(""Brad Pit"", ""Ocean's Twelve"", color = 'r')
movies_graph.add_edge(""George Clooney"", ""Ocean's Twelve"", color = 'r')
movies_graph.add_edge(""Chaterine Zeta-Jones"", ""Ocean's Twelve"", color = 'r')

movies_graph.add_edge(""Brad Pit"", ""Fight Club"", color = 'blue')
movies_graph.add_edge(""Helena Bonham Carter"", ""Fight Club"", color= 'blue')
````",2018-12-13T15:15:59+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 2",lisasiurina,"
```
from networkx import DiGraph
movie = DiGraph()

#nodes for actors
movie.add_node(""Brad Pitt"")
movie.add_node(""Eva Green"")
movie.add_node(""George Clooney"")
movie.add_node(""Catherine Zeta-Jones"")
movie.add_node(""Johnny Depp"")
movie.add_node(""Helena Bonham Carter"")

#nodes for movies
movie.add_node(""Ocean's Twelve"")
movie.add_node(""Fight Club"")
movie.add_node(""Dark Shadows"")

movie.add_edge(""Brad Pitt"", ""Ocean's Twelve"")
movie.add_edge(""Brad Pitt"", ""Fight Club"")
movie.add_edge(""Eva Green"", ""Dark Shadows"")
movie.add_edge(""George Clooney"", ""Ocean's Twelve"")
movie.add_edge(""Catherine Zeta-Jones"",""Ocean's Twelve"")
movie.add_edge(""Johnny Depp"", ""Dark Shadows"")
movie.add_edge(""Helena Bonham Carter"", ""Fight Club"")
movie.add_edge(""Helena Bonham Carter"", ""Dark Shadows"")

print(movie.nodes())
print(movie.edges())

```

['Brad Pitt', 'Eva Green', 'George Clooney', 'Catherine Zeta-Jones', 'Johnny Depp', 'Helena Bonham Carter', ""Ocean's Twelve"", 'Fight Club', 'Dark Shadows']
[('Brad Pitt', ""Ocean's Twelve""), ('Brad Pitt', 'Fight Club'), ('Eva Green', 'Dark Shadows'), ('George Clooney', ""Ocean's Twelve""), ('Catherine Zeta-Jones', ""Ocean's Twelve""), ('Johnny Depp', 'Dark Shadows'), ('Helena Bonham Carter', 'Fight Club'), ('Helena Bonham Carter', 'Dark Shadows')]
",2018-12-13T23:58:42+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 2",delfimpandiani,"```
from networkx import MultiDiGraph

hollywood = MultiDiGraph()

hollywood.add_edge(""George Clooney"", ""Ocean's Twelve"")
hollywood.add_edge(""Brad Pitt"", ""Ocean's Twelve"")
hollywood.add_edge(""Catherine Zeta-Jones"", ""Ocean's Twelve"")
hollywood.add_edge(""Brad Pitt"", ""Fight Club"")
hollywood.add_edge(""Helena Bonhan Carter"", ""Fight Club"")
hollywood.add_edge(""Johny Depp"", ""Dark Shadows"")
hollywood.add_edge(""Helena Bonham Carter"", ""Dark Shadows"")
hollywood.add_edge(""Eva Green"", ""Dark Shadows"")


print(hollywood.edges())


[('George Clooney', ""Ocean's Twelve""), ('Brad Pitt', ""Ocean's Twelve""), ('Brad Pitt', 'Fight Club'), ('Catherine Zeta-Jones', ""Ocean's Twelve""), ('Helena Bonhan Carter', 'Fight Club'), ('Johny Depp', 'Dark Shadows'), ('Helena Bonham Carter', 'Dark Shadows'), ('Eva Green', 'Dark Shadows')]

```",2018-12-14T19:26:09+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 2",mangiafrangette,"```
from networkx import MultiDiGraph

actor_movie_graph = MultiDiGraph()

# adding actors
actor_movie_graph.add_node(""Brad Pitt"")
actor_movie_graph.add_node(""Eva Green"")
actor_movie_graph.add_node(""George Clooney"")
actor_movie_graph.add_node(""Catherine Zeta-Jones"")
actor_movie_graph.add_node(""Johnny Depp"")
actor_movie_graph.add_node(""Helena Bonham Carter "")

# adding movies
actor_movie_graph.add_node(""Ocean's Twelve"")
actor_movie_graph.add_node(""Fight Club"")
actor_movie_graph.add_node(""Dark Shadows"")

# adding edges
actor_movie_graph.add_edge(""George Clooney"", ""Ocean's Twelve"")
actor_movie_graph.add_edge(""Brad Pitt"", ""Ocean's Twelve"")
actor_movie_graph.add_edge(""Catherine Zeta-Jones"", ""Ocean's Twelve"")
actor_movie_graph.add_edge(""Brad Pitt"", ""Fight Club"")
actor_movie_graph.add_edge(""Helena Bonham Carter"", ""Fight Club"")
actor_movie_graph.add_edge(""Brad Pitt"", ""Dark Shadows"")
actor_movie_graph.add_edge(""Helena Bonham Carter"", ""Dark Shadows"")
actor_movie_graph.add_edge(""Eva Green"", ""Dark Shadows"")
```",2018-12-15T09:44:06+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 2",bluebell94,"from networkx import MultiDiGraph
movie_stars = MultiDiGraph()
movie_stars.add_node(""a"",weight=""Ocean's Twelve"")
movie_stars.add_node(""b"",weight=""Fight Club"")
movie_stars.add_node(""c"",weight=""Dark Shadows"")
movie_stars.add_node(1, weight=""Brad Pitt"")
movie_stars.add_node(2, weight=""George Clooney"")
movie_stars.add_node(3, weight=""Eva Green"")
movie_stars.add_node(4, weight=""Catherine Zeta-Jones"")
movie_stars.add_node(6, weight=""Helena Bonham Carter"")

movie_stars.add_edge(1,""a"")
movie_stars.add_edge(1,""b"")
movie_stars.add_edge(2,""a"")
movie_stars.add_edge(3,""c"")
movie_stars.add_edge(4,""a"")
movie_stars.add_edge(5,""c"")
movie_stars.add_edge(6,""b"")
movie_stars.add_edge(6,""c"")

print(movie_stars.nodes(data=True))
print(movie_stars.edges(data=True))

[('a', {'weight': ""Ocean's Twelve""}), ('b', {'weight': 'Fight Club'}), ('c', {'weight': 'Dark Shadows'}), (1, {'weight': 'Brad Pitt'}), (2, {'weight': 'George Clooney'}), (3, {'weight': 'Eva Green'}), (4, {'weight': 'Catherine Zeta-Jones'}), (6, {'weight': 'Helena Bonham Carter'}), (5, {})]
[(1, 'a', {}), (1, 'b', {}), (2, 'a', {}), (3, 'c', {}), (4, 'a', {}), (6, 'b', {}), (6, 'c', {}), (5, 'c', {})]
",2018-12-15T10:31:48+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 2",beccadelbens," ``` 
from networkx import MultiDiGraph

second_graph = MultiDiGraph

second_graph.add_node(""Brad Pitt"")
second_graph.add_node(""Eva Green"")
second_graph.add_node(""George Clooney"")
second_graph.add_node(""Catherine Zeta-Jones"")
second_graph.add_node(""Johnny Depp"")
second_graph.add_node(""Helena Bonham Carter"")
second_graph.add_node(""Ocean's Twelve"")
second_graph.add_node(""Fight Club"")
second_graph.add_node(""Dark Shadows"")

second_graph.add_edge(""Brad Pitt"", ""Ocean's Twelve"")
second_graph.add_edge(""Brad Pitt"", ""Fight Club"")
second_graph.add_edge(""Eva Green"", ""Dark Shadows"")
second_graph.add_edge(""George Clooney"", ""Ocean's Twelve"")
second_graph.add_edge(""Catherine Zeta-Jones"", ""Ocean's Twelve"")
second_graph.add_edge(""Johnny Depp"", ""Dark Shadows"")
second_graph.add_edge(""Helena Bonham Carter"", ""Fight Club"")
second_graph.add_edge(""Helena Bonham Carter"", ""Dark Shadows"")

print(second_graph.nodes())
print(second_graph.edges())
 ``` ",2018-12-15T15:13:57+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 2",dafnikitsiki,"from networkx import MultiDiGraph

#create a new graph
cast_graph = MultiDiGraph()

#create nodes for movies
cast_graph.add_node(""Ocean's Twelve"")
cast_graph.add_node(""Fight Club"")
cast_graph.add_node(""Dark Shadows"")

#create nodes for actors
cast_graph.add_node(""Brad Pitt"")
cast_graph.add_node(""Eva Green"")
cast_graph.add_node(""George Clooney"")
cast_graph.add_node(""Catherine Zeta-Jones"")
cast_graph.add_node(""Johnny Depp"")
cast_graph.add_node(""Helena Bonham Carter"")

#create edges between actors and movies
cast_graph.add_edge(""Brad Pitt"", ""Ocean's Twelve"")
cast_graph.add_edge(""Brad Pitt"", ""Fight Club"")
cast_graph.add_edge(""Eva Green"", ""Dark Shadows"")
cast_graph.add_edge(""George Clooney"", ""Ocean's Twelve"")
cast_graph.add_edge(""Catherine Zeta-Jones"", ""Ocean's Twelve"")
cast_graph.add_edge(""Johnny Depp"", ""Dark Shadows"")
cast_graph.add_edge(""Helena Bonham Carter"", ""Fight Club"")
cast_graph.add_edge(""Helena Bonham Carter"", ""Dark Shadows"")

print(cast_graph.nodes())
print(cast_graph.edges())",2018-12-15T20:30:53+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 2",essepuntato,"Hi @andreamust 

> is there a way to print only the attributes without the node identifiers?

Not to my knowledge – of course, you can implement a function that does exactly that, if you want.

Another comment for @bluebell94: use appropriate attribute names for specifying values – e.g. I do not expect to have a name associated to the attribute *weight*, bur rather a number. If you want to specify the names as attributes, please look at the way @andreamust did.",2018-12-22T07:48:17+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 1",SeverinJB,"```
from networkx import MultiGraph

network_tim = MultiGraph()

network_tim.add_node(""Tim Berners-Lee"")
network_tim.add_node(""Christian Bizer"")
network_tim.add_node(""Tom Heath"")
network_tim.add_node(""Sören Auer"")
network_tim.add_node(""Lalana Kagal"")
network_tim.add_node(""James A. Hendler"")
network_tim.add_node(""Daniel J. Weitzner"")

network_tim.add_edge(""Tim Berners-Lee"", ""Christian Bizer"", weight=17)
network_tim.add_edge(""Tim Berners-Lee"", ""Tom Heath"", weight=17)
network_tim.add_edge(""Tim Berners-Lee"", ""Sören Auer"", weight=10)
network_tim.add_edge(""Tim Berners-Lee"", ""Lalana Kagal"", weight=9)
network_tim.add_edge(""Tim Berners-Lee"", ""James A. Hendler"", weight=8)
network_tim.add_edge(""Tim Berners-Lee"", ""Daniel J. Weitzner"", weight=8)

print(network_tim.nodes(data=True))
print(network_tim.edges(data=True))
```",2018-12-12T16:29:52+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 1",EleonoraPeruch,"```
from networkx import Graph

# top five co-authors of Tim Berners-Lee
# Christian Bizer (17)
# Tom Heath (17)
# Sören Auer (10)
# Lalana Kagal (9)
# James A. Hendler (8)

# create a new graph
tim_berners_lee = Graph()

# create six nodes
tim_berners_lee.add_node(""Tim Berners-Lee"")
tim_berners_lee.add_node(""Christian Bizer"")
tim_berners_lee.add_node(""Tom Heath"")
tim_berners_lee.add_node(""Sören Auer"")
tim_berners_lee.add_node(""Lalana Kagal"")
tim_berners_lee.add_node(""James A. Hendler"")

# create five edges
tim_berners_lee.add_edge(""Tim Berners-Lee"", ""Christian Bizer"", weight=17)
tim_berners_lee.add_edge(""Tim Berners-Lee"", ""Tom Heath"", weight=17)
tim_berners_lee.add_edge(""Tim Berners-Lee"", ""Sören Auer"", weight=10)
tim_berners_lee.add_edge(""Tim Berners-Lee"", ""Lalana Kagal"", weight=9)
tim_berners_lee.add_edge(""Tim Berners-Lee"", ""James A. Hendler"", weight=8)

print(tim_berners_lee.nodes(data=True))
print(tim_berners_lee.edges(data=True))

[('Tim Berners-Lee', {}), ('Christian Bizer', {}), ('Tom Heath', {}), ('Sören Auer', {}), ('Lalana Kagal', {}), ('James A. Hendler', {})]
[('Tim Berners-Lee', 'Christian Bizer', {'weight': 17}), ('Tim Berners-Lee', 'Tom Heath', {'weight': 17}), ('Tim Berners-Lee', 'Sören Auer', {'weight': 10}), ('Tim Berners-Lee', 'Lalana Kagal', {'weight': 9}), ('Tim Berners-Lee', 'James A. Hendler', {'weight': 8})]

```",2018-12-12T18:10:42+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 1",friendlynihilist,"```
from networkx import Graph
cs_bib = Graph()

#add nodes
cs_bib.add_node(""Tim Berners-Lee"")
cs_bib.add_node(""Christian Bizer"")
cs_bib.add_node(""Tom Heath"")
cs_bib.add_node(""Sören Auer"")
cs_bib.add_node(""Lalana Kagal"")
cs_bib.add_node(""James A. Hendler"")

#add edges with 'weight' attribute
cs_bib.add_edge(""Tim Berners-Lee"", ""Christian Bizer"", weight=17)
cs_bib.add_edge(""Tim Berners-Lee"", ""Tom Heath"", weight=17)
cs_bib.add_edge(""Tim Berners-Lee"", ""Sören Auer"", weight=10)
cs_bib.add_edge(""Tim Berners-Lee"", ""Lalana Kagal"", weight=9)
cs_bib.add_edge(""Tim Berners-Lee"", ""James A. Hendler"", weight=8)

print(cs_bib.nodes(data=True))
print(cs_bib.edges(data=True))

#memo:
#tim berners-lee
#christian bizer 17
#tom heath 17
#sören auer 10
#lalana kagal 9
#james a. hendler 8
```",2018-12-13T12:19:36+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 1",andreamust,"```

from networkx import Graph

my_graph = Graph()

my_graph.add_node(1, name = ""Tim"", surname = ""Berners-Lee"")
my_graph.add_node(2, name = ""Tom"", surname = ""Heat"")
my_graph.add_node(3, name = ""Christian"", surname = ""Bizer"")
my_graph.add_node(4, name = ""Soren"", surname = ""Auer"")
my_graph.add_node(5, name = ""Lalana"", surname = ""Kagal"")
my_graph.add_node(6, name = ""Daniel J."", surname = ""Weitzner"")


my_graph.add_edge(1, 2, weight = 17)
my_graph.add_edge(1, 3, weight = 17)
my_graph.add_edge(1, 4, weight = 10)
my_graph.add_edge(1, 5, weight = 9)
my_graph.add_edge(1, 6, weight = 8)


print(my_graph.nodes(data=True))
print(my_graph.edges(data=True))

```",2018-12-13T12:26:52+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 1",saraarmaroli,"```
from networkx import Graph

tim_berners_graph = MultiGraph()
tim_berners_graph.add_node(""Tim Berners Lee"")
tim_berners_graph.add_node(""Christian Bizer"")
tim_berners_graph.add_node(""Tom Heath"")
tim_berners_graph.add_node(""Sören Auer"")
tim_berners_graph.add_node(""Michael Hausenblas"")
tim_berners_graph.add_node(""Kingsley Idehen"")

tim_berners_graph.add_edge(""Tim Berners Lee"", ""Christian Bizer"", weight=17)
tim_berners_graph.add_edge(""Tim Berners Lee"", ""Tom Heath"", weight=17)
tim_berners_graph.add_edge(""Tim Berners Lee"", ""Sören Auer"", weight=8)
tim_berners_graph.add_edge(""Tim Berners Lee"", ""Michael Hausenblas"", weight=5)
tim_berners_graph.add_edge(""Tim Berners Lee"", ""Kingsley Idehen"",  weight=4)

print(tim_berners_graph.nodes(data=True))
print(tim_berners_graph.edges(data=True))
```",2018-12-13T14:39:00+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 1",MilenaCorbellini,"````
from networkx import MultiGraph
lee_graph= MultiGraph()

lee_graph.add_node('Tim Berners-Lee')
lee_graph.add_node('Cristian Bizer')
lee_graph.add_node('Tom Heath')
lee_graph.add_node('Soren Auer')
lee_graph.add_node('Lalana Kagal')
lee_graph.add_node('James A. Hendler')
lee_graph.add_node('Daniel J. Weitzner')

lee_graph.add_edge('Tim Berners-Lee', 'Christian Bizer', weight=17)
lee_graph.add_edge('Tim Berners-Lee', 'Tom Heath', weight=17)
lee_graph.add_edge('Tim Berners-Lee', 'Soren Auer', weight=10)
lee_graph.add_edge('Tim Berners-Lee', 'Lalana Kagal', weight=9)
lee_graph.add_edge('Tim Berners-Lee', 'James A. Hendler', weight=8)
lee_graph.add_edge('Tim Berners-Lee', 'Daniel J. Weitzner', weight=8)

print(lee_graph.nodes(data= True))
`print(lee_graph.edges(data=True))
```
",2018-12-13T14:43:29+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 1",lisasiurina,"```
from networkx import Graph

authors = Graph()

authors.add_node(""Tim Berners-Lee"")
authors.add_node(""Christian Bizer"")
authors.add_node(""Tom Heath"")
authors.add_node(""Sören Auer"")
authors.add_node(""Lalana Kagal"")
authors.add_node(""James A. Hendler"")

authors.add_edge(""Tim Berners-Lee"", ""Christian Bizer"", weight=17)
authors.add_edge(""Tim Berners-Lee"", ""Tom Heath"", weight=17)
authors.add_edge(""Tim Berners-Lee"", ""Sören Auer"", weight=10)
authors.add_edge(""Tim Berners-Lee"", ""Lalana Kagal"", weight=9)
authors.add_edge(""Tim Berners-Lee"", ""James A. Hendler"", weight=8)

print(authors.nodes(data=True))
print(authors.edges(data=True))```

[('Tim Berners-Lee', {}), ('Christian Bizer', {}), ('Tom Heath', {}), ('Sören Auer', {}), ('Lalana Kagal', {}), ('James A. Hendler', {})]
[('Tim Berners-Lee', 'Christian Bizer', {'weight': 17}), ('Tim Berners-Lee', 'Tom Heath', {'weight': 17}), ('Tim Berners-Lee', 'Sören Auer', {'weight': 10}), ('Tim Berners-Lee', 'Lalana Kagal', {'weight': 9}), ('Tim Berners-Lee', 'James A. Hendler', {'weight': 8})]

",2018-12-13T23:11:18+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 1",delfimpandiani,"```
from networkx import MultiGraph

network = MultiGraph()
# no need to add the notes separately, they are created on-the-go as the edges are created themselves

network.add_edge(""Tim Berners-Lee"", ""Christian Bizer"", weight=17)
network.add_edge(""Tim Berners-Lee"", ""Tom Heath"", weight=17)
network.add_edge(""Tim Berners-Lee"", ""Sören Auer"", weight=10)
network.add_edge(""Tim Berners-Lee"", ""Lalana Kagal"", weight=9)
network.add_edge(""Tim Berners-Lee"", ""James A. Hendler"", weight=8)
network.add_edge(""Tim Berners-Lee"", ""Daniel J. Weitzner"", weight=8)

print(network.nodes(data=True))
print(network.edges(data=True))

[('Tim Berners-Lee', {}), ('Christian Bizer', {}), ('Tom Heath', {}), ('Sören Auer', {}), ('Lalana Kagal', {}), ('James A. Hendler', {}), ('Daniel J. Weitzner', {})]
[('Tim Berners-Lee', 'Christian Bizer', {'weight': 17}), ('Tim Berners-Lee', 'Tom Heath', {'weight': 17}), ('Tim Berners-Lee', 'Sören Auer', {'weight': 10}), ('Tim Berners-Lee', 'Lalana Kagal', {'weight': 9}), ('Tim Berners-Lee', 'James A. Hendler', {'weight': 8}), ('Tim Berners-Lee', 'Daniel J. Weitzner', {'weight': 8})]

```",2018-12-14T19:14:25+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 1",mangiafrangette,"```
from networkx import Graph

tim_graph = Graph()

tim_graph.add_node(""Tim Berners-Lee"")
tim_graph.add_node(""Christian Bizer"")
tim_graph.add_node(""Tom Heath"")
tim_graph.add_node(""Sören Auer"")
tim_graph.add_node(""Lalana Kagal"")
tim_graph.add_node(""James A. Hendler"")

tim_graph.add_edge(""Tim Berners-Lee"", ""Christian Bizer"", weight=17)
tim_graph.add_edge(""Tim Berners-Lee"", ""Tom Heath"", weight=17)
tim_graph.add_edge(""Tim Berners-Lee"", ""Sören Auer"", weight=10)
tim_graph.add_edge(""Tim Berners-Lee"", ""Lalana Kagal"", weight=9)
tim_graph.add_edge(""Tim Berners-Lee"", ""James A. Hendler"", weight=8)

print(tim_graph.adj[""Tim Berners-Lee""])
```",2018-12-15T09:29:34+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 1",bluebell94,"from networkx import MultiGraph

team_coworkers=MultiGraph()
team_coworkers.add_node(""Tim Berners-Lee"")
team_coworkers.add_node(""Christian Brizer"")
team_coworkers.add_node(""Tom Heath"")
team_coworkers.add_node(""Sören Auer"")
team_coworkers.add_node(""Lalann Kagul"")
team_coworkers.add_node(""James A. Hendler"")

team_coworkers.add_edge(""Tim Berners-Lee"", ""Christian Brizer"", weight=17)
team_coworkers.add_edge(""Tim Berners-Lee"",""Tom Heath"", weight=17)
team_coworkers.add_edge(""Tim Berners-Lee"", ""Sören Auer"",weight=10)
team_coworkers.add_edge(""Tim Berners-Lee"", ""Lalann Kagul"", weight=9)
team_coworkers.add_edge(""Tim Berners-Lee"", ""James A. Hendler"", weight=8)

print(team_coworkers.nodes(data=True))
print(team_coworkers.edges(data=True))

print(team_coworkers.adj)

[('Tim Berners-Lee', {}), ('Christian Brizer', {}), ('Tom Heath', {}), ('Sören Auer', {}), ('Lalann Kagul', {}), ('James A. Hendler', {})]
[('Tim Berners-Lee', 'Christian Brizer', {'weight': 17}), ('Tim Berners-Lee', 'Tom Heath', {'weight': 17}), ('Tim Berners-Lee', 'Sören Auer', {'weight': 10}), ('Tim Berners-Lee', 'Lalann Kagul', {'weight': 9}), ('Tim Berners-Lee', 'James A. Hendler', {'weight': 8})]

{'Tim Berners-Lee': {'Christian Brizer': {0: {'weight': 17}}, 'Tom Heath': {0: {'weight': 17}}, 'Sören Auer': {0: {'weight': 10}}, 'Lalann Kagul': {0: {'weight': 9}}, 'James A. Hendler': {0: {'weight': 8}}}, 'Christian Brizer': {'Tim Berners-Lee': {0: {'weight': 17}}}, 'Tom Heath': {'Tim Berners-Lee': {0: {'weight': 17}}}, 'Sören Auer': {'Tim Berners-Lee': {0: {'weight': 10}}}, 'Lalann Kagul': {'Tim Berners-Lee': {0: {'weight': 9}}}, 'James A. Hendler': {'Tim Berners-Lee': {0: {'weight': 8}}}}


",2018-12-15T10:02:19+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 1",beccadelbens," ``` 
from networkx import Graph

first_graph = Graph()

first_graph.add_node(""Tim Berners Lee"")
first_graph.add_node(""Christian Bizer"")
first_graph.add_node(""Tom Heath"")
first_graph.add_node(""Soren Auer"")
first_graph.add_node(""Lalana Kagal"")
first_graph.add_node(""James A. Hendler"")

first_graph.add_edge(""Tim Berners Lee"", ""Christian Bizer"", weight=17)
first_graph.add_edge(""Tim Berners Lee"", ""Tom Heath"", weight=17)
first_graph.add_edge(""Tim Berners Lee"", ""Soren Auer"", weight=10)
first_graph.add_edge(""Tim Berners Lee"", ""Lalana Kagal"", weight=9)
first_graph.add_edge(""Tim Berners Lee"", ""James A. Hendler"", weight=8)

print(first_graph.edges(data=True))
#[('Tim Berners Lee', 'Christian Bizer', {'weight': 17}), ('Tim Berners Lee', 'Tom Heath', {'weight': 17}),
#('Tim Berners Lee', 'Soren Auer', {'weight': 10}), ('Tim Berners Lee', 'Lalana Kagal', {'weight': 9}),
#('Tim Berners Lee', 'James A. Hendler', {'weight': 8})]
 ``` ",2018-12-15T15:12:54+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 1",dafnikitsiki,"from networkx import MultiGraph

#create a new graph
tim_graph = MultiGraph()

#create five edges
tim_graph.add_edge(""Tim Berners Lee"", ""Tom Heath"", weight=17)
tim_graph.add_edge(""Tim Berners Lee"", ""Cristian Bizer"", wight=17)
tim_graph.add_edge(""Tim Berners Lee"", ""Soren Auer"", weight=10)
tim_graph.add_edge(""Tim Berners Lee"", ""Lalana Kagal"", weight=9)
tim_graph.add_edge(""Tim Berners Lee"", ""James A. Hendler"", weight=8)

print(tim_graph.edges(data=True))
@essepuntato is it correct not to create the nodes alone before creating the edges?",2018-12-15T16:04:02+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 1",essepuntato,"Hi @dafnikitsiki 

> @essepuntato is it correct not to create the nodes alone before creating the edges?

Yep, this is a totally feasible approach indeed.",2018-12-22T07:41:43+00:00
comp-think/2018-2019,"Lecture ""Organising information: graphs"", exercise 1",dafnikitsiki,Thank you very much for the reply!,2018-12-22T10:27:00+00:00
comp-think/2018-2019,"Lecture ""Organising information: trees"", exercise 2",SeverinJB,"_Note:_
The following test case [print(test_breadth_first_visit(book, list(LevelOrderIter(book))))] only works if the tree provided by Silvio is part of the same file. The complete code (with the tree) is in the correct order in the second snippet.

**Bugfix:**
The list _result_ did not reset itself after an execution of the algorithm. Consequently, every following execution just added its results to the existing list _result_. The bug was successfully fixed.

**+++ Algorithm with Test Cases +++**
```
from anytree import Node, LevelOrderIter

def test_iterating(input, expected):
    return expected == iterating(input)

def iterating(input, queue=list()):
	result = [input]
	queue.extend(input.children)

	while len(queue) > 0:
		result.append(queue[0])
		queue.extend(queue[0].children)
		queue.remove(queue[0])

	return result

print(test_iterating(book, list(LevelOrderIter(book))))
print(test_iterating(book, list(LevelOrderIter(book))))
```

**+++ Algorithm with Test Cases and Silvio's Tree +++**
```
from anytree import Node, LevelOrderIter

# Silvio's Tree
book = Node(""book"")
chapter_1 = Node(""chapter"", book)
chapter_2 = Node(""chapter"", book)

paragraph_1 = Node(""paragraph"", chapter_1)
text_1 = Node(""Alice was beginning to get very tired of sitting by ""
              ""her sister on the bank, and of having nothing to do: ""
              ""once or twice she had peeped into the book her sister ""
              ""was reading, but it had no pictures or conversations ""
              ""in it, "", paragraph_1)
quotation_1 = Node(""quotation"", paragraph_1)
text_2 = Node(""“and what is the use of a book,”"", quotation_1)
text_3 = Node("" thought Alice, "", paragraph_1)
quotation_2 = Node(""quotation"", paragraph_1)
text_4 = Node(""“without pictures or conversations?”"", quotation_2)

paragraph_2 = Node(""paragraph"", chapter_1)
text_5 = Node(""So she was considering in her own mind, (as well as ""
              ""she could, for the hot day made her feel very sleepy ""
              ""and stupid,) whether the pleasure of making a ""
              ""daisy-chain would be worth the trouble of getting up ""
              ""and picking the daisies, when suddenly a white rabbit ""
              ""with pink eyes ran close by her."", paragraph_2)

paragraph_3 = Node(""paragraph"", chapter_1)
text_6 = Node(""..."", paragraph_3)
text_7 = Node(""..."", chapter_2)
text_8 = Node(""..."", book)


# Test Function
def test_iterating(input, expected):
    return expected == iterating(input)

# Algorithm
def iterating(input, queue=list()):
	result = [input]
	queue.extend(input.children)

	while len(queue) > 0:
		result.append(queue[0])
		queue.extend(queue[0].children)
		queue.remove(queue[0])

	return result

# Test Case
print(test_iterating(book, list(LevelOrderIter(book))))
print(test_iterating(book, list(LevelOrderIter(book))))
```",2018-12-11T15:45:46+00:00
comp-think/2018-2019,"Lecture ""Organising information: trees"", exercise 2",friendlynihilist,"@essepuntato: that's my take on the exercise. It was very hard to understand how to manipulate properly nodes and I'm not quite sure about it. In the end I've used queues and lists to store ""discovered"" and ""visited"" nodes. I'll tweak it later. Also, as mentioned by @SeverinJB, I don't know if I was supposed to print node names or not.
I've attached tree rendering and printed queue:
![image](https://user-images.githubusercontent.com/41264663/49817228-f3e70180-fd6f-11e8-91db-c3e3513c5a91.png)
EDIT: updated with test case.
```
from anytree import Node, RenderTree, AsciiStyle
from collections import deque

book = Node(""Lanark"")
chapter_1 = Node(""Chapter I"", book)
chapter_2 = Node(""Chapter II"", book)
paragraph_1 = Node(""Paragraph 1"", chapter_1)
paragraph_2 = Node(""Paragraph 2"", chapter_1)
paragraph_3 = Node(""Paragraph 1"", chapter_2)
paragraph_4 = Node(""Paragraph 2"", chapter_2)
quotation_1 = Node(""He looked at them and saw their faces did not fit.""
                   "" The skin on the skulls crawled and twitched like half-solid paste."", paragraph_1)

renderer = RenderTree(book)
print(RenderTree(book, style=AsciiStyle()).by_attr())

def test_breadth_first_order(root_node, expected):
    result = breadth_first_order(root_node)
    if expected == result:
        return True
    else:
        return False


def breadth_first_order(root_node):
    queue = deque()
    result = [root_node.name]
    queue.append(root_node)

    while len(queue) > 0:
        for item in queue.popleft().children:
            result.append(item.name)
            queue.append(item)

    return result

print(test_breadth_first_order(book, ['Lanark', 'Chapter I', 'Chapter II', 'Paragraph 1', 'Paragraph 2', 'Paragraph 1', 'Paragraph 2', 'He looked at them and saw their faces did not fit. The skin on the skulls crawled and twitched like half-solid paste.']))
```",2018-12-11T17:04:40+00:00
comp-think/2018-2019,"Lecture ""Organising information: trees"", exercise 2",essepuntato,"Hi all,

I'm posting here my take on the exercise - you can find the source of this [online](https://comp-think.github.io/2018-2019/python/breadth_first_visit_iterative.py) as usual. It is worth mentioning that, usually, the breadth visit of a tree is seen as a typical example of **iterative** algorithm – that's why the solution of this exercise is smaller and more ""natural"" (at least from my perspective) than the [recursive one](#29).

```
from tree_instructions import *
from collections import deque


# Test case for the algorithm
def test_breadth_first_visit_iterative(root_node, expected):
    result = breadth_first_visit_iterative(root_node)
    if expected == result:
        return True
    else:
        return False


# Code of the algorithm
def breadth_first_visit_iterative(root_node):
    result = []
    to_visit = deque([root_node])

    while to_visit:
        node_to_visit = to_visit.popleft()
        result.append(node_to_visit)
        to_visit.extend(node_to_visit.children)

    return result


bfv = [book,
       chapter_1, chapter_2, text_8,
       paragraph_1, paragraph_2, paragraph_3, text_7,
       text_1, quotation_1, text_3, quotation_2, text_5, text_6,
       text_2, text_4]
print(test_breadth_first_visit_iterative(book, bfv))
```",2018-12-14T09:53:07+00:00
comp-think/2018-2019,"Lecture ""Organising information: trees"", exercise 2",delfimpandiani,"I had written this code before, but was still struggling to find a way of producing the desired output without knowing beforehand the number of generations present in the input tree. Now that I have seen Prof. Peroni's take, mine seems a tad convoluted. But I am happy it works, at least with the test case provided by Silvio.

```
def test_breadth_first_visit(root_node, expected):
    result = breadth_first_visit_iterative(root_node)
    if expected == result:
        return True
    else:
        return False

def breadth_first_visit(input):
    result = [input]
    generation1 = [input.children]
    generation2 = []
    generation3 = []
    generation4 = []
    generation_list = [generation1, generation2, generation3, generation4]
    for generation in generation_list:
        for gen_el in generation:
            result.append(gen_el)
            generation_list[index(generation) + 1].extend([gen_el.children])
    return result


bfv = [book,
       chapter_1, chapter_2, text_8,
       paragraph_1, paragraph_2, paragraph_3, text_7,
       text_1, quotation_1, text_3, quotation_2, text_5, text_6,
       text_2, text_4]
print(test_breadth_first_visit(book, bfv))
# True

```

",2018-12-14T17:59:37+00:00
comp-think/2018-2019,"Lecture ""Organising information: trees"", exercise 1",SeverinJB,"@essepuntato, Could you please clarify whether I interpreted the exercise correctly? 
I struggle(d) with this exercise because of your request ""[...] should return the following list: [book, chapter_1, chapter_2, text_8, ...]"". In beginning, I tried to take you literally and to return a list which contains [book, chapter_1, chapter_2, text_8, ...]. After studying the documentation of _[anytree](https://anytree.readthedocs.io/)_, however, I realised this is kind of meta-meta-programming and not easily done. Also, I realised you would have written the strings in quotes: [""book"", ""chapter_1"", ""chapter_2"", ""text_8"", ...]. 
The following algorithm, hence, returns a list which contains in level-order (your requested order) all nodes of any given tree, i.e. [Node('/book'), Node('/book/chapter'), Node('/book/chapter'), Node('/book/...'), ...]

_Note:_
The following test case [print(test_breadth_first_visit(book, list(LevelOrderIter(book))))] only works if the tree provided by Silvio is part of the same file. The complete code (with the tree) is in the correct order in the second snippet. 

**Bugfix:**
The list _result_ did not reset itself after an execution of the algorithm. Consequently, every following execution just added its results to the existing list _result_. The bug was successfully fixed. 

**Update:**
The suggestion of Peroni was implemented. Both if conditions ""if len(queue) >= 1:"" and ""if len(queue) != 0:"" are now reduced to ""if queue:"". Sleek!

**+++ Algorithm with Test Cases +++**
```
from anytree import Node, LevelOrderIter

# Test Function
def test_breadth_first_visit(input, expected):
    return expected == breadth_first_visit(input)

# Algorithm
def breadth_first_visit(input, queue=[]):
    if queue:
        queue.remove(queue[0])

    result = [input]
    queue.extend(input.children)

    if queue: 
        result.extend(breadth_first_visit(queue[0]))

    return result

# Test Case
print(test_breadth_first_visit(book, list(LevelOrderIter(book))))
print(test_breadth_first_visit(book, list(LevelOrderIter(book))))
```
**+++ Algorithm with Test Cases and Silvio's Tree +++**
```
from anytree import Node, LevelOrderIter

# Silvio's Tree
book = Node(""book"")
chapter_1 = Node(""chapter"", book)
chapter_2 = Node(""chapter"", book)

paragraph_1 = Node(""paragraph"", chapter_1)
text_1 = Node(""Alice was beginning to get very tired of sitting by ""
              ""her sister on the bank, and of having nothing to do: ""
              ""once or twice she had peeped into the book her sister ""
              ""was reading, but it had no pictures or conversations ""
              ""in it, "", paragraph_1)
quotation_1 = Node(""quotation"", paragraph_1)
text_2 = Node(""“and what is the use of a book,”"", quotation_1)
text_3 = Node("" thought Alice, "", paragraph_1)
quotation_2 = Node(""quotation"", paragraph_1)
text_4 = Node(""“without pictures or conversations?”"", quotation_2)

paragraph_2 = Node(""paragraph"", chapter_1)
text_5 = Node(""So she was considering in her own mind, (as well as ""
              ""she could, for the hot day made her feel very sleepy ""
              ""and stupid,) whether the pleasure of making a ""
              ""daisy-chain would be worth the trouble of getting up ""
              ""and picking the daisies, when suddenly a white rabbit ""
              ""with pink eyes ran close by her."", paragraph_2)

paragraph_3 = Node(""paragraph"", chapter_1)
text_6 = Node(""..."", paragraph_3)
text_7 = Node(""..."", chapter_2)
text_8 = Node(""..."", book)


# Test Function
def test_breadth_first_visit(input, expected):
    return expected == breadth_first_visit(input)

# Algorithm
def breadth_first_visit(input, queue=[]):
    if queue:
        queue.remove(queue[0])

    result = [input]
    queue.extend(input.children)

    if queue: 
        result.extend(breadth_first_visit(queue[0]))

    return result

# Test Case
print(test_breadth_first_visit(book, list(LevelOrderIter(book))))
print(test_breadth_first_visit(book, list(LevelOrderIter(book))))
```",2018-12-11T15:41:05+00:00
comp-think/2018-2019,"Lecture ""Organising information: trees"", exercise 1",essepuntato,"Hi @SeverinJB,

> The following algorithm, hence, returns a list which contains in level-order (your requested order) all nodes of any given tree, i.e. [Node('/book'), Node('/book/chapter'), Node('/book/chapter'), Node('/book/...'), ...]

This is exactly what I wanted, since the various variables I've used in the example in the text of exercise the are actually references to objects.",2018-12-12T06:50:16+00:00
comp-think/2018-2019,"Lecture ""Organising information: trees"", exercise 1",SeverinJB,"> This is exactly what I wanted, since the various variables I've used in the example in the text of exercise the are actually references to objects.

@essepuntato Thanks, for the response. ",2018-12-12T07:38:55+00:00
comp-think/2018-2019,"Lecture ""Organising information: trees"", exercise 1",essepuntato,"Hi all,

I'm posting here my take on the exercise - you can find the source of this [online](https://comp-think.github.io/2018-2019/python/breadth_first_visit_recursive.py) as usual. 

The solution I prepared does not change the signature of the function (i.e. the way the input parameters are defined), but actually specifies different variables as input of the recursive calls – this is possible in Python since it is a [dynamically typing language](https://stackoverflow.com/questions/1517582/what-is-the-difference-between-statically-typed-and-dynamically-typed-languages). In practice, I reconstruct, in a ditionary, all the nodes in all the levels of the tree, and only at the very end (i.e. within the first call) I reconstruct the list to return.

Of course, this is not the only approach that can be used. In fact, as far as I can see, @SeverinJB's one works very well, and (at least from what I can see) it is even more elegant than the one I'm proposing here. Great job!

```
from tree_instructions import *


# Test case for the algorithm
def test_breadth_first_visit_recursive(root_node, expected):
    result = breadth_first_visit_recursive(root_node)
    if expected == result:
        return True
    else:
        return False


# Code of the algorithm
def breadth_first_visit_recursive(root_node):
    n_ancestors = len(root_node.ancestors)

    if n_ancestors == 0:
        cur_node = root_node
        levels = {}
    else:
        cur_node = root_node[0]
        levels = root_node[1]

    max_level = n_ancestors
    add_to_level(cur_node, n_ancestors, levels)

    for child in cur_node.children:
        cur_level = breadth_first_visit_recursive((child, levels))
        if cur_level > max_level:
            max_level = cur_level

    if n_ancestors:
        return max_level
    else:
        result = []
        for level in range(max_level + 1):
            result.extend(levels[level])
        return result


def add_to_level(node, level, levels):
    if level not in levels:
        levels[level] = []
    levels[level].append(node)


bfv = [book,
       chapter_1, chapter_2, text_8,
       paragraph_1, paragraph_2, paragraph_3, text_7,
       text_1, quotation_1, text_3, quotation_2, text_5, text_6,
       text_2, text_4]
print(test_breadth_first_visit_recursive(book, bfv))
```",2018-12-14T09:48:10+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 2",simayguzel,"```
def test_merge_sort(input_list, expected):

    result = merge_sort(input_list)

    if result == expected:
        return True
    else:
        return False

def merge_sort(input_list):
    input_list_len = len(input_list)

    if len(input_list) <= 1:
        return input_list
    else:
        mid = input_list_len // 2
        l = (merge_sort(input_list[0:mid]))
        r = (merge_sort(input_list[mid:input_list_len]))
        return merge(l,r)

def merge(l,r):
    result = list()

    while len(l) > 0 and len(r) > 0:
        left_item = l[0]
        right_item = r[0]


        if left_item < right_item:
            result.append(left_item)
            l.remove(left_item)

        else:
            result.append(right_item)
            r.remove(right_item)

    
    result.extend(l)
    result.extend(r)

    return result


input_list = ([""Coraline"", ""American Gods"", ""Neverwhere"", ""Neverwhere"", ""American Gods"", ""Coraline""])

print(test_merge_sort([""Coraline"", ""American Gods"", ""Neverwhere"", ""Neverwhere"", ""American Gods"", ""Coraline""],['American Gods', 'American Gods', 'Coraline', 'Coraline', 'Neverwhere', 'Neverwhere']))  #True
```
",2018-12-08T16:08:19+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 2",EleonoraPeruch,"```
from merge import merge


# test for the algorithm
def test_merge_sort(books_list, expected, d=dict()):
    result = merge_sort(books_list, d=dict())
    if result == expected:
        return True
    else:
        return False

def merge_sort(books_list, d=dict()):
    books_list_len = len(books_list)  # base case
    if len(books_list)<= 1:
        return books_list
    else:
        mid = books_list_len // 2  # divide step
        left_books_list = books_list[0:mid]
        right_books_list = books_list[mid:books_list_len]

        # recursive step
        left = merge_sort(books_list[0:mid])
        right = merge_sort(books_list[mid:books_list_len])

        # dictionary used as input in case the same list of books must be ordered more than one time
        # dynamic programming approach
        if left_books_list == right_books_list:
            d[right] = left

        return merge(left, right) # combine

print(test_merge_sort([""Coraline"", ""American Gods"", ""Neverwhere"", ""Neverwhere"", ""American Gods"", ""Coraline""], [""American Gods"", ""American Gods"", ""Coraline"", ""Coraline"", ""Neverwhere"", ""Neverwhere""], ({})))
print(test_merge_sort([""Heart of Darkness"", ""Wuthering Heights"", ""Twelfth Night"", ""Twelfth Night"", ""Wuthering Heights"", ""Heart of Darkness""], [""Heart of Darkness"", ""Heart of Darkness"", ""Twelfth Night"", ""Twelfth Night"", ""Wuthering Heights"", ""Wuthering Heights""], ({})))

# True
# True
```",2018-12-09T09:08:48+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 2",SeverinJB,"_Note:_
This dynamic merge sort algorithm saves results for a partial list of an input list if the partial list itself was used as an input in the recursive part of the algorithm. For example, after having ordered [9, 6, 8, 7, 0], the result for the partial list [8, 7, 0] can be retrieved from the dictionary. However, the partial list [6, 8, 7] is not stored in the dictionary and has to be ordered itself. The difference is that the latter was never used as an input of the recursive merge_sort_dp(). Whereas the first partial list was used as an input.

**+++ Dynamic Merge Sort with Test Cases +++**
```
# Test Function
def test_merge_sort_dp(input_list, expected):
    return expected == merge_sort_dp(input_list)

# Merge Algorithm 
def merge_dp(left_list, right_list): 
    left = left_list.copy()
    right = right_list.copy()
    result = list()

    while len(left) > 0 and len(right) > 0:
        left_item = left[0] 
        right_item = right[0]
        
        if left_item < right_item:
            result.append(left_item)
            left.remove(left_item)
        else:
            result.append(right_item) 
            right.remove(right_item)
    
    result.extend(left)
    result.extend(right)
    return result

# Merge Sort Algorithm
def merge_sort_dp(input_list, d=dict()):
    input_list_len = len(input_list)
    key = ''.join(map(str, input_list))

    if key not in d:
        if len(input_list) <= 1:
            d[key] = input_list
        else:
            mid = input_list_len // 2
            left = merge_sort_dp(input_list[0:mid])
            right = merge_sort_dp(input_list[mid:input_list_len])
            d[key] = merge_dp(left, right)

    return d[key]
    
# Test Cases 
print(test_merge_sort_dp([3,4,1,5,2,9,6,8,7,0],[0,1,2,3,4,5,6,7,8,9]))
print(test_merge_sort_dp([9, 6, 8, 7, 0],[0, 6, 7, 8, 9]))
print(test_merge_sort_dp([8, 7, 0],[0, 7, 8]))
print(test_merge_sort_dp([3, 4, 1, 5, 2],[1, 2, 3, 4, 5]))
print(test_merge_sort_dp([3,4,1,5,2,9,6,8,7,0],[0,1,2,3,4,5,6,7,8,9]))
print(test_merge_sort_dp([""B"",""C"",""F"",""A"",""G"",""E"",""H"",""J"",""D"",""I""],[""A"",""B"",""C"",""D"",""E"",""F"",""G"",""H"",""I"",""J""]))
print(test_merge_sort_dp([""B"",""C"",""A"",""E"",""D""],[""A"",""B"",""C"",""D"",""E""]))
```",2018-12-09T16:14:40+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 2",delfimpandiani,"> _Note:_
> This dynamic merge sort algorithm saves results for a partial list of an input list if the partial list itself was used as an input in the recursive part of the algorithm. For example, after having ordered [9, 6, 8, 7, 0], the result for the partial list [8, 7, 0] can be retrieved from the dictionary. However, the partial list [6, 8, 7] is not stored in the dictionary and has to be ordered itself. The difference is that the latter was never used as an input of the recursive merge_sort_dp(). Whereas the first partial list was used as an input.
> 
> **+++ Dynamic Merge Sort with Test Cases +++**
> 
> ```
> # Test Function
> def test_merge_sort_dp(input_list, expected):
>     return expected == merge_sort_dp(input_list)
> 
> # Merge Algorithm 
> def merge_dp(left_list, right_list): 
>     left = left_list.copy()
>     right = right_list.copy()
>     result = list()
> 
>     while len(left) > 0 and len(right) > 0:
>         left_item = left[0] 
>         right_item = right[0]
>         
>         if left_item < right_item:
>             result.append(left_item)
>             left.remove(left_item)
>         else:
>             result.append(right_item) 
>             right.remove(right_item)
>     
>     result.extend(left)
>     result.extend(right)
>     return result
> 
> # Merge Sort Algorithm
> def merge_sort_dp(input_list, d=dict()):
>     input_list_len = len(input_list)
>     key = ''.join(map(str, input_list))
> 
>     if key not in d:
>         if len(input_list) <= 1:
>             d[key] = input_list
>         else:
>             mid = input_list_len // 2
>             left = merge_sort_dp(input_list[0:mid])
>             right = merge_sort_dp(input_list[mid:input_list_len])
>             d[key] = merge_dp(left, right)
> 
>     return d[key]
>     
> # Test Cases 
> print(test_merge_sort_dp([3,4,1,5,2,9,6,8,7,0],[0,1,2,3,4,5,6,7,8,9]))
> print(test_merge_sort_dp([9, 6, 8, 7, 0],[0, 6, 7, 8, 9]))
> print(test_merge_sort_dp([8, 7, 0],[0, 7, 8]))
> print(test_merge_sort_dp([3, 4, 1, 5, 2],[1, 2, 3, 4, 5]))
> print(test_merge_sort_dp([3,4,1,5,2,9,6,8,7,0],[0,1,2,3,4,5,6,7,8,9]))
> print(test_merge_sort_dp([""B"",""C"",""F"",""A"",""G"",""E"",""H"",""J"",""D"",""I""],[""A"",""B"",""C"",""D"",""E"",""F"",""G"",""H"",""I"",""J""]))
> print(test_merge_sort_dp([""B"",""C"",""A"",""E"",""D""],[""A"",""B"",""C"",""D"",""E""]))
> ```

@SeverinJB Sevi, could you explain your thinking process behind editing the merge() algorithm definition, when you added
>     left = left_list.copy()
>     right = right_list.copy()
in its definition? I am trying to understand why this is necessary to make your merge_sort_dp() work. As I tried your code without editing merge() in the way you did, and it doesn't work. 
Would be awesome if you could explain your thinking process also in general!",2018-12-11T12:37:12+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 2",delfimpandiani,"My approach, based on a mix of Severin's and Eleonora's approaches but with a focus on labelling each of the 5 steps of dynamic programming. 
STEP 1: base case - solution already exists
STEP 2: base case - easy-to-solve, approach directly
STEP 3: divide
STEP 4: conquer
STEP 5: combine
STEP 6: memorize

I created an ancillary function list_to_key() to handle the key label creations for each element in the dictionary separately.

```
# ____________MERGE_________________________
def merge(left_list, right_list):    
    left = left_list.copy()
    right = right_list.copy()
    result = list()

    while len(left) > 0 and len(right) > 0:
        left_item = left[0] 
        right_item = right[0]
        
        if left_item < right_item:
            result.append(left_item)
            left.remove(left_item)
        else:
            result.append(right_item) 
            right.remove(right_item)
    
    result.extend(left)
    result.extend(right)
    return result

#_______ANCILLARY FUNCT: LIST_TO_KEY()_______
def list_to_key(input_list):
    key_list = list() 
    for item in input_list:
        str_item = str(item)
        key_list.append(str_item)
    key_name = """"
    for i in key_list:
        key_name += str(i)
    return key_name

#__________TEST_DYNAMIC _MSORT_________________
def test_dynamic_msort(input_list, expected, d=dict()):
    result = dynamic_msort(input_list, d=dict())
    if result == expected:
        return True
    else:
        return False
        
#_____________DYNAMIC _MSORT_________________
def dynamic_msort(input_list, d=dict()):
    len_input_list = len(input_list)
    key = list_to_key(input_list)
    
    if key in d: # STEP 1-base case: solution exists
        return d[key]
    elif len_input_list <= 1: # STEP 2-base case: address directly
        d[key] = input_list
        return d[key]
    else: #recursive step
        mid = len_input_list // 2  # STEP 3- divide
        left_list = input_list[0:mid]
        right_list = input_list[mid:len_input_list]
        left = dynamic_msort(left_list) # STEP 4-conquer
        right = dynamic_msort(right_list) # STEP 4conquer
        merged_list = merge(left, right) # STEP 5 -combine
        d[key] = merged_list # STEP 6- memorize
        return d[key]


print(test_dynamic_msort([3,4,1,5,2,9,6,8,7,0],[0,1,2,3,4,5,6,7,8,9]))
print(test_dynamic_msort([9, 6, 8, 7, 0],[0, 6, 7, 8, 9]))
print(test_dynamic_msort([8, 7, 0],[0, 7, 8]))
print(test_dynamic_msort([3, 4, 1, 5, 2],[1, 2, 3, 4, 5]))
print(test_dynamic_msort([3,4,1,5,2,9,6,8,7,0],[0,1,2,3,4,5,6,7,8,9]))
print(test_dynamic_msort([""B"",""C"",""F"",""A"",""G"",""E"",""H"",""J"",""D"",""I""],[""A"",""B"",""C"",""D"",""E"",""F"",""G"",""H"",""I"",""J""]))
print(test_dynamic_msort([""B"",""C"",""A"",""E"",""D""],[""A"",""B"",""C"",""D"",""E""]))

# True
# True
# True
# True
# True
# True
# True

```


@SeverinJB  I figured it out the merge() edit on my own! We need to use copies of the lists, because otherwise our dictionaries are corrupted every time we run the merge() function.",2018-12-11T14:59:33+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 2",SeverinJB,"> 
> @SeverinJB Sevi, could you explain your thinking process behind editing the merge() algorithm definition, when you added
> 
> > ```
> > left = left_list.copy()
> > right = right_list.copy()
> > ```

> @SeverinJB I figured it out the merge() edit on my own! We need to use copies of the lists, because otherwise our dictionaries are corrupted every time we run the merge() function.

Hi @delfimpandiani,

Sorry for not coming back to your questions earlier. 

_For clarification:_
With **copy_list = main_list** only the reference is copied. It's like the computer is storing the list with a generic name ""281x829yez"", but there are now two human-readable names (copy_list and main_list) which can be used to address the list. Hence, when copy_list is modified main_list is simultaneously modified! The additional ""copy()"" in **copy_list = main_list.copy()** creates an actual copy of main_list and stores this copy in copy_list.

Hopefully, this helps.",2018-12-11T16:01:13+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 2",essepuntato,"Hi all,

Here my take on the exercise - source codes available [online](https://comp-think.github.io/2018-2019/python/merge_sort_dp.py).

```
# Import the function 'merge' from the module 'merge' (file 'merge.py')
from merge import merge


# Test case for the algorithm
def test_merge_sort_dp(input_list, expected):
    result = merge_sort_dp(input_list)
    if expected == result:
        return True
    else:
        return False


# Code of the algorithm
def merge_sort_dp(input_list, prev_l=list()):
    result = find_solution(input_list, prev_l)

    if result is None:
        if len(input_list) <= 1:
            result = input_list
            store_solution(result, prev_l)
        else:
            input_list_len = len(input_list)
            mid = input_list_len // 2

            left = merge_sort_dp(input_list[0:mid], prev_l)
            right = merge_sort_dp(input_list[mid:input_list_len], prev_l)
            result = merge(left, right)
            store_solution(result, prev_l)
    return result


def find_solution(input_list, sol_list):
    input_dic = create_list_dict(input_list)
    for d, sol in sol_list:
        if input_dic == d:
            return list(sol)


def store_solution(input_list, solution_list):
    d = create_list_dict(input_list)
    solution_list.append((d, list(input_list)))


def create_list_dict(input_list):
    d = {}
    for el in input_list:
        if el not in d:
            d[el] = 0
        d[el] = d[el] + 1
    return d


print(test_merge_sort_dp([], []))
print(test_merge_sort_dp([1], [1]))
print(test_merge_sort_dp([3, 4, 1, 2, 9, 8, 2], [1, 2, 2, 3, 4, 8, 9]))
print(test_merge_sort_dp([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""],
                         [""American Gods"", ""Coraline"", ""Good Omens"", ""Neverwhere"", ""The Graveyard Book""]))
print(test_merge_sort_dp([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere"", ""American Gods"",
                          ""American Gods"", ""Good Omens"", ""The Graveyard Book"", ""American Gods"", ""Neverwhere"", ""Coraline""],
                         [""American Gods"", ""American Gods"",""American Gods"", ""American Gods"", ""Coraline"", ""Coraline"",
                          ""Good Omens"", ""Good Omens"", ""Neverwhere"",  ""Neverwhere"", ""The Graveyard Book"", ""The Graveyard Book""]))
```",2018-12-14T10:20:25+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 2",MilenaCorbellini,"I didn't see the solution of the exercise again. I tried to create an algoritm but I'm not sure of the efficiency, because it returns the result, but maybe it iterates in an unneccessary way. Could it work?
````
def test_merge(left_list, right_list, expected):
    result = merge(left_list, right_list)
    if expected == result:
        return True
    else:
        return False

def merge(left_list, right_list):
    result = list()

    while len(left_list) > 0 and len(right_list) > 0:
        left_item = left_list[0]
        right_item = right_list[0]


        if left_item < right_item:
            result.append(left_item)
            left_list.remove(left_item)

        else:
            result.append(right_item)
            right_list.remove(right_item)

    result.extend(left_list)
    result.extend(right_list)

    return result


def test_merge_sort(input_list, expected, d):
    if merge_sort(input_list, d) == expected:
        return True
    else:
        return False

def merge_sort(input_list, d):
    input_list_len = len(input_list)
    for item in input_list:
        if item not in d:
            if input_list_len <= 1:
                d[merge] = input_list



            else:
                mid = input_list_len // 2

                left = merge_sort(input_list[0:mid], d)
                right = merge_sort(input_list[mid:input_list_len], d)
                d[merge] = merge(left, right)

            return d[merge]


print(test_merge_sort([""Coraline"", ""American Gods"", ""Neverwhere"", ""Neverwhere"", ""American Gods"", ""Coraline""],
                      ['American Gods', 'American Gods', 'Coraline', 'Coraline', 'Neverwhere', 'Neverwhere'], ({})))
````",2018-12-14T15:34:24+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 1",HiImBono,"Hi prof and others,

I did not really understand the point of this exercise since,

If one would draw a tree chart for the multiplication 3×4 according to the example (listing 3) in lecture 'Recursion'  there will be no repeating sub-solutions. Meaning that when a sub-solution is stored in the dictionary it will not be used again. 

I am correct or am I missing the point?",2018-12-05T14:39:07+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 1",hizclick,"@HiImBono 
example:
I t
2* 4 means 2 + 2 + +2 + 2 or 4 + 4
so 
    step 1: 2 + 2
    step 2: 2 + 4
   step 3: 2 + 6
we can use recurssion to solve this problem.
 i think in this way we can compute it 
```..
def test_multiplication(n1, n2,  expected, d=dict()):
    if multiplication(n1, n2, d=dict()) == expected:
        return True
    else:
        return False
def multiplication(n1, n2, d=dict()):
    if n2 not in d:
        if n2 == 0: 
            d[n2] = n2
        else:
            d[n2]= n1 + multiplication(n1, n2 - 1, d)
    
    return d[n2]
print(test_multiplication(4,3,12)) #True
print(test_multiplication(5,2,10)) #True
print(test_multiplication(3,3,9)) #True
```





",2018-12-05T15:22:41+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 1",federicabologna,"```
def test_mult_dp(n1, n2, d, exp):
    if exp == mult_dp(n1, n2, d):
        return True
    else:
        return False

def mult_dp(n1, n2, d):
    if n2 not in d:
        if n2 == 0:
           d[n2] = 0
        elif n2 == 1:
           d[n2] = n1
        else:
            d[n2] = n1 + mult_dp(n1, n2-1, d)

    return d[n2]

print(test_mult_dp(15, 67, {}, 1005))
print(test_mult_dp(45, 6, {}, 270))
print(test_mult_dp(39, 16, {}, 624))

True
True
True
```",2018-12-05T15:54:02+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 1",EleonoraPeruch,"```
# test for the algorithm
def test_multiplication(int_1, int_2, expected, solution_dict):
    result = multiplication(int_1, int_2, solution_dict)
    if expected == result:
        return True
    else:
        return False

# code of the algorithm
def multiplication(int_1, int_2, solution_dict):
    # checking if a solution exists
    if int_2 not in solution_dict:
        if int_2 == 0: # base case
            solution_dict[int_2] = int_2  # if the input int is 0 return that input int 
        else:   # recursive step
            solution_dict[int_2] = int_1 + multiplication(int_1, int_2 - 1, solution_dict) # store the result of the multiplication in the
    return solution_dict[int_2]                                                                                          # dictionary using the original input as key
    

# run some tests
print(test_multiplication(0, 1, 0, ({})))
print(test_multiplication(3, 0, 0, ({})))
print(test_multiplication(0, 0, 0, ({})))
print(test_multiplication(3, 4, 12, ({})))
print(test_multiplication(1, 1, 1, ({})))

True
True
True
True
True
```",2018-12-05T22:59:03+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 1",delfimpandiani,"```
def test_mult_dp(multiplied, multiplier, expected):
    result = mult_dp(multiplied, multiplier)
    if expected == result:
        return True
    else:
        return False

# the dictionary is going to be specific for our multiplied,
# and will hold keys of the form --> [multiplier] : result
def mult_dp(multiplied, multiplier, d=dict()):
    
    if multiplier not in d: # Checking if a solution exists
        if multiplier == 0:  # base case
            d[multiplier] = multiplier
        elif multiplier == 1:  # second base case
            d[multiplier] = multiplied
        else:  # recursive step
            # the dictionary will be passed as input of the recursive calls of the algorithm
            d[multiplier] = multiplied + mult_dp(multiplied, (multiplier-1), d)
        return d[multiplier]


print(test_mult_dp(3, 4, 12))
print(test_mult_dp(0, 0, 0))
```",2018-12-06T11:34:15+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 1",simayguzel,"```

def test_multiplication(a, b, dic, expected):

    result = multiplication(a, b, dic)
    if result == expected:
        return True
    else:
        return False

def multiplication(a, b, dic=dict()):
    if b not in dic:
        if b == 0:
            dic[b] = 0
        if b == 1:
            dic[b] = a
        elif b < 0:
            dic[b] = -(a - multiplication(a, b+1, dic))
            return dic[b]
        else:
            dic[b] = a + multiplication(a, b-1, dic)
    return dic[b]
print(test_multiplication(3, 4,({}),12))   #True
print((test_multiplication(-3,-4,({}), 12)))   #True
print(test_multiplication(2,0,({}),0))    #True
print(test_multiplication(-10,1,({}),-10))    #True
```",2018-12-08T10:32:51+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 1",beccadelbens,"```
def test_multiplication(n1, n2, d, expected):
    result = multiplication(n1, n2, d)
    if result == expected:
        return True
    else:
        return False

def multiplication(n1, n2, d={}):
    if n2 < 0:
        n1 = -n1
        n2 = -n2

    key = str(n1) + ""-"" + str(n2)

    if key not in d:
        if n2 == 0:
            return 0
        d[key] = n1 + multiplication(n1, n2-1, d)

    return d[key]

d = {}

print(test_multiplication(3, 4, d, 12)) # True
print(test_multiplication(5, 5, d, 25)) # True
print(test_multiplication(-6, 3, d, -18)) # True
```

",2018-12-09T09:20:04+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 1",SeverinJB,"_Note:_ 
This dynamic multiplication algorithm recognises if two numbers had been multiplied before. The algorithm creates a dictionary which contains all the product which had been calculated during previous execution. The key is created based on the two factors. The content of this dictionary can be used even if the algorithm is called with new entry values. For example, after multiplying the factors ""5"" and ""7"", the product for ""3x5"" or ""5x1"" can be retrieved from the dictionary. (The order of the factors makes no difference while searching for previous multiplication.)

**+++ Dynamic Multiplication Algorithm +++**
```
# Test Function
def test_multiplication_dp(int_1, int_2, expected): 
    return expected == multiplication_dp(int_1, int_2)  
        
# Algorithm 
def multiplication_dp(int_1, int_2, d=dict()):
    if int_1 < int_2:
        key = str(int_1) + str(int_2)
    else:
        key = str(int_2) + str(int_1)

    if key not in d:
        if int_2 == 0: 
            return 0 
        else:            
            d[key] = int_1 + multiplication_dp(int_1, int_2 - 1) 

    return d[key]

# Test Cases
print(test_multiplication_dp(5, 7, 35))
print(test_multiplication_dp(5, 1, 5))
print(test_multiplication_dp(2, 5, 10))
print(test_multiplication_dp(5, 3, 15))
print(test_multiplication_dp(5, 4, 20))
print(test_multiplication_dp(5, 5, 25))
print(test_multiplication_dp(7, 5, 35))
```",2018-12-09T16:14:35+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 1",tceron,"```
def test_multiplication(int_1, int_2, solution_dict, expected):     
    result = multiplication(int_1, int_2, solution_dict)     
    if expected == result:         
        return True     
    else:         
        return False 

def multiplication(int_1, int_2, solution_dict):
    if int_2 not in solution_dict:   #check whether it's in the dict
        if int_2 == 0:
            solution_dict[int_2] = int_2
        else:
            solution_dict[int_2] = int_1 + multiplication(int_1, int_2 -1, solution_dict)  #store info in the dict
    return solution_dict[int_2]
```
print(test_multiplication(0, 0, ({}), 0))     #true
print(test_multiplication(1, 1, ({}), 1))     #true
print(test_multiplication(5, 2, ({}), 10))    #true
print(test_multiplication(8, 3, ({}), 24))    #true
print(test_multiplication(6, 5, ({}), 30))     #true",2018-12-09T16:49:55+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 1",SeverinJB,"Guys, I'd like to give some feedback if you don't mind.

It seems like only the algorithm of @beccadelbens works. All the other algorithms contain at least one of the following two errors: 

1. Resetting the Dictionary
The dictionary is only useful if it is available for future executions of the algorithm. Given the formula n1 x n2 = n1 + (n​1 x (n​2 - 1)), the algorithm has to calculate every pair of two factors only once. Hence, the content of the dictionary is not used during the first run of the algorithm. However, if the dictionary is available for future executions the algorithm can save​ computation time if the searched product has common factors with previous products. For example, after having calculated ""6x6"" the algorithm can retrieve the product for ""6x3"" from the dictionary.
The reset was done with an empty dictionary as input value ""test_multiplication_dp(5, 7, 35, ({}))"" or ""test_multiplication_dp(5, 7, 35, d=dict())"". (The ""d=dict()"" is only necessary to define a standard value for d in the def of a new function, but will reset the dictionary if used during the execution of an algorithm.)

2. Using One Factor as Key
If only one factor is used as a key, the algorithm fails for many multiplications​ in which one factor is matching the key, but the other factor has changed. For example, if the factor ""6"" of the calculation ""9x6"" was used as a key, the algorithm will save ""54"" as value for the key ""6"". Hence, the algorithm will return a wrong value for the calculation ""10x6"". Since the algorithm will search the dictionary for the key ""6"" and will return the value ""54"" instead of returning ""60"".

Hopefully, this is helpful. Correct me if I am mistaken. 

Cheers, 
Sevi ✌️",2018-12-09T16:50:14+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 1",andreamust,"```
def test_multiplication(n_1, n_2, expected, d=dict()):
    result = multiplication(n_1, n_2, d=dict())
    if result == expected:
        return True
    else:
        return False

def multiplication(n_1, n_2, d=dict()):
    if n_2 not in d:
        if n_2 == 0:
            d[n_2] = 0
        else:   #recursive step
            d[n_2] = n_1 + multiplication(n_1, n_2 - 1, d)
        return d[n_2]

print(test_multiplication(8, 8, 64, ({})))    #True
print(test_multiplication(2, 9, 18, ({})))    #True
print(test_multiplication(20, 0, 0, ({})))    #True
```",2018-12-09T17:20:37+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 1",lisasiurina,"@SeverinJB thank you for pointing out the errors:

```def multiplication(int_1, int_2, solution_dict, expected):
    result = multiplication(int_1, int_2, solution_dict)
    if result == expected:
        return True
    else:
        return False

def multiplication(int_1, int_2, solution_dict={}):
    if int_2 not in solution_dict:
     if int_2 < 0:
        int_1 = -int_1
        int_2 = -int_2

    key = str(int_1) + ""-"" + str(int_2)

    if key not in solution_dict:
        if (int_2) == 0:
            return 0
        solution_dict[key] = int_1 + multiplication(int_1, int_2 - 1, solution_dict)
        
    return solution_dict[key]
```
",2018-12-09T19:04:18+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 1",friendlynihilist,"Thank you @SeverinJB for your feedback, it was really helpful.

```
def test_multiplication(int_1, int_2, d, expected):
    result = multiplication(int_1, int_2, d)
    if expected == result:
        return True
    else:
        return False


def multiplication(int_1, int_2, d={}):

    cache = str(int_1) + ""-"" + str(int_2)
    if cache not in d:
        if int_2 == 0:
            return 0
        else:
            d[cache] = int_1 + multiplication(int_1, int_2 - 1, d)
    return d[cache]


print(test_multiplication(5, 5, ({}), 25))
print(test_multiplication(7, 5, ({}), 35))
print(test_multiplication(0, 0, ({}), 0))
print(test_multiplication(44, 44, ({}), 1936))
```",2018-12-11T10:45:53+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 1",MilenaCorbellini,"````
def test_multiplication(n_1, n_2, expected, d = dict()):
    if multiplication(n_1, n_2, d=dict()) == expected:
        return True
    else:
        return False

def multiplication(n_1, n_2, d=dict()):

    if n_2 not in d:
        if n_2 == 0:
            d[n_2] = n_2
        else:
             d[n_2] = n_1 + multiplication(n_1, n_2 - 1, d)

    return d[n_2]
print(test_multiplication(0, 0, 0, ({})))
print(test_multiplication(1, 0, 0, ({})))
print(test_multiplication(5, 7, 35, ({})))
````
",2018-12-13T19:37:16+00:00
comp-think/2018-2019,"Lecture ""Dynamic programming algorithms"", exercise 1",essepuntato,"Hi all,

Here my take on the exercise - source codes available [online](https://comp-think.github.io/2018-2019/python/multiplication_dp.py).

```
# Test case for the algorithm
def test_multiplication(int_1, int_2, solution_dict, expected):
    result = multiplication(int_1, int_2, solution_dict)
    if expected == result:
        return True
    else:
        return False


# Code of the algorithm
def multiplication(int_1, int_2, solution_dict):
    if int_1 < int_2:
        mult_pair = (int_1, int_2)
    else:
        mult_pair = (int_2, int_1)

    if mult_pair not in solution_dict:
        if int_2 == 0:
            solution_dict[mult_pair] = 0
        else:
            solution_dict[mult_pair] = int_1 + multiplication(int_1, int_2 - 1, solution_dict)

    return solution_dict[mult_pair]


my_dict = {}
print(test_multiplication(0, 0, my_dict, 0))
print(test_multiplication(1, 0, my_dict, 0))
print(test_multiplication(5, 7, my_dict, 35))
print(test_multiplication(7, 7, my_dict, 49))
```",2018-12-14T10:19:20+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 2",hizclick,"```
def test_quicksort(input_list,start,end,expected):
    result = quicksort(input_list,start,end)
    if result == expected:
        return True
    else:
        return False
    
def quicksort(input_list,start,end):
    start = partition(input_list, start, end, start)
    if start != len(input_list):
        start +=1
    if(start<len(input_list)):
        partition(input_list, start, end, start)
        return input_list
    else: 
        return input_list
   ```
#partition function 
  ```
def partition(input_list, start, end, pivot_position):    
    pivot_value = input_list[pivot_position]
    for position, item in enumerate(input_list):
        if start <= position <= end:
            if item in input_list[start:pivot_position+1]:
                if item > pivot_value:
                    new_value = item
                    input_list.pop(position)
                    input_list.insert(end,new_value)
                    pivot_position = position
            elif item in input_list[pivot_position+1:end+1]:
                if item < pivot_value:
                    new_value = item
                    input_list.pop(position)
                    input_list.insert(start,new_value)
                    pivot_position = position
    
    for position, item in enumerate(input_list):
        if start <= position <= end:
            if item in input_list[start:pivot_position+1]:
                if item > pivot_value:
                    for position, item in enumerate(input_list):
                        if item == pivot_value:
                            pivot_position = position
                    partition(input_list, start, end, pivot_position)
            elif  item in input_list[pivot_position+1:end+1]:
                if item < pivot_value:
                    for position, item in enumerate(input_list):
                        if item == pivot_value:
                            pivot_position = position
                    partition(input_list, start, end, pivot_position)
    for position, item in enumerate(input_list):
        if item == pivot_value:
            return position
    
 #Since lists are mutable, we have used different names for each list while running the test.

my_list = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""])
my_list2 = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""])



my_list = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""])
my_list2 = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""])
my_list3 = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""])

print(test_quicksort(my_list, 1, 4,[""The Graveyard Book"", ""American Gods"",""Coraline"", ""Good Omens"",""Neverwhere""]))     #True
print(test_quicksort(my_list2, 2, 4,[""The Graveyard Book"", ""Coraline"", ""American Gods"",""Good Omens"",""Neverwhere"",])) #True
print(test_quicksort(my_list2, 3, 4,[""The Graveyard Book"", ""Coraline"", ""American Gods"" , ""Good Omens"",""Neverwhere""])) #True
```
",2018-12-05T09:53:10+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 2",SeverinJB,"This recursive quicksort algorithm should work with any kind of input.

_Note:_
Against what I wrote in the other thread, I have not yet optimised the partition algorithm. However, the following partition algorithm was adjusted to work with quicksort. If I have time, I would still like to eliminate the unnecessary ""excerpt_list workaround"" in the partition algorithm.

**+++ Quicksort. +++**
```
def quicksort(input_list, start, end):
    if 0 <= start <= end <= len(input_list):
        
        if len(input_list[start:end]) <= 1:
            if input_list[start] > input_list[end]:
                input_list[end], input_list[start] = input_list[start], input_list[end]
            return input_list
        else:
            pivot_position = partition(input_list, start, end, start)
            quicksort(input_list, pivot_position + 1, end)
            quicksort(input_list, start, pivot_position)
            return input_list
            
    else:
        print(""Input values without effect."")
        return input_list
```

**+++ Quicksort, Partition, and Testing Sets. +++**
```
def test_quicksort(input_list, start, end, expected):
    return expected == quicksort(input_list, start, end)


def partition(input_list, start, end, pivot_position):
    pivot_object = input_list[pivot_position]
    excerpt_list = input_list[start:end + 1]
    excerpt_list.remove(pivot_object)
    ordered_list = [pivot_object]

    def conductor(input):
        input_len = len(input)

        if input_len == 1:
            return assistant(input)
        else:
            mid = input_len // 2
            conductor(input[0:mid])
            conductor(input[mid:input_len])

    def assistant(value):
        if value[0] > pivot_object:
            ordered_list.insert(len(ordered_list), value[0])
        else:
            ordered_list.insert(0, value[0])

    conductor(excerpt_list)
    input_list[start:end + 1] = ordered_list
    print(input_list.index(pivot_object))
    return input_list.index(pivot_object)


def quicksort(input_list, start, end):
    if 0 <= start <= end <= len(input_list):
        
        if len(input_list[start:end]) <= 1:
            if input_list[start] > input_list[end]:
                input_list[end], input_list[start] = input_list[start], input_list[end]
            return input_list
        else:
            pivot_position = partition(input_list, start, end, start)
            quicksort(input_list, pivot_position + 1, end)
            quicksort(input_list, start, pivot_position)
            return input_list
            
    else:
        print(""Input values without effect."")
        return input_list


print(test_quicksort([3, 1, 6, 4, 7, 9, 2, 5, 8, 0], 0, 9, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]))
print(test_quicksort([""Rory"", ""Lorelai"", ""Luke"", ""Lane""], 1, 3, [""Rory"", ""Lane"", ""Lorelai"", ""Luke""]))
print(test_quicksort([""Tristan"", ""Logan"", ""Jess"", ""Dean""], 5, 3, [""Tristan"", ""Logan"", ""Jess"", ""Dean""]))
```",2018-12-05T16:08:41+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 2",delfimpandiani,"I haven't yet correctly separated the code between quicksort() and partition(), but this quicksort() that contains my partition() code does the job. Will continue trying to separate tomorrow.

```
def test_quicksort(input_list, s, e, pp, expected):
    result = quicksort(input_list, s, e, pp)
    if result == expected:
        return True
    else:
        return False
    
def quicksort(input_list, s, e, pp):
    len_input_list = len(input_list)
    if len_input_list <= 2: # base case: list with only 2 items
        input_list = sorted(input_list) # make sure the two items are in order
        return input_list
        
    else: # recursive step
        pv = input_list[pp] #pivot value is the item at pivot position in input lsit
        for item in input_list[s:(e +1)]:
            if item == pv:
                pass
            elif item < pv:
                input_list.remove(item)
                input_list.insert(s, item)
            elif item > pv:
                input_list.remove(item)
                input_list.insert(e, item)
        new_pp = input_list.index(pv)
        left = input_list[s:new_pp]
        right = input_list[(new_pp + 1): e + 1]
        left = quicksort(left, s, new_pp, pp)
        right = quicksort(right, new_pp, len(right), pp)
        input_list = input_list[0:s]
        input_list.extend(left)
        input_list.append(pv)
        input_list.extend(right)
        return input_list

my_list = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""])

print(test_quicksort(my_list, 1, 4, 1, [""The Graveyard Book"", ""American Gods"",""Coraline"", ""Good Omens"",""Neverwhere""]))
print(test_quicksort([""Rory"", ""Lorelai"", ""Luke"", ""Lane""], 1, 3, 1, [""Rory"", ""Lane"", ""Lorelai"", ""Luke""]))


#True
#True
```",2018-12-05T21:51:59+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 2",delfimpandiani,"Version of partition() and quicksort() separated:

```
def test_quicksort(input_list, s, e, expected):
    result = quicksort(input_list, s, e)
    if result == expected:
        return True
    else:
        return False

# partition algorithm
def partition(input_list, s, e, pp):
        pv = input_list[pp]
        for item in input_list[s:(e +1)]:
            if item == pv:
                pass
            elif item < pv:
                input_list.remove(item)
                input_list.insert(s, item)
            elif item > pv:
                input_list.remove(item)
                input_list.insert(e, item)
        new_pp = input_list.index(pv)
        return new_pp, input_list


# quicksort algorithm
def quicksort(input_list, s, e):
    left_behind = input_list[0:s]
    len_input_list = len(input_list)
    
    if len_input_list <= 2: # base case: list with only 2 items
        input_list = sorted(input_list) # make sure the two items are in order
        return input_list
        
    else: # recursive step
        pp = s
        pv = input_list[pp]
        new_pp = input_list.index(pv)
        partition_tuple = partition(input_list, s, e, pp)
        new_pp = partition_tuple[0]
        input_list = partition_tuple[1]
        left = input_list[s:new_pp]
        right = input_list[(new_pp + 1): e + 1]
        left = quicksort(left, s, new_pp)
        right = quicksort(right, new_pp, len(right))
        input_list = left_behind
        input_list.extend(left)
        input_list.append(pv)
        input_list.extend(right)
        return input_list

my_list = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""])

print(test_quicksort(my_list, 1, 4, [""The Graveyard Book"", ""American Gods"",""Coraline"", ""Good Omens"",""Neverwhere""]))
print(test_quicksort([""Rory"", ""Lorelai"", ""Luke"", ""Lane""], 1, 3, [""Rory"", ""Lane"", ""Lorelai"", ""Luke""]))

#True
#True
```",2018-12-06T10:24:05+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 2",essepuntato,"Hi guys,

(As in the [previous](#25) exercise)

That has been the most interesting discussion we had so far in the entire course. I really thank you for all you effort in solving it, providing an incredible number of different perspectives and angles to look at this problem. It has been great.

Here my solution to the problem - I hope you can find it clear but I'm happy to discuss it in the next lecture. The [source code](https://comp-think.github.io/2018-2019/python/quicksort.py) is available online as usual.

```
from partition import partition


# Test case for the algorithm
def test_quicksort(input_list, start, end, expected):
    result = quicksort(input_list, start, end)
    if expected == result:
        return True
    else:
        return False


# Code of the algorithm
def quicksort(input_list, start, end):
    if start < end:
        pivot_position = partition(input_list, start, end, start)
        quicksort(input_list, start, pivot_position - 1)
        quicksort(input_list, pivot_position + 1, end)
    return input_list


# Run tests
print(test_quicksort([1], 0, 0, [1]))
print(test_quicksort([1, 2, 3, 4, 5, 6, 7], 0, 6, [1, 2, 3, 4, 5, 6, 7]))
print(test_quicksort([3, 4, 1, 2, 9, 8, 2], 0, 6, [1, 2, 2, 3, 4, 8, 9]))
print(test_quicksort([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""], 0, 4,
                     [""American Gods"", ""Coraline"", ""Good Omens"", ""Neverwhere"", ""The Graveyard Book""]))
```",2018-12-07T21:29:56+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 1",delfimpandiani,"
This was took quite a long while. There is probably a cleaner, shorter way to solve this. Here is one that, at least, works for many different inputs:

Clean code:

```
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if result == expected:
        return True
    else:
        return False

def partition(input_list, start, end, pivot_position):
    pivot_value = input_list[pivot_position] 
    list_to_consider = input_list[start:end + 1] 

    for item in list_to_consider: 
        if input_list.index(item) < input_list.index(pivot_value) and item > pivot_value:
                input_list.insert(pivot_position, item)
                input_list.remove(item)
                pivot_position -= 1
        elif input_list.index(item) > input_list.index(pivot_value) and item < pivot_value: 
                input_list.remove(item)
                input_list.insert((pivot_position), item)
                pivot_position += 1
                
    pivot_finalpos = input_list.index(pivot_value)
    return(pivot_finalpos, input_list)


print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 1, 4, 0, (1, [""A"", ""D"", ""F"", ""R"", ""E""])))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 1, 4, 1, (3, [""D"", ""E"", ""A"", ""F"", ""R""])))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 1, 4, 2, (4, [""D"", ""F"", ""E"", ""A"", ""R""])))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 0, 4, 1, (3, [""D"", ""E"", ""A"", ""F"", ""R""])))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 0, 3, 1, (2, [""D"", ""E"", ""F"", ""R"", ""A""])))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 0, 4, 2, (4, [""D"", ""F"", ""E"", ""A"", ""R""])))


#True
#True
#True
#True
#True
#True

```

Code with comments

```
# Test of partition algorithm
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if result == expected:
        return True
    else:
        return False

# Code of partition algorithm

def partition(input_list, start, end, pivot_position):
    pivot_value = input_list[pivot_position] 
    #create a variable for the value of the item in the pivot position
    list_to_consider = input_list[start:end + 1] 
    #create a new sublist from start to end of the elements to consider

    for item in list_to_consider: 
    # for each item that has to be considered
        if input_list.index(item) < input_list.index(pivot_value) and item > pivot_value:
    # if the item to be considered is on the left of the pivot value and it is bigger than the pivot value
                input_list.insert(pivot_position, item)
                # add the item to the right of the pivot value
                input_list.remove(item)
                # remove first instance of item
                pivot_position -= 1
                # pivot position decreases by 1 since the pivot value moved left
        elif input_list.index(item) > input_list.index(pivot_value) and item < pivot_value: 
        # if the item to be considered is on the right of the pivot value and it is smaller than pivot value
                input_list.remove(item) 
                # remove the item
                input_list.insert((pivot_position), item) 
                # insert the item on the pivot position 
                pivot_position += 1
                # pivot position increases by 1 since the pivot value moved right
                
    pivot_finalpos = input_list.index(pivot_value)
    # create a new variable that hold the final position of the pivot value
    return(pivot_finalpos, input_list)
    # return the new pivot value positoin and the input list with the modifications
 
# Test runs # note that the expected value contains the tuple of expected new pivot position and the expected input list
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 1, 4, 0, (1, [""A"", ""D"", ""F"", ""R"", ""E""])))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 1, 4, 1, (3, [""D"", ""E"", ""A"", ""F"", ""R""])))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 1, 4, 2, (4, [""D"", ""F"", ""E"", ""A"", ""R""])))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 0, 4, 1, (3, [""D"", ""E"", ""A"", ""F"", ""R""])))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 0, 3, 1, (2, [""D"", ""E"", ""F"", ""R"", ""A""])))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 0, 4, 2, (4, [""D"", ""F"", ""E"", ""A"", ""R""])))

#True
#True
#True
#True
#True
#True

```",2018-12-04T14:55:52+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 1",delfimpandiani,"Here is another way..
Guys help me clean this up, I'm sure it can be cleaner

Clean code
```

def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if result == expected:
        return True
    else:
        return False


def partition(input_list, start, end, pivot_position):
    pivot_value = input_list[pivot_position]
    uncon_left = input_list[0:start]
    con_left = input_list[start:pivot_position]
    con_right = input_list[(pivot_position + 1):(end + 1)]
    uncon_right = input_list[(end + 1):len(input_list)]
    new_list = []

    for item in con_left:
        if item > pivot_value:  
            con_left.remove(item)
            con_right.append(item)

    for item in con_right[0:len(con_right)]:
        if item < pivot_value:
            con_right.remove(item)
            con_left.append(item)

    new_list.extend(uncon_left)
    new_list.extend(con_left)
    new_list.append(pivot_value)
    new_list.extend(con_right)
    new_list.extend(uncon_right)

    pivot_finalpos = new_list.index(pivot_value)
    return pivot_finalpos, new_list

print(test_partition([""D"", ""F"", ""R"", ""A"", ""E""], 0, 4, 1, (3, [""D"", ""A"", ""E"", ""F"", ""R""])))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 0, 3, 1, (2, [""D"", ""E"", ""F"", ""R"", ""A""])))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 0, 4, 2, (4, [""D"", ""F"", ""E"", ""A"", ""R""])))

```

Code with comments

```
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if result == expected:
        return True
    else:
        return False


def partition(input_list, start, end, pivot_position):
    pivot_value = input_list[pivot_position]

    # 4 lists
    uncon_left = input_list[
                 0:start]  # from first element of input list to the first element to be considered (noninclusive)
    con_left = input_list[
               start:pivot_position]  # from first element to be considered to the pivot position (noninclusive)
    con_right = input_list[(pivot_position + 1):(
                end + 1)]  # from element after pivot position to the las element to be considered (inclusive)
    uncon_right = input_list[(end + 1):len(
        input_list)]  # from element after last element to be considerd to the end of the input list
    new_list = []

    for item in con_left:  # for each item to be considered that is to the left of the pivot value
        if item > pivot_value:  # if the item is bigger than the pivot value
            con_left.remove(item)  # remove from left list
            con_right.append(item)  # add to right list

    for item in con_right[0:len(con_right)]:  # for each item to be considered that is to the right of the pivot value
        if item < pivot_value:  # if the item is smaller than the pivot value
            con_right.remove(item)  # remove from right list
            con_left.append(item)  # add to left list

    # uncon_left and uncon_right remain the same
    new_list.extend(uncon_left)
    new_list.extend(con_left)
    new_list.append(pivot_value)
    new_list.extend(con_right)
    new_list.extend(uncon_right)


    pivot_finalpos = new_list.index(pivot_value)
    return pivot_finalpos, new_list


print(test_partition([""D"", ""F"", ""R"", ""A"", ""E""], 0, 4, 1, (3, [""D"", ""A"", ""E"", ""F"", ""R""])))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 0, 3, 1, (2, [""D"", ""E"", ""F"", ""R"", ""A""])))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 0, 4, 2, (4, [""D"", ""F"", ""E"", ""A"", ""R""])))


# True
# True
# True
```",2018-12-04T16:08:41+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 1",lisasiurina,"```
def partition(input_list, start, end, pivot_position):
 l =list()
 u=0 
 for i in input_list : 
   print(l)
   if pivot_position<u<end:      
                l.append(i)
      
   else:
                
                l.insert(start,i)
   u=u+1
   print(l)
 g=input_list[pivot_position]
 v=end-start
 k=l.index(g, 0 ,v)
 print(k)
partition([""A"",""B"",""C"",""D"",""E""],1,5,2)
```
[]
['A']
['A']
['A', 'B']
['A', 'B']
['A', 'C', 'B']
['A', 'C', 'B']
['A', 'C', 'B', 'D']
['A', 'C', 'B', 'D']
['A', 'C', 'B', 'D', 'E']
1",2018-12-04T16:31:36+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 1",simayguzel,"@hizkie and I found a solution after 2 days of working. Our solution works for all probable pivot_positions.

```


def test_partition(input_list, start, end, pivot_position,expected):
    result = partition(input_list, start, end, pivot_position)
    if result == expected:
        return True
    else:
        return False
    
def partition(input_list, start, end, pivot_position):    
    pivot_value = input_list[pivot_position]
    for position, item in enumerate(input_list):
        if start <= position <= end:
            if item in input_list[start:pivot_position+1]:
                if item > pivot_value:
                    new_value = item
                    input_list.pop(position)
                    input_list.insert(end,new_value)
                    pivot_position = position
            elif item in input_list[pivot_position+1:end+1]:
                if item < pivot_value:
                    new_value = item
                    input_list.pop(position)
                    input_list.insert(start,new_value)
                    pivot_position = position
    
    for position, item in enumerate(input_list):
        if start <= position <= end:
            if item in input_list[start:pivot_position+1]:
                if item > pivot_value:
                    for position, item in enumerate(input_list):
                        if item == pivot_value:
                            pivot_position = position
                    partition(input_list, start, end, pivot_position)
            elif  item in input_list[pivot_position+1:end+1]:
                if item < pivot_value:
                    for position, item in enumerate(input_list):
                        if item == pivot_value:
                            pivot_position = position
                    partition(input_list, start, end, pivot_position)
    for position, item in enumerate(input_list):
        if item == pivot_value:
            return position
    
 #Since lists are mutable, we have used different names for each list while running the test.

my_list = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""])
my_list1 = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""])
my_list2 = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""])
my_list3 = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""])

print(test_partition(my_list, 1, 4, 1,2))     #True
print(test_partition(my_list1, 1, 4, 2,4))    #True
print(test_partition(my_list2, 1, 4, 4,1))     #True
print(test_partition(my_list3, 1, 4, 3,3))     #True


```
",2018-12-04T18:01:36+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 1",ilsamoano,"I've understood in the end how Delfina & Lisa sorted the problem.
Anyway my first approach was to create 2 new lists, saving in the first one every element of the considered range of the input list > the pivot position,  
and in the second every element of the considered range of the input list  <= the pivot position, 
and then add to the second list created the first one: I am not able to code it correctly, for the moment. 
but I'd like to understand if it is a doable approach or if the logic behind this is wrong: I've put below the correct solution my wrong attempt as a reference 

```

#correct solution

def TEST_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    
    if result == expected:
        
        return ""true""
    else:
        return ""false""
    
    
         
    
def partition(input_list, start, end, pivot_position):
  
    pivot_value = input_list[pivot_position]
    start_end_list = input_list[start: end + 1]
    
    for item in start_end_list:
         if input_list.index(item)< input_list.index(pivot_value) and item > pivot_value: 
             input_list.insert(pivot_position,item)
             input_list.remove(item)
             pivot_position -= 1
             
             
         elif input_list.index(item) > input_list.index(pivot_value) and item < pivot_value:          
             input_list.remove(item)
             input_list.insert(pivot_position, item)
             pivot_position += 1
             
    new_pivot_position= (input_list.index(pivot_value))
    return (input_list,new_pivot_position )


print(TEST_partition([""Z"", ""C"", ""N"", ""G"", ""A""], 1, 4, 1, (['Z', 'A','C','N','G'],2)))

```
True


```
#my first wrong approach

def partition(input_list, start, end, pivot_position):
  
    pivot_value = input_list[pivot_position]
    start_end_list = input_list[start: end + 1]
    leftlist= list()
    rightlist= list()
   
    
    for Item in start_end_list:
       
          if input_list.index(Item) >= input_list.index(pivot_value):
       
           rightlist.append(Item)
           input_list.remove(Item)
       
     
          elif input_list.index(Item) <= input_list.index(pivot_value):
       
           leftlist.append(Item)
           input_list.remove(Item)
                
           
           
    input_list.extend(leftlist)
    input_list.extend(rightlist)


    new_pivot_position= (input_list.index(pivot_value))
    return (input_list,new_pivot_position)
```",2018-12-04T18:42:40+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 1",delfimpandiani,"@ilsamoano 

Here is what I meant on my voice note:

```
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if result == expected:
        return ""true""
    else:
        return ""false""


def partition(input_list, start, end, pivot_position):
    pivot_value = input_list[pivot_position]
    start_end_list = input_list[start: end + 1]
    not_considered = input_list[0:start]
    leftlist = list()
    rightlist = list()

    for item in start_end_list:

        if input_list.index(item) > input_list.index(pivot_value):

            rightlist.append(item)
            input_list.remove(item)


        elif input_list.index(item) < input_list.index(pivot_value):

            leftlist.append(item)
            input_list.remove(item)

    for leftitem in leftlist:
        if leftitem > pivot_value:
            rightlist.append(leftitem)
            leftlist.remove(leftitem)

    for rightitem in rightlist:
        if rightitem < pivot_value:
            leftlist.append(rightitem)
            rightlist.remove(rightitem)

    input_list = not_considered
    input_list.extend(leftlist)
    input_list.append(pivot_value)
    input_list.extend(rightlist)

    new_pivot_position = (input_list.index(pivot_value))
    return (input_list, new_pivot_position)


print(test_partition([""Z"", ""C"", ""N"", ""G"", ""A""], 1, 4, 1, (['Z', 'A', 'C', 'N', 'G'], 2)))

# true

```


Thought about it more and shortened it just a bit:
```

def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if result == expected:
        return ""true""
    else:
        return ""false""


def partition(input_list, start, end, pivot_position):
    pivot_value = input_list[pivot_position]
    start_end_list = input_list[start: end + 1]
    leftlist = input_list[0:pivot_position]
    rightlist = input_list[(pivot_position + 1): len(input_list)]

    for leftitem in leftlist:
        if leftitem in start_end_list and leftitem > pivot_value:
            rightlist.append(leftitem)
            leftlist.remove(leftitem)

    for rightitem in rightlist[0:len(rightlist)]:
        if rightitem in start_end_list and rightitem < pivot_value:
            leftlist.append(rightitem)
            rightlist.remove(rightitem)

    input_list = leftlist
    input_list.append(pivot_value)
    input_list.extend(rightlist)

    new_pivot_position = (input_list.index(pivot_value))
    return (new_pivot_position, input_list)


print(test_partition([""D"", ""F"", ""R"", ""A"", ""E""], 0, 4, 1, (3, [""D"", ""A"", ""E"", ""F"", ""R""])))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 0, 3, 1, (2, [""D"", ""E"", ""F"", ""R"", ""A""])))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 0, 4, 2, (4, [""D"", ""F"", ""E"", ""A"", ""R""])))

# true
# true
# true

```",2018-12-04T20:45:30+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 1",SeverinJB,"The following algorithm employs the principles of ""divide and conquer algorithms"" (base case, divide, conquer, combine). In order to implement the divide and conquer approach, the algorithm uses two inner functions of which one is using itself recursively. 

When I am doing the second exercise tomorrow, I will try to improve this algorithm. If I am able to tweak the code I'll post an update. 

```
# --- Test Algorithm ---
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if result == expected:
        return True
    else:
        return False

# --- Algorithm ---
def partition(input_list, start, end, pivot_position):
    if 0 <= start <= pivot_position <= end <= len(input_list):
        pivot_object = input_list[pivot_position]
        excerpt_list = input_list[start:end + 1]
        excerpt_list.remove(pivot_object)
        ordered_list = [pivot_object]

        def conductor(input):
            input_len = len(input)

            if input_len == 1: 
                return assistant(input)
            else:  
                mid = input_len // 2 
                conductor(input[0:mid])
                conductor(input[mid:input_len]) 

        def assistant(value): 
            if value[0] > pivot_object:
                ordered_list.insert(len(ordered_list), value[0]) 
            else:
                ordered_list.insert(0, value[0]) 

        conductor(excerpt_list)
        input_list[start:end + 1] = ordered_list
        print(input_list.index(pivot_object))
        return input_list

    else:
        print(""Input values without effect."")
        return input_list

# --- Test Cases ---
print(test_partition([""Rory"", ""Lorelai"", ""Luke"", ""Lane""], 1, 3, 2, [""Rory"", ""Lane"", ""Lorelai"", ""Luke""]))
print(test_partition([""Tristan"", ""Logan"", ""Jess"", ""Dean""], 5, 3, 2, [""Tristan"", ""Logan"", ""Jess"", ""Dean""]))
```",2018-12-04T23:23:14+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 1",delfimpandiani,"Simple, clean approach based on Prof. Peroni's explanation in class today. 

```
def test_partition(input_list, s, e, pp, expected):
    result = partition(input_list, s, e, pp)
    if result == expected:
        return True
    else:
        return False

def partition(input_list, s, e, pp):
        pv = input_list[pp]
        for item in input_list[s:(e +1)]:
            if item == pv:
                pass
            elif item < pv:
                input_list.remove(item)
                input_list.insert(0, item)
            elif item > pv:
                input_list.remove(item)
                input_list.insert(e, item)
        new_pp = input_list.index(pv)
        return new_pp

print(test_partition([4, 1, 7, 3, 7, 8, 9, 2], 0, 7, 0, 3))
print(test_partition([4, 3, 5, 1, 7], 0, 4, 0, 2))

#True 
#True 

# also tried with Hizkiel's test and it works:

my_list = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""])
my_list1 = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""])
my_list2 = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""])
my_list3 = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""])

print(test_partition(my_list, 1, 4, 1,2))     #True
print(test_partition(my_list1, 1, 4, 2,4))    #True
print(test_partition(my_list2, 1, 4, 4,1))     #True
print(test_partition(my_list3, 1, 4, 3,3))    #True 
```",2018-12-05T20:46:55+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 1",tceron,"I'm extremely happy to be posting the solution of this exercise after so many hours over it, nightmares (for real) and hints from colleagues :D
```
def test_partition(input_list, start, pivot_position, end, expected):
    result = partition(input_list, start, pivot_position, end)
    if result == expected:
        return True
    else:
        return False

def partition(input_list, start, pivot_position, end):
    pivot_value = input_list[pivot_position]
    for i in input_list[start:end +1]:
        if i < pivot_value:
            curEle = i
            input_list.remove(curEle)
            input_list.insert(0, curEle)
        elif i > pivot_value:
                input_list.append(i)
                input_list.remove(i)
    new_pivot_position =  input_list[pivot_position]
    return new_pivot_position
```

test_partition(['oranges', 'banana', 'strawberry', 'pineapple', 'apple', 'pear'], 1, 1, 4, ""oranges"")       #true
test_partition([[""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""], 1, 2, 4, ""Coraline"")     #true",2018-12-06T16:22:34+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 1",EleonoraPeruch,"Here I propose two possible solutions: the first algorithm uses a sublist and it works; however, I wanted to use the range and I have been struggling for hours trying to find a solution. So the second code I propose uses the range, but it worked only with some tests so I know it is not correct, but maybe it can be a start, of course only in the case in which we can actually use range for solving this exercise. Suggestions are more than welcome! 
```
# test for the algorithm
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if expected == result:
        return True
    else:
        return False

# code of the algorithm using sublist
# it works with whatever type of value in the list
def partition(input_list, start, end, pivot_position):
    p = input_list[pivot_position]
    for item in input_list[start : end + 1]:
            if item > p :
                input_list.remove(item)
                input_list.insert(end, item)
            if item < p :
                input_list.remove(item)
                input_list.insert(start, item)
    new_pivot_position = input_list.index(p) # use index to retrieve the position of an item in a list
    return new_pivot_position

# run some tests
print(test_partition([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""], 1, 4, 1, 2))
print(test_partition([4, 3, 5, 1, 7], 0, 4, 0, 2))

# true
# true


# code of the algorithm using range
def partition(input_list, start, end, pivot_position):
    p = input_list[pivot_position]
    for i in input_list: # i is taken as an item of the list, either number or str
        if i in range(start, end + 1): # with range i is taken as integer
            if i > p :
                input_list.remove(i)
                input_list.insert(end, i)
            if i < p :
                input_list.remove(i)
                input_list.insert(start, i)
    new_pivot_position = input_list.index(p)
    return new_pivot_position

# run some tests
print(test_partition([4, 3, 5, 1, 7], 0, 4, 0, 2))

# true
```",2018-12-06T19:25:07+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 1",federicabologna,"```
def test_partition(input_list, start, end, pivot_position, expected):
    if expected == partition(input_list, start, end, pivot_position):
        return True
    else:
        return False

def partition(input_list, start, end, pivot_position):
    pivot_value = input_list[pivot_position]
    for i in input_list[start:end+1]:
        if i < pivot_value:
            input_list.remove(i)
            input_list.insert(start, i)
        elif i > pivot_value:
            input_list.remove(i)
            input_list.insert(end, i)
    new_position = input_list.index(pivot_value)
    return new_position

print(test_partition([4, 1, 7, 3, 7, 8, 9, 2], 0, 7, 0, 3))
print(test_partition([4, 3, 5, 1, 7], 0, 4, 0, 2))
my_list = [""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""]
my_list2 = [""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""]
my_list3 = [""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""]
my_list4 = [""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"",""American Gods""]
print(test_partition(my_list, 1, 4, 1, 2))
print(test_partition(my_list2, 1, 4, 2, 4))
print(test_partition(my_list3, 1, 4, 4, 1))
print(test_partition(my_list4, 1, 4, 3, 3))
print(test_partition([""D"", ""F"", ""R"", ""A"", ""E""], 0, 4, 1, 3))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 0, 3, 1, 2))
print(test_partition([""D"", ""F"", ""R"", ""E"", ""A""], 0, 4, 2, 4))

True
True
True
True
True
True
True
True
True
```

",2018-12-07T18:29:52+00:00
comp-think/2018-2019,"Lecture ""Divide and conquer algorithm"", exercise 1",essepuntato,"Hi guys,

That has been the most interesting discussion we had so far in the entire course. I really thank you for all you effort in solving it, providing an incredible number of different perspectives and angles to look at this problem. It has been great.

Here my solution to the problem - I hope you can find it clear but I'm happy to discuss it in the next lecture. The [source code](https://comp-think.github.io/2018-2019/python/partition.py) is available online as usual.

```
# Test case for the algorithm
def test_partition(input_list, start, end, pivot_position, expected):
    p_value = input_list[pivot_position]
    result = partition(input_list, start, end, pivot_position)
    if expected == result and p_value == input_list[result]:
        return True
    else:
        return False


# Code of the algorithm
def partition(input_list, start, end, pivot_position):
    pivot_value = input_list[pivot_position]

    swap_index = start - 1
    for index in range(start, end + 1):
        if input_list[index] < pivot_value:
            swap_index += 1
            if swap_index == pivot_position:
                pivot_position = index
            swap(input_list, swap_index, index)

    new_pivot_position = swap_index + 1
    swap(input_list, pivot_position, new_pivot_position)

    return new_pivot_position


def swap(input_list, old_index, new_index):
    cur_value = input_list[old_index]
    input_list[old_index] = input_list[new_index]
    input_list[new_index] = cur_value


# Run tests
print(test_partition([1, 2, 3, 4, 5], 0, 4, 0, 0))
print(test_partition([4, 5, 3, 1, 7], 0, 4, 0, 2))
print(test_partition([4, 5, 3, 1, 7], 0, 4, 2, 1))
print(test_partition([7, 5, 3, 1, 4], 0, 4, 4, 2))
print(test_partition([1, 9, 7, 5, 9, 3, 1, 4, 2, 3], 0, 9, 1, 8))
print(test_partition([1, 9, 7, 5, 9, 3, 1, 4, 2, 3], 0, 9, 0, 0))
print(test_partition([1, 9, 7, 5, 9, 3, 1, 4, 2, 3], 0, 9, 3, 6))
print(test_partition([1, 2, 2, 3, 9, 8, 4], 1, 2, 1, 1))
```",2018-12-07T21:28:52+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",hizclick,"```
def test_fab(n,expected):
    if expected == fab(n):
        return True
    else:
        return False

def fab(n):
    if(n<=0):
        result = 0
    elif(n==1):
        result = 1
    else: 
        result = fab(n-1) + fab(n-2)
    return result
print(test_fab(10,55))
print(test_fab(4,3)) 
#true 
#true
```",2018-11-30T13:40:07+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",delfimpandiani,"```
# Test case for the exponentiation algorithm

def test_fib(n, expected):
    result = fib(n)
    if expected == result:
        return True
    else:
        return False

# Code of the exponentiation algorithm

def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

# Three test runs of the algorithm

print(test_fib(7, 13))
print(test_fib(9, 34))

#true
#true```",2018-11-30T13:50:56+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",simayguzel,"```
#I wrote this algorithm for exercise #2 
def F(n):
if (n == 0) :
return 0
if (n == 1 or n== 2) :
return 1
else:
return F(n-1)+F(n-2)

#The one I did today:

def test_F(n,expected):
    
    result = F(n)
    if result == expected:
        return True
    else:
        return False

def F(n):
    if n <=0:
        return 0
    elif n == 1:
        return 1
    else:
        return F(n-1)+F(n-2)

print(test_F(14,377))     #True
print(test_F(12,144))     #True
```

",2018-11-30T15:29:51+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",federicabologna,"```
def test_fib(n, expected):
    if expected == fib(n):
        return True
    else:
        return False

def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

print(test_fib(7,13))
print(test_fib(0,0))
print(test_fib(4,3))
```

True
True
True",2018-11-30T17:07:30+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",EleonoraPeruch,"```
# Test case for the algorithm
def test_fib(n, expected):
    result = fib(n)
    if result == expected:
        return True
    else:
        return False
        
# Code of the algorithm
def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1)+fib(n-2)
        
# Test some cases
print(test_fib(7, 13))
print(test_fib(12, 144))
print(test_fib(1, 1))

True
True
True
```",2018-12-01T11:48:55+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",Totaro1996,"def test_fib(n, expected):
    result=fib(n)
    if result==expected:
        return True
    else:
        return False

def fib(n):
    if n==0:
        return 0
    elif n==1:
        return 1
    else:
        return fib(n-1)+fib(n-2)

print(test_fib(0,0))
print(test_fib(7,13))
print(test_fib(6,8)

True
True
True",2018-12-01T16:01:07+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",bluebell94,"def fib_check(n,expected):
 if fib (n) == expected:
    return True
 else:
     return False

def fib(n):
 if (n<=0):
    return 0
 else:
     if (n==1):
         return 1
     else:
         return fib(n-1) + fib(n-2)
 
print fib(5)   {5}
 
print fib_check(11,89)     {True}
print fib_check(7,13)       {True}",2018-12-01T17:20:47+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",MattiaSpadoni,"I have to check it on Pycharm, increasing n is a quite problematic about the computational work. I've written 44 as input of ""cosalunga"" on pycharm and I'm still waiting the result.

![image](https://user-images.githubusercontent.com/44199892/49330909-add2b680-f595-11e8-8e07-3c525f52c6a1.png)
",2018-12-01T17:22:58+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",beccadelbens,"```
#Test case for the algorithm
def test_fib(n, expected):
    result = fib(n)
    if expected == result:
        return True
    else:
        return False

#Code of the algorithm
def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1)+fib(n-2)

print (test_fib(-1, 0)) #True
print (test_fib(1, 1)) #True
```",2018-12-01T17:27:31+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",friendlynihilist,"I've found this recursive algorithm very resource-consuming because it has to calculate each previous number for every number, so I've used low inputs to mitigate the effect. I guess there's a faster way to do that...maybe creating a list to store numbers and reduce the counting?
```
def test_fib(n, expected): #my test case
    result = fib(n)
    if expected == result:
        return True
    else:
        return False

def fib(n): #fib alg

    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

print(test_fib(3, 2)) #true
print(test_fib(5, 5)) #true
```",2018-12-02T15:01:38+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",saraarmaroli,"```
def test_fib(n,expected):
   result=fib(n)
    if expected==result:
  return True
    else:
     return False


def fib(n):
    if n<=0:
        return 0
    if n==1:
        return 1
    return fib(n-1)+ fib(n-2)

print(test_fib(8,21)) #true 
print(test_fib(5,5)) #true 
print(fib(8))
```",2018-12-02T17:54:26+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",mangiafrangette,"```
def test_fib(n, expected):
    return fib(n) == expected


def fib(n):

    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)


n1 = 1
expected1 = 1
print(test_fib(n1, expected1))
n2 = 4
expected2 = 3
print(test_fib(n2, expected2))
n3 = 16
expected3 = 987
print(test_fib(n3, expected3))
```",2018-12-02T21:09:44+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",lisasiurina,"def test_fab(n,expected):
    if expected == fab(n):
        return True
    else:
        return False

def fab(n):
    if(n<=0):
        result = 0
    elif(n==1):
        result = 1
    else: 
        result = fab(n-1) + fab(n-2)
    return result
print(test_fab(8,21))
print(test_fab(2,1))",2018-12-02T21:44:11+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",tceron,"```
def test_fib(n, expected):
    result = fib(n)
    if expected == result:
        return True
    else:
        return False

def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)
```        
print(test_fib(1,1))   #true
print(test_fib(0,0))     #true
print(test_fib(9,34))      #true",2018-12-03T07:05:24+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",SeverinJB,"```
# Test case for the algorithm 
def test_fib(n, expected): 
    result = fib(n) 
    if expected == result: 
        return True 
    else: 
        return False 

# Code of the algorithm
def fib(n):
    if n == 0: 
        return 0
    elif n == 1: 
        return 1
    else:        
        return fib(n-1) + fib(n-2)

# Test Cases 
print(test_fib(3, 2)) 
print(test_fib(5, 5)) 
print(test_fib(4, 3))
```",2018-12-03T09:13:42+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",ilsamoano,"```

#test
def test_fib(n, expected):
    if fib(n) == expected:
        return True
    else:
        return False
    
#code    
def fib(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    else:
        return fib(n - 1) + fib (n - 2)
    
#test cases    
print(test_fib(5,5)) #true
print(test_fib(8,21)) #true
print(test_fib(9,34)) #true
        
        
```",2018-12-03T18:13:32+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",MilenaCorbellini,"```
def test_fib(n, expected):
    if fib(n) == expected:
        return True
    else:
        return False
def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n -1) + fib(n - 2)
print(test_fib(7, 13))
print(test_fib(5, 5))
print(test_fib(1, 1))
```

",2018-12-04T15:50:48+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",DavideApolloni,"#Test case for the algorithm
def test_fib(n, expected):
    result = fib(n)
    if expected == result:
        return True
    else:
        return False

#Code of the algorithm
def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

print(test_fib(7, 13))
print(test_fib(1,1))",2018-12-05T15:47:09+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",andreamust,"
```
def test_fib(n, expected):
    result = fib(n)
    if result == expected:
        return True
    else:
        return False

def fib(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    else:
        return fib(n-1)+fib(n-2)


print(test_fib(-4, 0))    #True
print(test_fib(1, 1))     #True
print(test_fib(4, 3))     #True
```
",2018-12-05T17:43:56+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 2",essepuntato,"Hi guys,

here my take on the exercise (source code available [online](https://comp-think.github.io/2018-2019/python/fib.py)):

```
# Test case for the algorithm
def test_fib(n, expected):
    result = fib(n)
    if expected == result:
        return True
    else:
        return False


# Code of the algorithm
def fib(n):
    if n <= 1:
        return n
    else:
        return fib(n-1) + fib(n-2)


print(test_fib(0, 0))
print(test_fib(1, 1))
print(test_fib(2, 1))
print(test_fib(7, 13))
```

Some comments:

1. **Python code and indentation**: please, in your answers to the various questions, if you have to write down a Python code, **be sure** that the correct indent is preserved by previewing your post before to publish it. You can use the <code>```</code> environment for defining your Python code, e.g.:

<pre><code>
```
write your Python code here
```
</code></pre>",2018-12-06T14:51:26+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",hizclick,"```
def test_pwr(n, expo, expected):
    if pwr(n, expo) == expected:
        return True
    else:
        return False
     
def pwr(n, expo):
    if(expo==0):
        result = 1
    elif(expo==1):
        result = n
    else: 
        result = n * pwr(n,expo-1)
    return result
print(test_pwr(3,4,81))
print(test_pwr(17,1,17))
print(test_pwr(2,0,1))
#true 
#true 
#true 
```",2018-11-30T13:37:08+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",delfimpandiani,"First I approached the problem similarly to the multiplication recursion. That is, I wrote with pencil & paper a way to conceive of exponentiation in a recursive way. For example for 3^4:

3^4 = 3 x 3 x 3 x 3
3^4 = 3 x (3^3)
3^4 = 3 x (3 x (3^2))
3^4 = 3 x (3 x (3 x (3^1)))
3^4 = 3 x (3 x (3 x (3 x (3^0))))

Since we know that any number raised to the power of 0 will give 1 (such as, 2^0=1, just like 64235626^0=1), we can use this as the base case.


 

```
# Test case for the exponentiation algorithm

def test_exponentiation(base_number, exponent, expected):
    result = exponentiation(base_number, exponent)
    if expected == result:
        return True
    else:
        return False

# Code of the exponentiation algorithm

def exponentiation(base_number, exponent):
    if exponent == 0: #this is the application of the base case as I mentioned above
        return 1 # any number to the power of 0 equals 1
    else:
        return base_number * exponentiation(base_number, exponent - 1) # reduce the exponent by one and multiply this whole thing by the base_number

# Three test runs of the algorithm

print(test_exponentiation(3, 4, 81))
print(test_exponentiation(17, 1, 17))
print(test_exponentiation(2, 0, 1))
```",2018-11-30T13:38:24+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",simayguzel,"```
def test_exponentiation(n,e, expected):
    result = exponentiation(n,e)
    if expected == result:
        return True
    else:
        return False

def exponentiation(n, e):
    if e==0:
        return 1
    elif e==1:
        return n
    else:
        return n * exponentiation(n,e-1)
        
print(test_exponentiation(3,4,81))      #True
print(test_exponentiation(17,1,17))     #True
print(test_exponentiation(2,0,1))         #True

```
",2018-11-30T15:19:43+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",federicabologna,"def test_exp(n, e, expected):
    if expected == exp(n, e):
        return True
    else:
        return False

def exp(n, e):
    if e == 0:
        return 1
    else:
        return n*exp(n, e-1)

print(test_exp(3,4,81))
print(test_exp(17,1,17))
print(test_exp(2,0,1))

True
True
True",2018-11-30T17:47:45+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",MattiaSpadoni,"All true, I was stack in the temptative of doing this thing with another way, but I'm not able to solve a problems with variables.

![image](https://user-images.githubusercontent.com/44199892/49306879-c8445b80-f4d3-11e8-95b7-2227a9942a93.png)
",2018-11-30T18:12:34+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",EleonoraPeruch,"```
# Test case for the algorithm
def test_exponentiation(base_number, exponent, expected):
    result = base_number ** exponent
    if expected == result:
        return True
    else:
        return False

# Code of the algorithm
def exponentiation(base_number, exponent):
    x = base_number
    n = exponent
    if n == 0:
        return 1 # any integer raised to 0 return 1
    else:
        return x * exponentiation(x, n-1) # reduce the exponent of 1
                                          # multiply the exponentiation of the base_number
                                          # raised to the reduced exponent and the base_number
# run some tests
print(test_exponentiation(3, 4, 81))
print(test_exponentiation(17, 1, 17))
print(test_exponentiation(2, 0, 1))
```",2018-11-30T18:41:22+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",beccadelbens,"```
#Test case for the algorithm
def test_exponentiation(base_number, exponent, expected):
    result = exponentiation(base_number, exponent)
    if expected == result:
        return True
    else:
        return False

#Code of the algorithm
def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1
    else:
        return base_number * exponentiation(base_number, exponent - 1)

print(exponentiation(5, 3)) #return 125

print(test_exponentiation(3, 4, 81)) #return True
print(test_exponentiation(17, 1, 17)) #return True
print(test_exponentiation(2, 0, 1)) #return True
```",2018-12-01T10:12:25+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",bluebell94,"def exp_check(n,e,expected):
 if exp(n,e) == expected:
  return True
 else:
  return False

def exp(n,e):
  if (e==0):
      result=1
  else:
      result=n*exp(n,e-1)
  return result
  
print (exp(2,3))         {8)
print(exp(93,0))        {1)
  
print(exp_check(3,4,81))        {True)
print(exp_check(17,1,17))      {True)
print(exp_check(2,0,1))          {True)",2018-12-01T16:23:14+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",friendlynihilist,"Provided that in recursion x <sup>y</sup> = x * x <sup>y-1</sup>, that's my idea:
```
def test_exponentiation(base_number, exponent, expected):
    result = exponentiation(base_number, exponent)
    if expected == result:
        return True
    else:
        return False


def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1
    else:
        return base_number * exponentiation(base_number, exponent - 1)


print(test_exponentiation(3, 4, 81))
print(test_exponentiation(17, 1, 17))
print(test_exponentiation(2, 0, 1))
```",2018-12-02T14:07:04+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",tceron,"```
def test_exponentiation(num, exponent, expected):
    if  exponentiation(num, exponent) == expected:
        return True
    else: 
        return False

def exponentiation(num, exponent):
    if exponent == 0:
        return 1
    elif exponent == 1:
        return num
    else: 
        result = num * exponentiation(num,exponent - 1)
    return result
```
print(test_exponentiation(3, 4, 81))
print(test_exponentiation(17, 1, 17))
print(test_exponentiation(2, 0, 1))",2018-12-02T18:20:46+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",mangiafrangette,"```
def test_my_alg(n, e, expected):
    return my_alg(n, e) == expected


def my_alg(n, e):

   if e == 0:
       output = 1
   else:
       output = n * my_alg(n, e - 1)

   return output


n1 = 3
e1 = 4
expected1 = 81
print(test_my_alg(n1, e1, expected1))
n2 = 17
e2 = 1
expected2 = 17
print(test_my_alg(n2, e2, expected2))
n3 = 2
e3 = 0
expected3 = 1
print(test_my_alg(n3, e3, expected3))
```",2018-12-02T20:57:57+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",lisasiurina,"def test_exponentiation(n,e, expected):
    result = exponentiation(n,e)
    if expected == result:
        return True
    else:
        return False

def exponentiation(n, e):
    if e==0:
        return 1
    elif e==1:
        return n
    else:
        return n * exponentiation(n,e-1)
        
print(test_exponentiation(3,4,81))     Output:True
print(test_exponentiation(17,1,17))     Output:True
print(test_exponentiation(2,0,1))        Output:True",2018-12-02T21:26:24+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",SeverinJB,"```
# Test case for the algorithm 
def test_exponentiation(base_number, exponent, expected): 
    result = exponentiation(base_number, exponent) 
    if expected == result: 
        return True 
    else: 
        return False 

# Code of the algorithm
def exponentiation(base_number, exponent):
    if exponent == 0: 
        return 1
    else:        
        return base_number * exponentiation(base_number, exponent - 1) 

# Test Cases 
print(test_exponentiation(3, 4, 81)) 
print(test_exponentiation(17, 1, 17)) 
print(test_exponentiation(2, 0, 1))
```",2018-12-03T09:13:08+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",ilsamoano,"```
# Test case for the algorithm
def exponentiation_test(base_number, exponent, expected):
     if exponentiation(base_number, exponent)== expected:
         return True
     else:
         return False
     
#code         
def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1     
    else:
        return base_number * exponentiation(base_number, exponent - 1)
 
#test cases   
print(exponentiation_test(3,4,81))        
print(exponentiation_test(17,1,17))
print (exponentiation_test(2,0,1))
```",2018-12-03T18:03:45+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",MilenaCorbellini,"

![esercizio 11](https://user-images.githubusercontent.com/45001201/49452363-5a54a880-f7e1-11e8-8840-8c891c784962.PNG)
",2018-12-04T15:26:37+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",DavideApolloni,"#Test case for the algorithm

def test_expontentiation(n, exponent, expected)
	result = exponentiation(n, exponent)
	if expected == result 
		return True
	else
		return False


#Code of the algorithm

def exponentation(n, e):
	if exponent == 0:
		return 1
	elif exponent == 1:
		return n
	else
		return n ** exponentiation(n, e-1) 

print (test_exponentiation(3, 4, 81))
print(test_exponentiation(17, 1, 17))
print(test_exponentiation(2, 0, 1))",2018-12-05T15:43:59+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",andreamust,"
```
def test_exponentation(base_number, exponent, expected):
    result = exponentation(base_number, exponent)
    if expected == result:
        return True
    else:
        return False


def exponentation(base_number, exponent):
    if exponent == 0:
        return 1
    if exponent == 1:
        return base_number
    else:
        return base_number * exponentation(base_number, exponent - 1)


print(test_exponentation(3, 4, 81))
print(test_exponentation(17, 1, 17))
print(test_exponentation(2, 0, 1))

```",2018-12-05T17:24:35+00:00
comp-think/2018-2019,"Lecture ""Recursion"", exercise 1",essepuntato,"Hi guys,

here my take on the exercise (source code available [online](https://comp-think.github.io/2018-2019/python/exponentation.py)):

```
# Test case for the algorithm
def test_exponentation(int_1, int_2, expected):
    result = exponentation(int_1, int_2)
    if expected == result:
        return True
    else:
        return False


# Code of the algorithm
def exponentation(int_1, int_2):
    if int_2 == 0:
        return 1
    else:
        return int_1 * exponentation(int_1, int_2 - 1)


print(test_exponentation(3, 4, 81))
print(test_exponentation(17, 1, 17))
print(test_exponentation(2, 0, 1))
```

Some comments:

1. **Python code and indentation**: please, in your answers to the various questions, if you have to write down a Python code, **be sure** that the correct indent is preserved by previewing your post before to publish it. You can use the <code>```</code> environment for defining your Python code, e.g.:

<pre><code>
```
write your Python code here
```
</code></pre>",2018-12-06T14:45:48+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",andreamust,"```
set_hobbit = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = set({""Saruman"", ""Gandalf""})
first_dict = dict()  # this creates a new dictionary
first_dict[""hobbit""] = set_hobbit
first_dict[""magician""] = set_magician
print(first_dict)
```

#output: {'hobbit': {'Merry', 'Pippin', 'Sam', 'Frodo'}, 'magician': {'Gandalf', 'Saruman'}}",2018-11-28T13:20:45+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",bluebell94," set_hobbits=({""Frodo"",""Sam"",""Pippin"",""Merry""})
 set_magicians=({""Saruman"",""Gandalf""})
 dict_protagonists=dict()
 dict_protagonists[""hobbit""]=set_hobbits
 dict_protagonists[""magician""]=set_magicians
 print(dict_protagonists)

At the end to each of the names in the set_hobbits is assigned key ""hobbit"", correspondingly to each name in the set_magicians is asssigned - ""magician"". 
{'hobbit': {'Sam', 'Frodo', 'Merry', 'Pippin'}, 'magician': {'Saruman', 'Gandalf'}}

",2018-11-28T14:21:03+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",beccadelbens,"set_hobbit = set()
#set_hobbit({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_hobbit.add(""Frodo"")
set_hobbit.add(""Sam"")
set_hobbit.add(""Pippin"")
set_hobbit.add(""Merry"")

set_magician = set()
#set_magician({""Saruman"", ""Gandalf""})
set_magician.add(""Saruman"")
set_magician.add(""Gandalf"")

my_dict = dict()
my_dict[""hobbit""] = set_hobbit
my_dict[""magician""] = set_magician

---------------------------------------------------------

set_hobbit = set()
set_hobbit = ({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})

set_magician = set()
set_magician = ({""Saruman"", ""Gandalf""})

my_dict = dict()
my_dict[""hobbit""] = set_hobbit
my_dict[""magician""] = set_magician
",2018-11-28T15:54:56+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",EleonoraPeruch,"```
my_dict = dict() # create a new dictionary

# first pair
for i in set_hobbit:
    my_dict[""hobbit""] = i   # associate each item in set_hobbit with the key ""hobbit""

# second pair
for i in set_magician:
    my_dict[""magician""] = i # associate each item in set_magician with the key ""magician""

return dict()
```",2018-11-28T16:45:30+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",simayguzel,"```
hobbitset = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
hobbitmagician = set({""Saruman"", ""Gandalf""})
mydict = dict()
mydict['hobbits'] = hobbitset
mydict['magicians'] = hobbitmagician
for each in hobbitset:
    mydict['hobbits'].update
for each in hobbitmagician:
    mydict['magicians'].update
print(mydict)
output = {'hobbits': {'Merry', 'Sam', 'Pippin', 'Frodo'}, 'magicians': {'Gandalf', 'Saruman'}}
```",2018-11-28T18:57:48+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",leticiasandra,"set_hobbit = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = set({""Saruman"", ""Gandalf""})
my_dict = dict()
my_dict[""hobbit""] = set_hobbit
my_dict[""magician""] = set_magician
return_my_dict = dict()
print(my_dict)
output = {'hobbits': {'Merry', 'Frodo', 'Sam', 'Pippin'}, 'magician': {'Saruman', 'Gandalf'}}",2018-11-28T20:23:09+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",delfimpandiani,"```
set_hobbit = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
# my_set({""Frodo"", ""Sam"", ""Pippin"", ""Merry"", ""Galadriel"", ""Saruman"", ""Gandalf""})

set_magician = set({""Saruman"", ""Gandalf""})

fantasy_dict = dict()
fantasy_dict[""hobbit""] = set_hobbit
fantasy_dict[""magician""] = set_magician

print(fantasy_dict[""hobbit""])
# this returns {'Merry', 'Sam', 'Frodo', 'Pippin'}

print(fantasy_dict[""magician""])
# this returns {'Saruman', 'Gandalf'}
```",2018-11-28T21:33:39+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",MattiaSpadoni,"set_hobbit = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = set({""Saruman"", ""Gandalf""})
#quest Create a dictionary with 2 key: ""hobbit"" and ""magician"" that contain the proper values
lotr = dict()
lotr[""hobbits""] = set_hobbit
lotr[""magician""] = set_magician

#what are you doing here? Take you sword and you horse, time to go to Pelennor's field. 
#just an historical curiosity, something like the battle of Pelennor's field is happened in reality.
#in 955 the Holy Roman Emperor Oton I defeted a huge Hungarian horde in the Lechfeld batte with a #cavalry charge, the heavy cavarly charge should be very similar to the cavalry charge of LOTR",2018-11-29T14:49:04+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",SeverinJB,"```
my_action_figures = dict()

my_action_figures[""hobbit""] = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
my_action_figures[""magician""] = set({""Saruman"", ""Gandalf""})
```",2018-11-29T14:56:58+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",ilsamoano,"```
set_hobbit = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = set ({""Saruman"", ""Gandalf""})

LOTR = dict()
LOTR[""hobbit""] = set_hobbit
LOTR[""magician""] = set_magician

print(LOTR)

# {'hobbit': {'Sam', 'Pippin', 'Frodo', 'Merry'}, 'magician': {'Gandalf', 'Saruman'}}
```",2018-11-29T15:36:39+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",Totaro1996,"set_hobbit=set([""Frodo"",""Sam"", ""Pippin"", ""Merry""])
set_magician=set([""Saruman"",""Gandalf""])

first_dictionary=dict()
first_dictionary[""name""]=""hobbit""
first_dictionary[""set""]=set_hobbit

second_dictionary=dict()
second_dictionary[""name_two""]=""magician""
second_dictionary[""set_two""]=set_magician

first_dictionary.update(second_dictionary)
print(first_dictionary)",2018-11-29T16:18:12+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",friendlynihilist,"```
set_hobbit = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = set({""Saruman"", ""Gandalf""})

a_day_may_come_when_the_courage_of_men_fails = dict()

a_day_may_come_when_the_courage_of_men_fails [""hobbits""] = set_hobbit
a_day_may_come_when_the_courage_of_men_fails [""magicians""] = set_magician

print(a_day_may_come_when_the_courage_of_men_fails)
```

",2018-11-29T20:03:23+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",lisasiurina,"set_hobbit = set([""Frodo"", ""Sam"", ""Pippin"", ""Merry""])
set_magician=set([""Saruman"", ""Gandalf""])
my_dict = dict ()
my_dict[""hobbit""] = set_hobbit
my_dict[""magician""] = set_magician
print (my_dict)

output {'magician': set(['Gandalf', 'Saruman']), 'hobbit': set(['Frodo', 'Pippin', 'Sam', 'Merry'])}

",2018-11-29T21:15:42+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",tceron,"set_hobbit = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = set({""Saruman"", ""Gandalf""})

my_dictionary = dict()
my_dictionary [""hobbit""] = set_hobbit
my_dictionary [""magician""] = set_magician

print(my_dictionary)",2018-11-30T07:15:13+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",MilenaCorbellini,"![esercizio3](https://user-images.githubusercontent.com/45001201/49296479-b2756d00-f4b8-11e8-8c28-a977e7ec0c86.PNG)
",2018-11-30T14:58:16+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",DavideApolloni,"set_hobbits = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""}) 
set_magicians = set({""Saruman"", ""Gandalf""}) 

middle_earth = dict()
middle_earth[""hobbits""] = set_hobbits
middle_earth[""magicians""] = set_magicians

print(middle_earth)
",2018-12-01T11:29:17+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 3",Saraa04,"set_hobbit = ({""Frodo"", ""Sam"", ""Pippin"", ""Merry""}) 
set_magician = ({""Saruman"", ""Gandalf""})

my_first_dictionary = dict()
my_first_dictionary[""hobbit""] = set_hobbit
my_first_dictionary[""magician""] = set_magician

print(my_first_dictionary)

output: {'hobbit': {'Sam', 'Pippin', 'Frodo', 'Merry'}, 'magician': {'Gandalf', 'Saruman'}}",2018-12-01T17:50:47+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",hizclick,"my_set.remove(""Bilbo"") #remove bilbo from the set
my_set.add(""Galadriel"") #adds Galadriel to the set
​my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})) 
#updates my_set by adding ""Saruman"" and ""Gandalf""",2018-11-28T10:39:41+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",friendlynihilist,"Considering our starting hobbits({""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""}):
```
hobbits = set()
hobbits.add(""Bilbo"")
hobbits.add(""Frodo"")
hobbits.add(""Sam"")
hobbits.add(""Pippin"")
hobbits.add(""Merry"")
```
We execute:
```
hobbits.remove(""Bilbo"") #""Bilbo"" element is removed. our set contains now ({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
hobbits.add(""Galadriel"") #""Galadriel"" element is added to our ""hobbits"" set
hobbits.update(lotr({""Saruman"", ""Frodo"", ""Gandalf""})) #it updates the first list with the elements contained in the second set. elements in set are not repeatable, so ""Frodo"" will not be added.
```
The final set is:
`hobbits({""Frodo"", ""Sam"", ""Pippin"", ""Merry"", ""Galadriel"", ""Saruman"", ""Gandalf""})`

",2018-11-28T12:01:20+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",andreamust,"```
my_set = set() # this creates a new set
my_set.add(""Bilbo"") # these 5 lines add five names
my_set.add(""Frodo"")
my_set.add(""Sam"")


my_set.add(""Pippin"")
my_set.add(""Merry"")
print(my_set)     # the output is {'Bilbo', 'Frodo', 'Pippin', 'Merry', 'Sam'}

```
 #exercise2 starts

```
my_set.remove(""Bilbo"")   # this deletes an element
print(my_set)   # the result is {'Sam', 'Merry', 'Pippin', 'Frodo'}

my_set.add(""Galadriel"")   # this adds a new element
print(my_set)    # the result is {'Sam', 'Merry', 'Galadriel', 'Pippin', 'Frodo'}

my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))  # this adds ""Saruman"" and ""Gandalf"" but not ""Frodo"" because this element is already in the list

print(my_set)   # the result is: {'Saruman', 'Galadriel', 'Frodo', 'Gandalf', 'Pippin', 'Merry', 'Sam'}
```",2018-11-28T12:04:40+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",dersuchendee,"> Consider the set created in the first exercise, stored in the variable my_set. Describe the status of ​my_set after the execution of each of the following operations: ​my_set.remove(""Bilbo""), ​my_set.add(""Galadriel""), ​my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})).

set_tolkien= ()
set_tolkien.add(""Bilbo"")
set_tolkien.add(""Frodo"")
set_tolkien.add(""Sam"")
set_tolkien.add(""Pippin"")
set_tolkien.add(""Merry"")

Current status of set_tolkien: ({""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""})

set_tolkien.remove(""Bilbo"")

Current status of set_tolkien: ({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})

set_tolkien.add(""Galadriel"")

Current status of set_tolkien: ({""Frodo"", ""Sam"", ""Pippin"", ""Merry"", ""Galadriel""})

set_tolkien.update({""Saruman"", ""Frodo"", ""Gandalf""}))

Current status of set_tolkien: ({""Frodo"", ""Sam"", ""Pippin"", ""Merry"", ""Galadriel"", ""Saruman"", ""Gandalf""})",2018-11-28T12:06:10+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",bluebell94,"# initial stage of the set protagonists= ({""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
protagonists.remove(""Bilbo"")- will remove ""Bilbo"" 
# current status of the set - ({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
protagonists.add(""Galadriel"")- will add ""Galadriel"" 
# current status of the set -({""Frodo"", ""Sam"", ""Galadriel"", ""Pippin"", ""Merry""})
protagonists.update(set({[""Saruman"", ""Frodo"", ""Gandalf""})) -will add all except ""Frodo"", as the set doesn't accept repeatability of items
# final status of the set ({""Frodo"", ""Saruman"", ""Sam"",  ""Gandalf"", ""Galadriel"", ""Pippin"", ""Merry""})",2018-11-28T13:53:13+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",beccadelbens,"mag_set = set()
mag_set.add(""Saruman"")
mag_set.add(""Frodo"")
mag_set.add(""Gandalf"")

my_set = set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")
my_set.remove(""Bilbo"")
my_set.add(""Galadriel"")
my_set.update(mag_set)

#my_set({""Pippin"", ""Gandalf"", ""Sam"", ""Merry"", ""Frodo"", ""Saruman"", ""Galadriel""})",2018-11-28T15:45:30+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",EleonoraPeruch,"```
# this is only one possible combination
# set({""Bilbo"", ""Merry"", ""Sam"",""Frodo"",""Pippin""}) 

my_set.remove(""Bilbo"") # the element ""Bilbo"" will be removed from the set
my_set.add(""Galadriel"") # add the element ""Galadriel"" to the set
my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})) # ""Frodo"" will not be added 
                                                    # as it is already included in the set

print(my_set)

# set({""Gandalf"", ""Merry"", ""Sam"", ""Galadriel"", ""Saruman"", ""Frodo"", ""Pippin""})
# the elements can be combined in a different order
```",2018-11-28T16:29:02+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",simayguzel,"```
# I already have the set that I have done in the first exercise which is {'Sam', 'Bilbo', 'Frodo', 'Merry', 'Pippin'} 
hobbitset.remove(""Bilbo"")
hobbitset.add(""Galadriel"")
hobbitset.update(set({""Saruman"",""Frodo"",""Gandalf""})) #since there is no need to sort the list, we don't have to do an extra execution.
print(hobbitset)

outcome = {'Sam', 'Gandalf', 'Frodo', 'Merry', 'Saruman', 'Galadriel', 'Pippin'}
```",2018-11-28T18:04:23+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",leticiasandra,"my_name_set = set()
my_name_set.add(""Bilbo"")
my_name_set.add(""Frodo"")
my_name_set.add(""Sam"")
my_name_set.add(""Pippin"")
my_name_set.add(""Merry"")
my_name_set.remove(""Bilbo""),
my_name_set.add(""Galadriel""),
my_name_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))
print(my_name_set)
my_name_set = (""Frodo"", ""Pippin"", ""Gandalf"", ""Sam"", ""Merry"", ""Saruman"", ""Galadriel"")



",2018-11-28T19:57:59+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",delfimpandiani,"```
my_set = set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")
# my_set({ ""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry"" })


my_set.remove(""Bilbo"")
# my_set({ ""Frodo"", ""Sam"", ""Pippin"", ""Merry"" })

my_set.add(""Galadriel"")
# my_set({ ""Frodo"", ""Sam"", ""Pippin"", ""Merry"", ""Galadriel"" })

my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))
# my_set({""Frodo"", ""Sam"", ""Pippin"", ""Merry"", ""Galadriel"", ""Saruman"", ""Gandalf""})
```",2018-11-28T21:25:46+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",MattiaSpadoni,"#Theoden: so, it begins

sauron._set({""Bilbo"", ""Frodo"", ""Pippin"", ""Sam"", ""Merry""})

Actions:
my_set.remove(""Bilbo""), ​my_set.add(""Galadriel""), ​my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))

#first step:
sauron_set.remove(""Bilbo"")
sauron._set({""Frodo"", ""Pippin"", ""Sam"", ""Merry""})

#second step
​sauron_set.add(""Galadriel"")
sauron._set({""Frodo"", ""Pippin"", ""Sam"", ""Merry"", ""Galadriel""})

#third step
sauron_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))
sauron._set({""Frodo"", ""Pippin"", ""Sam"", ""Merry"", ""Galadriel"", ""Saruman"", ""Frodo"", ""Gandalf""})

#end, now go to defend Helm's Deep.
",2018-11-29T14:37:20+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",SeverinJB,"```
1 set_der_besten_hobbits = set([""Bilbo"",""Frodo"",""Sam"",""Pippin"",""Merry""])
2 set_der_besten_hobbits.remove(""Bilbo”)
3 set_der_besten_hobbits.add(""Galadriel"")
4 set_der_besten_hobbits.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))
```

In the second line, ""Bilbo"" dies on set. The set now persists of {'Frodo', 'Sam', ‘Merry', ‘Pippin'}.
In the third line, “Galadriel"" fills the gap which ""Bilbo"" left behind. She is now the first woman on set: {'Frodo', 'Sam', 'Merry', 'Galadriel', ‘Pippin'}.
In the fourth line, two old men and a Frodo double join the set. Seven different characters are now on set: {‘Saruman’, 'Sam', 'Frodo', 'Merry', 'Galadriel', 'Pippin', 'Gandalf'}.
",2018-11-29T14:54:52+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",ilsamoano,"mordor_set = set() #used set() to create a new set
mordor_set.add(""Bilbo"") #added new element to the set
mordor_set.add(""Frodo"") #added new element to the set
mordor_set.add(""Sam"") #added new element to the set
mordor_set.add(""Pippin"") #added new element to the set
mordor_set.add(""Merry"") #added new element to the set

print(mordor_set)


#{'Frodo', 'Pippin', 'Merry', 'Bilbo', 'Sam'}

mordor_set.remove(""Bilbo"") #method remove used to remove string ""Bilbo""
mordor_set.add(""Galadriel"") #method add used to add string ""Galadriel""
mordor_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})) #method update used to add to mordor_set new elements from a second set

print(mordor_set)

#{'Gandalf', 'Frodo', 'Pippin', 'Merry', 'Galadriel', 'Saruman', 'Sam'}",2018-11-29T15:30:10+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",Totaro1996,"hobbitset=set ([""Frodo"",""Bilbo"",""Sam"",""Pippin"",""Merry""])
hobbitset.remove(""Bilbo"") #it removes the string ""Bilbo"" 
hobbitset.add(""Galadriel"") #it adds the string ""Galadriel"" 
new_set=set([""Saruman"",""Frodo"",""Gandalf""]) #it creates another set with new elements
hobbitset.update(new_set) #it is used for adding all the elements included in new_set
print(hobbitset)
",2018-11-29T15:56:32+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",lisasiurina,"set(['Bilbo', 'Merry', 'Pippin', 'Sam', 'Frodo'])
my_set = set() 
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Pippin"")
my_set.add(""Merry"")
my_set.remove(""Bilbo"") #this removes 'Bilbo"" from the set
my_set.add(""Galadriel"") #this adds ""Galadriel"" to the set
my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})) #adds all the elements included in <set> to the my_set accept for ""Frodo"" which has been already added to the set
print (my_set)

output  set(['Pippin', 'Galadriel', 'Sam', 'Frodo', 'Merry', 'Gandalf', 'Saruman'])

",2018-11-29T20:42:49+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",tceron,"my_set.remove(""Bilbo""), ​my_set.add(""Galadriel""), ​my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))

my_set{'Bilbo', 'Merry', 'Pippin', 'Sam', 'Frodo'}
my_set.remove('Bilbo')     #removes the item 'Bilbo'
my_set.add('Galadriel')     #adds the item 'Galafriel'
my_set.update(set({'Saruman', 'Frodo', 'Gandalf'}))     #it adds them items 'Saruman, and 'Gandalf' to the list, it doesn't add 'Frodo' because it was already present in the list. 

Output: my_set{'Merry', 'Pippin', 'Sam', 'Frodo', 'Galadriel', 'Saruman', 'Gandalf'}
",2018-11-30T07:02:40+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",MilenaCorbellini,"![esercizio 2](https://user-images.githubusercontent.com/45001201/49295758-cd46e200-f4b6-11e8-97eb-648c9a6e4dcd.PNG)
Last operation doesen't add ""Frodo"" because it's already in the set.",2018-11-30T14:45:29+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",DavideApolloni,"my_set=({""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""})

my_set.remove(""Bilbo"")
_#""Bilbo"" wears the one ring and disappears from the set_
**output**: my_set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})

my_set.add(""Galadriel"")
_#""Galadriel"" joins the set while she is looking for Aragorn_
**output**: my_set({""Frodo"", ""Sam"", ""Galadriel, ""Pippin"", ""Merry""})

​my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))
_#""Saruman"" and ""Gandalf"", after having enjoyed some fireworks, join the set. ""Frodo"" is not added, as he is already present_
**output**: my_set({""Gandalf"", ""Saruman, ""Frodo"", ""Sam"", ""Galadriel, ""Pippin"", ""Merry""})",2018-12-01T11:10:33+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 2",Saraa04,"Considering the first exercise:

the_hobbits = set() 
the_hobbits.add(""Bilbo"")
the_hobbits.add(""Frodo"")
the_hobbits.add(""Sam"")
the_hobbits.add(""Pippin"")
the_hobbits.add(""Merry"")
print(the_hobbits)

_exercise 2:_ my_set.remove(""Bilbo""), ​my_set.add(""Galadriel""), ​my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})).

**the_hobbits.remove(""Bilbo"")**    # this removes ""Bilbo"" from the set
                                                 # the_hobbits set became: 
                                                 # set ({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})

**the_hobbits.add(""Galadriel"")**   # this adds ""Galadriel"" to the set
                                                # now the_hobbits set contains:
                                                # set ({""Frodo"", ""Sam"", ""Pippin"", ""Merry"", ""Galadriel""})

**the_hobbits.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))**
                                                  # it updates the_hobbits set
                                                  # it does not add the element ""Frodo"" to the set because it was already included

print(the_hobbits)

**Output**: set({'Galadriel', 'Gandalf', 'Pippin', 'Frodo', 'Sam', 'Saruman', 'Merry'})",2018-12-01T17:41:21+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",hizclick,"my_set = set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")
print(my_set)",2018-11-28T10:28:43+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",andreamust,"```

my_set = set()   # this creates a new set
my_set.add(""Bilbo"")   # these 5 lines add five names
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")
print(my_set)

```",2018-11-28T11:47:34+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",friendlynihilist,"hobbits = set() #create an empty set and associate it to ""hobbits"" variable
hobbits.add(""Bilbo"") #add a new element to the set
hobbits.add(""Frodo"") #etc.
hobbits.add(""Sam"")
hobbits.add(""Pippin"")
hobbits.add(""Merry"")",2018-11-28T11:52:18+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",dersuchendee,"> Write a pseudocode in Python so as to create a set of the following elements: ""​Bilbo""​, ""​Frodo""​, ""​Sam""​, ""​Pippin""​, ""​Merry""​.

set_tolkien= ()
set_tolkien.add(""Bilbo"")
set_tolkien.add(""Frodo"")
set_tolkien.add(""Sam"")
set_tolkien.add(""Pippin"")
set_tolkien.add(""Merry"")

Current status of set_tolkien: ({""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""})",2018-11-28T11:59:35+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",bluebell94,"
1 | protagonists=set()
2 | protagonists.add(""Bilbo"")
3 | protagonists.add(""Frodo"")
4 | protagonists.add(""Sam"")
5 | protagonists.add(""Pippin"")
6 | protagonists.add(""Merry"")
7 | print (protagonists)

Final set, containing [""Bilbo"", ""Merry"", ""Sam"", ""Pippin"",""Frodo""]

",2018-11-28T13:44:05+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",beccadelbens,"my_set = set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")

print(my_set)

#my_set = ({""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""})

",2018-11-28T15:59:56+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",EleonoraPeruch,"```
my_set = set() # create a new set

# add the elements ""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry"" 
# in a random order
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")

print(my_set)
```",2018-11-28T16:14:51+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",simayguzel,"```
hobbitset = set()
hobbitset.add(""Bilbo"")
hobbitset.add(""Frodo"")
hobbitset.add(""Sam"")
hobbitset.add(""Pippin"")
hobbitset.add(""Merry"")
print(hobbitset)

output = {'Sam', 'Bilbo', 'Frodo', 'Merry', 'Pippin'}
```",2018-11-28T17:57:47+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",leticiasandra,"my_name_set = set()
my_name_set.add(""Bilbo"")
my_name_set.add(""Frodo"")
my_name_set.add(""Sam"")
my_name_set.add(""Pippin"")
my_name_set.add(""Merry"")
my_name_set = (""Bilbo"" , ""Frodo"" , ""Sam"" , "" Pippin"" , ""Merry"")
print(my_name_set)",2018-11-28T18:54:07+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",delfimpandiani,"my_set = set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")
",2018-11-28T21:14:00+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",MattiaSpadoni,"sauron_set = set()
sauron_set.add(""Bilbo"")
sauron_set.add(""Frodo"")
sauron_set.add(""Sam"")
sauron_set.add(""Pippin"")
sauron_set.add(""Merry"")",2018-11-29T14:30:43+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",SeverinJB,"```
set_der_besten_hobbits = set([""Bilbo"",""Frodo"",""Sam"",""Pippin"",""Merry""])

OR

set_der_besten_hobbits = set() 
set_der_besten_hobbits.add(""Bilbo"")
set_der_besten_hobbits.add(""Frodo"")
set_der_besten_hobbits.add(""Sam"",)
set_der_besten_hobbits.add(""Pippin"")
set_der_besten_hobbits.add(""Merry"")
```",2018-11-29T14:52:37+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",Totaro1996,"hobbitset=set()
hobbitset.add(""Frodo"")
hobbitset.add(""Bilbo"")
hobbitset.add(""Sam"")
hobbitset.add(""Pippin"")
hobbitset.add(""Merry"")

print(hobbitset)",2018-11-29T14:58:11+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",ilsamoano,"```
mordor_set = set() #used set() to create a new set
mordor_set.add(""Bilbo"") #added new element to the set
mordor_set.add(""Frodo"") #added new element to the set
mordor_set.add(""Sam"") #added new element to the set
mordor_set.add(""Pippin"") #added new element to the set
mordor_set.add(""Merry"") #added new element to the set

print(mordor_set)


#{'Frodo', 'Pippin', 'Merry', 'Bilbo', 'Sam'}
```",2018-11-29T15:16:45+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",saraarmaroli,"my_set = set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")

print(my_set)

#my_set: {'Pippin', 'Sam', 'Frodo', 'Bilbo', 'Merry'}
",2018-11-29T15:34:20+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",lisasiurina,"my_set = set() 
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Pippin"")
my_set.add(""Merry"")

print (my_set)",2018-11-29T20:27:31+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",tceron,"my_set = set()
my_set.add(""Bilbo)
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")

print(my_set)
Output: my_set {""Pippin"", ""Sam"", ""Frodo"", ""Bilbo"", ""Merry""}",2018-11-29T21:58:03+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",VittoriaMoccia,"my_hobbits = set()
my_hobbits.add(""Bilbo"")
my_hobbits.add(""Frodo"")
my_hobbits.add(""Sam"")
my_hobbits.add(""Pippin"")
my_hobbits.add(""Merry"")
print(my_hobbits)",2018-11-30T12:04:10+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",MilenaCorbellini,"![esercizio1](https://user-images.githubusercontent.com/45001201/49294818-5577b800-f4b4-11e8-805f-25312b3eb5c6.PNG)
",2018-11-30T14:27:12+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",DavideApolloni,"![screenshot at dic 01 18-01-19](https://user-images.githubusercontent.com/44606693/49330741-25531680-f593-11e8-93a6-0a8a1fa56b35.png)
",2018-12-01T10:48:02+00:00
comp-think/2018-2019,"Lecture ""Organising information: unordered structures"", exercise 1",Saraa04,"the_hobbits = set()       _# this creates a new set_

 _# adding elements to the set without any particular order_
the_hobbits.add(""Bilbo"")     
the_hobbits.add(""Frodo"")
the_hobbits.add(""Sam"")
the_hobbits.add(""Pippin"")
the_hobbits.add(""Merry"")

print(the_hobbits)

Output: the_hobbits{'Sam', 'Frodo', 'Bilbo', 'Merry', 'Pippin'}",2018-12-01T17:02:55+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 5",hizclick,"```
def test_reverse_item(items,expected):
	if reverse_item(items) == expected:
		return True
	else:
		return False

def reverse_item(items):
	last_position= len(items) - 1
	new_list= []
	for position, item in enumerate(items):
		new_list.append(items[last_position])
		ast_position = last_position - 1
	return new_list

print(test_reverse_item([1,2,4],[4,2,1]))
print(test_reverse_item([""a"",5,2],[2,5,""a""]))
```",2018-11-26T17:46:31+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 5",delfimpandiani,"I was a little stuck and @Hizkie's answer was very helpful. I did not see the need for enumerating the original list, and it worked with doing so. But I can definitely see how doing so is ""safer"" because it introduces the constraint that Hizkiel defined as "" if(position>=0): "". 


```

def my_reversed(input_list):
    result = list() # new empty list where to store the resulting list
    position = len(input_list) - 1 # the position of the last item in original input_list -> the item that should be first in the new result list
    for item in input_list: # for each item in the original input_list -> this means it will run the same number of times as there are items in the original list
        result.append(input_list[position]) # append the item that is in the position specified (in first iteration, in last position)
        position -= 1 # decrease the position by one
    return result


# accompany the function with the related test case

# Test case for the algorithm
def test_my_reversed(input_list, expected):
    result = my_reversed(input_list)
    if expected == result:
        return True
    else:
        return False

# Different test runs
print(test_my_reversed([15, 38, 56, 4], [4, 56, 38, 15]))
print(test_my_reversed([""A"", ""B""], [""B"", ""A""]))
print(test_my_reversed([""A"", 78, ""Hola""], [""Hola"", 78, ""A""]))
print(test_my_reversed([10, 78, ""Sol""], [""Sol"", 10, 78]))


# True
# True
# True
# False
```",2018-11-26T23:46:42+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 5",federicabologna,"Thanks to @delfimpandiani for suggesting me to use ""input_list[new_position]""!

```
def test_my_reverse(input_list, expected):
    if expected == my_reverse(input_list):
        return True
    else:
        return False

def my_reverse(input_list):
    result = []
    new_position = len(input_list) - 1
    for item in input_list:
        result.append(input_list[new_position])
        new_position -= 1
    return result

print(test_my_reverse([""a"", ""b"", ""c""], [""c"", ""b"", ""a""]))
print(test_my_reverse([""e"", ""f"", ""g""], [""f"", ""e"", ""g""]))

True
False

```",2018-11-27T16:42:22+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 5",EleonoraPeruch,"```
# Test case for the algorithm
def test_my_reversed(input_list, expected):
    result = my_reversed(input_list)
    if expected == result:
        return True
    else:
        return False

# Code of the algorithm
def my_reversed(input_list):
    # return a list with the elements of the input_list
    # sorted in the opposite order
    result = list() # the list to return
    for item in input_list:
        result.append(item)    
    result.reverse()
    return result

# Run some tests
print(test_my_reversed([0, 1, 2], [2, 1, 0]))
print(test_my_reversed([0, 1, 2], [2, 1]))

True
False
```",2018-11-27T17:43:11+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 5",SeverinJB,"```
# Testing Algorithm
def test_my_reversed(input_list, expected): 
    result = my_reversed(input_list) 
    if expected == result: 
        return True 
    else: 
        return False

# Algorithm
def my_reversed(input_list): 
    reversed_list = []
    reversed_list.extend(input_list)
    tmp_value = len(input_list) - 1
    for item in input_list: 
        position = tmp_value - input_list.index(item)
        reversed_list[position] = item
    return reversed_list

# Testing Input
print(test_my_reversed([0,1,2], [2,1,0]))
print(test_my_reversed([0,1,2,3], [3,2,1,0]))
```",2018-11-27T23:13:29+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 5",friendlynihilist,"```
def test_my_reversed(input_list, expected):
    result = my_reversed(input_list)
    if expected == result:
        return True
    else:
        return False



def my_reversed(input_list):
    reverse_list = []
    max_value = len(input_list) - 1

    for position, item in enumerate(input_list): 
        if position >= 0:
            reverse_list.append(input_list[max_value])
        max_value = max_value - 1

    return reverse_list

print(test_my_reversed([1, 2, 3, 4], [4, 3, 2, 1])) #true
print(test_my_reversed([""a"", ""b"", ""c"", ""d""], [""d"", ""c"", ""b"", ""a""])) #true
print(test_my_reversed([""a"", 2, ""c"", 4], [4, ""c"", 2, ""a""])) #true
print(test_my_reversed([""a"", 1, 2, 4], [""a"", ""b"", 3, ""a""])) #false
```",2018-11-28T00:57:33+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 5",ilsamoano,"thanks  @delfimpandiani for taking time adding code's explanation



```
#Write in Python the function def my_reversed(input_list) 
#which behave like the built-in function reversed() 
#introduced in Section ""Insertion sort"" and returns a proper list,
# and accompany the function with the related test case. 
#It is not possible to use the built-in function reversed() in the implementation.

#test
def test_myreverse(oldlist,expected):
    result= myreverse(oldlist)
    
    if result == expected:
        return True
    else:
        return False
        
#code

def myreverse(oldlist):
  newlist = []
  j = len(oldlist)-1
  
  for i in lst:
    newlist.append(oldlist[j])
    j -=1 
  return newlist

print(test_myreverse([""a"",""b"",""c"",""d""],['d', 'c', 'b', 'a']))  #true
```",2018-11-28T13:31:03+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 5",mangiafrangette,"```def test_my_reversed(input_list, expected):
    return my_reversed(input_list) == expected

def my_reversed(input_list):

    reversed_list = []
    for i in range(len(input_list)):
        pos_wanted = len(input_list) - i - 1
        item_wanted = input_list[pos_wanted]
        reversed_list.append(item_wanted)

    return reversed_list

l1 = [1,3,5,7,9]
expected = list(reversed(l1))
print(test_my_reversed(l1,expected))
```",2018-11-28T17:11:56+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 5",simayguzel,"```
def my_reversed(input_list):
    if input_list(items,expected):
        result = my_reversed(input_list)
        return True
    else:
        return False
def my_reversed(input_list) : []   
def my_reversed(input_list) :
    return input_list[::-1]

print(my_reversed([1,3,5]))
output = [5,3,1] True
```",2018-11-28T19:23:58+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 5",MattiaSpadoni,"It's quite late, I don't have the energy to put also all the test structure.

![image](https://user-images.githubusercontent.com/44199892/49190647-90260700-f373-11e8-8638-d7e578f254b7.png)
",2018-11-29T00:21:27+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 5",tceron,"![image](https://user-images.githubusercontent.com/44325359/49253833-d89efc80-f427-11e8-8bc5-5a403048c2db.png)
",2018-11-29T21:41:23+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 5",essepuntato,"Hi all,

here my take on the exercise (available also as [Python file](https://comp-think.github.io/2018-2019/python/my_reversed_ex5.py) in the GitHub repository), with some comments:

```
# Test case for the algorithm
# Test case for the algorithm
def test_my_reversed(input_list, expected):
    result = my_reversed(input_list)
    if expected == result:
        return True
    else:
        return False


# Code of the algorithm
def my_reversed(input_list):
    l = list()
    for item in input_list:
        l.insert(0, item)
    return l


print(test_my_reversed([], []))
print(test_my_reversed([1, 2, 4, 3, 4, 7, 2], [2, 7, 4, 3, 4, 2, 1]))
print(test_my_reversed([""a"", ""b"", ""c"", ""d""], [""d"", ""c"", ""b"", ""a""]))
```

Some comments:

1. Some of you have specified an `if` block within the foreach loop with an enumeration of the element of the list, e.g.:
   
   ```
   for position, item in enumerate(input_list):
      if position >= 0:
         # do something
   ```

   The point is that `position` will be always greater than or equal to 0 because `enumerate` will anumerate the various positions in the list starting from 0, which is the very first position. If the list is empty, then no iteration of the foreach loop will be executed at all.

2. **test-driven development**: all the tests must be passed in order to claim that an algorithm returns what it is expected. If a test execution return False, the test is not passed. If you need to check the non-compliancy of the execution of a function on purpose, then you have to create an additional testing function that returns True if the condition of the test is not passed. Remeber: first write the test, then develop the algorithm/function.

3. **tests on different, even unusual, situations**: writing the right tests is very important since, as you know, it would allow you to catch specific wrong behaviours of the algorithm in presence of specific input values. Just to introduce an example for this algorithm, try to test your function by using different kinds of inputs, including the unusual ones, such as the **empty list** and a list in which some **elements are repeated** (which is a typical characteristic of lists), and see if your function is still working as expected.",2018-12-01T09:46:55+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 4",delfimpandiani,"Ok, so this one I found both easier (because in terms of operations, finding the range was clearer than the enumeration) and harder than the previous exercise. 

As I understood, the instruction was to define in Python a function called my_range(input_list) which should behave like the built-in function range(). In the lecture notes Section ""Insertion sort"", it says that inputting range(4) returns the range([0, 1, 2, 3]), which is a kind of list. However, when I tried it in Python, instead of range([0, 1, 2, 3],  it returned range(0, 4) -- meaning, it did not return a ""list"" per se. 

Therefore, I decided to opt for a solution that got me closer to the ""list"" result as defined in the lecture notes, in the form of range([0, 1, 2, 3]). My solution returns the list, but it does not return it as a function with the word 'range'.

```
def my_range(input_list):
    result = (list()) # new empty list where to store the resulting list
    len_input_list = len(input_list) #the list length is the same as the range I am trying to find
    for i in range(len_input_list):  # for each number in the range (between 0 and the list length)
        new_item = i #create a new item of the result list, which will be a number
        result.append(new_item) # apend the item to the new list
    return result
    

# accompany the function with the related test case

# Test case for the algorithm
def test_my_range(input_list, expected):
    result = my_range(input_list)
    if expected == result:
        return True
    else:
        return False

# Three different test runs
print(test_my_range([15, 38, 56, 4], [0, 1, 2, 3]))
print(test_my_range([""A"", ""B""], [0, 1]))
print(test_my_range([""A"", 78, ""Hola""], [0, 1, 2]))

# True
# True
# True
```

I'll keep an eye out for you guys' answers, to see how to include range() in the result of the user-defined function. Otherwise, Prof. @essepuntato, could you please clarify if it is necessary, and if so, how to do it? Thank you 👍",2018-11-26T17:10:23+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 4",hizclick,"The range() function has two sets of parameters.
start: Starting number of the sequence.
stop: Generate numbers up to, but not including this number. For example, range(0, 4) generates integers from 0 up to, but not including, 4.

so the function my_range has 3 inputs one for starting number, the second one for ending number and the last one to accept an input list. 
range(3, 6)= 3,4,5
range(0,9) = 0,1,2,3,4,5,6,7,8
in a list=[1,2,3,4,5,6,7] range(1,5), will out put  [2,3,4,5]
for the list [""ab"",""cd"",""eg"",""hi"",""jk""] and range(1,4) the out put will be [""cd"",""eg"",""hi""]

here is my code I think it will work for all inputs
```
def get_range(end,items="""",start=0): #initializing the start position to 0
	my_list=[]
	if len(items)!= 0: #check if a list is passed to get_range() function
		for position, item in enumerate(items):
			if(start<=position<end):
				my_list.append(item)
		return my_list
	else:
		end = end -1
		while start<=end:
			my_list.append(end)
			end -=1
		my_list.reverse()
		return my_list

def test_get_range(expected,end,items="""",start=0):
	result = get_range(end,items,start)
	if result == expected:
		return True
	else:
		return False
		 
print(test_get_range([2,3],3,[1,2,3,4],1)) 
#expected result, ending number, items in the list, starting position
print(test_get_range([1,2,3],4,"""",1))
print(test_get_range([3,4,5],6,"""",3))
print(test_get_range([2,3],3,[1,2,3,4,5],1))
print(test_get_range([2,3,4,5],5,[1,2,3,4,5,6,7],1))
print(test_get_range([""cd"",""eg"",""hi""],4,[""ab"",""cd"",""eg"",""hi"",""jk""],1))
print(test_get_range([""cd"",""eg"",""hi"",""jk""],4,[""ab"",""cd"",""eg"",""hi"",""jk""],1))

#true
#true
#true
#true
#true
#true
#false





```

",2018-11-27T00:02:03+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 4",essepuntato,"Hi @delfimpandiani 

It is not possible to use the built-in function `range()` in the body of your `my_range` function. However there is a clear mistake in the definition of the exercise (my fault), since range takes in input a **number** –– apologises!",2018-11-27T06:47:58+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 4",hizclick,"```
def test_my_range(n,expected):
	if my_range(n) == expected:
		return True
	else:
		return False
def my_range(n):
	n= n- 1
	my_list=[]
	while n>=0:
		my_list.append(n)
		n -= 1
	my_list.reverse()
	return(my_list)
print(test_my_range(4,[0,1,2,3]))
print(test_my_range(3,[0,1,2]))
print(test_my_range(5,[0,1,2,3,4]))
print(test_my_range(6,[0,1,2,3]))

#True 
#True 
#True  
#False
```	
",2018-11-27T09:33:00+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 4",federicabologna,"My method is basically identical to the one implemented by @Hizkie . In fact, the only difference is that I subtract ""1"" inside the while loop, instead of before the while statement.
Still, I had problems in printing the function, since Python would return ""<list_reverseiterator object at 0x000001AAB7D662B0>"".

```
def my_range(n):
    result = []
    while n > 0:
        n -= 1
        result.append(n)
    return reversed(result)

print(my_range(4))

<list_reverseiterator object at 0x000001AAB7D662B0>
```

Then, I looked up my colleagues' answers and found that they expressed the inversion as ""result.reverse()"" and not as ""reversed(<list>) - the second option was the one presented in class. After using that expression, Python finally returned the expected results.

```
def test_my_range(n, expected):
    result = my_range(n)
    if result == expected:
        return True
    else:
        return False

def my_range(n):
    result = []
    while n > 0:
        n -= 1
        result.append(n)
    result.reverse()
    return(result)

print(test_my_range(4, [0, 1, 2, 3]))
print(test_my_range(3, [3, 2, 1]))

True
False
```

@essepuntato Professor, my questions are now:
1 - what does the code returned by Python mean?
2 - what is the difference between the two expressions?",2018-11-27T15:37:07+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 4",delfimpandiani,"Given Prof. Peroni's edit of the prompt, I looked at Hizkiel's solution and decided to find a similar solution but without having to reverse the list. I used his same test examples and it works just as well:

```
def test_my_range(n,expected):
    if my_range(n) == expected:
        return True
    else:
        return False
def my_range(stop):
    n= 0
    my_list=[]
    while n<=(stop -1):
        my_list.append(n)
        n += 1
    return(my_list)
print(test_my_range(4,[0,1,2,3]))
print(test_my_range(3,[0,1,2]))
print(test_my_range(5,[0,1,2,3,4]))
print(test_my_range(6,[0,1,2,3]))

#True 
#True 
#True  
#False
```",2018-11-27T16:44:23+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 4",delfimpandiani,"Given Prof. Peroni's edit of the prompt, I looked at Hizkiel's solution and decided to find a similar solution but without having to reverse the list. I used his same test examples and it works just as well:

```
def test_my_range(n,expected):
    if my_range(n) == expected:
        return True
    else:
        return False
def my_range(stop):
    n= 0
    my_list=[]
    while n<=(stop -1):
        my_list.append(n)
        n += 1
    return(my_list)
print(test_my_range(4,[0,1,2,3]))
print(test_my_range(3,[0,1,2]))
print(test_my_range(5,[0,1,2,3,4]))
print(test_my_range(6,[0,1,2,3]))

#True 
#True 
#True  
#False
```",2018-11-27T16:44:25+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 4",MattiaSpadoni,"I tried like this, sorry, but screenshots are the easiest way to share it (yes I have 1158 unread e-mails).

![image](https://user-images.githubusercontent.com/44199892/49097017-2c64e680-f26c-11e8-854b-5e98adca5f11.png)
",2018-11-27T16:47:23+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 4",EleonoraPeruch,"```
# Test case for the algorithm
def test_my_range(stop_number, expected):
    result = my_range(stop_number)
    if expected == result:
        return True
    else:
        return False

# Code of the algorithm
def my_range(stop_number):
    stop_number >= 0    # my_range takes a non negative number as input
    # return a list of values from 0 
    # to the one preceding stop_number
    output_my_range = list() # the list to return
    input_number = 0         # the list starts from 0 
    while input_number < stop_number: 
            output_my_range.append(input_number)
            input_number += 1
    return output_my_range

# Run some tests
print(test_my_range((4), ([0, 1, 2, 3])))
print(test_my_range((4), ([0, 1, 2, 3, 4])))
print(test_my_range((4), ([0, 1, 2])))

True
False
False
```",2018-11-27T17:22:48+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 4",SeverinJB,"```
# Testing Algorithm
def test_my_range(input_value, expected): 
    result = my_range(input_value) 
    if expected == result: 
        return True 
    else: 
        return False

# Algorithm
def my_range(input_value): 
    range_object = []
    while input_value > 0: 
        input_value = input_value - 1
        range_object.append(input_value)
    range_object.reverse()
    return range_object

# Testing Input
print(test_my_range(3, [0,1,2]))
print(test_my_range(4, [0,1,2,3]))
print(test_my_range(0, []))
```",2018-11-27T23:11:53+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 4",friendlynihilist,"@essepuntato: Professor, while reaching the same conclusions (more or less), I've also experienced the exact same problem mentioned by my colleague @federicafaithbologna. Could `reversed(<input_list>)` be used in this code instead of `result.reverse()`. Thank you!

```
def test_my_range(stop_number, expected):
    result = my_range(stop_number)
    if expected == result:
        return True
    else:
        return False

def my_range(stop_number):
    result = []

    while stop_number > 0:
            stop_number = stop_number - 1
            result.append(stop_number)
    result.reverse() #question about this
    return result


print(test_my_range(6, [0, 1, 2, 3, 4, 5])) #true
print(test_my_range(7, [0, 1, 2, 3, 4, 5, 6, 7])) #false
print(test_my_range(5, [0, 1, 2, 3])) #false
print(test_my_range(4, [0, 1, 2, 3])) #true
```",2018-11-27T23:18:21+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 4",ilsamoano,"```

#test
def test_myrange(n,expected):
    result= myrange(n)
    
    if result == expected:
        return True
    else:
        return False
        
#code
def myrange(n):
    newlist = []
   
    while n >0:
        n = n - 1
        newlist.append(n)
    newlist.reverse()
    return newlist

#test evaluation
print (test_myrange(4,[0,1,2,3,]))
```",2018-11-28T01:49:56+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 4",mangiafrangette,"```
def test_my_range(stop_number, expected):
    return my_range(stop_number) == expected

def my_range(stop_number):

    stop_number = stop_number - 1
    range_list = []
    while stop_number >= 0:
        range_list.append(stop_number)
        stop_number = stop_number -1

    return list(reversed(range_list))

stop_number = 9
expected = list(range(stop_number))
print(test_my_range(stop_number, expected))
```",2018-11-28T16:44:36+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 4",tceron,"Thanks to the help of @delfimpandiani I was finally able to run it. :D
![range](https://user-images.githubusercontent.com/44325359/49221597-e168e180-f3d9-11e8-92d5-d84083a19157.png)
",2018-11-29T12:23:30+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 4",andreamust,"
```
def test_my_range(stop_number, expected):
    result = my_range(stop_number)
    if result == expected:
        return True
    else:
        return False



def my_range(stop_number):
    result = list()
    start_number = 0
    stop_number >= 0

    while start_number < stop_number:
        result.append(start_number)
        start_number += 1

    return result


print(test_my_range((3), ([0, 1, 2])))   #True
print(test_my_range((4), ([0, 1, 2, 3, 4])))    #False
print(test_my_range((-4), ([-3, -2, -1, 0])))     #False

```",2018-11-29T20:22:44+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 4",essepuntato,"Hi all,

here my take on the exercise (available also as [Python file](https://comp-think.github.io/2018-2019/python/my_range_ex4.py) in the GitHub repository), with some comments:

```
# Test case for the algorithm
def test_my_range(stop_number, expected):
    result = my_range(stop_number)
    if expected == result:
        return True
    else:
        return False


# Code of the algorithm
def my_range(stop_number):
    l = list()
    while stop_number > 0:
        stop_number = stop_number - 1
        l.insert(0, stop_number)
    return l


print(test_my_range(0, []))
print(test_my_range(4, [0, 1, 2, 3]))
```

Some comments:

1. @federicafaithbologna about your question on the difference between `reversed(<ordered collection>)` and `<list>.reverse()`. 
   
   The first is a simple built-in function that Python has. That function returns a new object, i.e. an iterator (which is a kind of list, but it is not really alist) of a collection of ordered elements such as a list, and allows you to browse such list from the last element to the first one. Since this function is generically developed to handle any kind of ordered collection, it can be also used with tuples, for instance, and it always create a new object leaving the original one as before.
   
   The second is actually a method that can be called on any object of class list. As anticipated in one of the previous lectures, a method is a special kind of function that can be used only with objects of a specific class. In fact, you can use such `<list>.reverse()` on a list you have, but for instance it cannot be used with an object of class tuple, since the class tuple does not implement the `reverse()` method. In addition, this method does not generate a new object but actually **changes** the list itself, by positioning the items in reverse order. For instance, try to run the following code in Python Tutor to see graphically the differences:
   ```
   l = [""a"", ""b"", ""c""]  # create a new list
   it = reversed(l)  # create a new object iterator which allow on to browse the list in reverse order
   print(l)  # print the list, which contains the items in the same order as before
   print(it)  # print the object iterator, which is not the original list
   l.reverse()  # it reorders the items in the list in reverse order
   print(l)  # print the list, that changed as a consequece of the previous method
   ```
   
   I hope it is clearer now. Anyway, when you have similar doubts, I would sugget to start from the official [Python documentation](https://docs.python.org/3/) (linked in the lecture notes on Programming Languages for your convenience) to see if it clarifies your issues. For instance, see the definition provided for [`reversed`](https://docs.python.org/3/library/functions.html?highlight=reversed#reversed) and [`reverse`](https://docs.python.org/3/tutorial/datastructures.html?highlight=list#more-on-lists) there.

2. **test-driven development**: all the tests must be passed in order to claim that an algorithm returns what it is expected. If a test execution return False, the test is not passed. If you need to check the non-compliancy of the execution of a function on purpose, then you have to create an additional testing function that returns True if the condition of the test is not passed. Remeber: first write the test, then develop the algorithm/function.",2018-12-01T08:53:34+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 3",delfimpandiani,"If I understood the prompt correctly, the point of the exercise is to create a new function called my_enumerate(), which should behave just like the built-in function enumerate()
```
def my_enumerate(input_list):
    result = list() # new empty list where to store the resulting list
    position = 0 # initialize position to the first one, 0
    for item in input_list: # for each item in the original input_list
        new_item = position, item
        result.append(new_item) # apend the item and its position to the new list
        position += 1 # increase the position by one
    return result

# accompany the function with the related test case

# Test case for the algorithm
def test_my_enumerate(input_list, expected):
    result = my_enumerate(input_list)
    if expected == result:
        return True
    else:
        return False

# Three different test runs
print(test_my_enumerate([15, 38, 56, 4], [(0, 15), (1, 38), (2, 56), (3, 4)]))
print(test_my_enumerate([""A"", ""B"", ""C"", ""D""], [(0, 'A'), (1, 'B'), (2, 'C'), (3, 'D')]))
print(test_my_enumerate([""A"", 78, ""Hola"", 6], [(0, 'A'), (1, 78), (2, 'Hola'), (3, 6)]))

```",2018-11-26T14:24:25+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 3",EleonoraPeruch,"![ex 3 brute-force algorithm](https://user-images.githubusercontent.com/45010379/49050230-acdf0500-f1e2-11e8-9644-012ce694d8a3.PNG)
",2018-11-27T00:21:01+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 3",federicabologna,"I tried to use len() as in the Insertion sort algorithm, and for once it worked! YEY!

```
def test_my_enumerate(input_list, expected):
    result = my_enumerate(input_list)
    if expected == result:
        return True
    else:
        return False

def my_enumerate(input_list):
    result = list()
    for item in input_list:
        position = len(result)
        new_item = item, position
        result.append(new_item)
    return result

print(test_my_enumerate(([""a"", ""b"", ""c""]), [('a', 0), ('b', 1), ('c', 2)]))
print(test_my_enumerate(([""a"", ""b"", ""c""]), [('a', 3), ('b', 1), ('c', 2)]))
```",2018-11-27T00:36:29+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 3",MattiaSpadoni,"![image](https://user-images.githubusercontent.com/44199892/49095183-2cfb7e00-f268-11e8-877c-8ea3c9102cd5.png)
",2018-11-27T16:15:11+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 3",friendlynihilist,"Thanks to @delfimpandiani for the patience and the help (you're a very good teacher):
```
def test_my_enumerate(input_list, expected):
    result = my_enumerate(input_list)
    if expected == result:
        return True
    else:
        return False

def my_enumerate(input_list):
    res_list = list()
    n = 0

    for item in input_list:
        new_item = n, item
        res_list.append(new_item)
        n += 1
    return res_list

input_list = [""a"", ""b"", ""c"", ""d""]
print(my_enumerate(input_list))

print(test_my_enumerate([""a"", ""b"", ""c"", ""d""], [(0, ""a""), (1, ""b""), (2, ""c""), (3, ""d"")])) #true
print(test_my_enumerate([""a"", ""b"", ""c"", ""d""], [(0, ""a""), (2, ""b""), (1, ""c""), (3, ""d"")])) #false
print(test_my_enumerate([""a"", ""b"", ""c"", ""d""], [(0, ""a""), (1, ""c""), (2, ""b""), (3, ""d"")])) #false
```",2018-11-27T16:45:33+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 3",lisasiurina,"Thank you @delfimpandiani and @federicafaithbologna hugs and kisses :)

```
def test_my_enumerate(input_list, expected):
    result = my_enumerate(input_list)
    if expected == result:
        return True
    else:
        return False

def my_enumerate(input_list):
    result = list()
    for item in input_list:
        position = len(result)
        new_item = item, position
        result.append(new_item)
    return result
```

print(test_my_enumerate((['Miami', 'Heat', '23']), [('Miami', 0), ('Heat', 1), ('23', 2)]))
",2018-11-27T20:15:30+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 3",SeverinJB,"```
# Testing Algorithm
def test_my_enumerate(input_list, expected): 
    result = my_enumerate(input_list) 
    if expected == result: 
        return True 
    else: 
        return False

# Algorithm
def my_enumerate(input_list): 
    enumerate_object = []
    for item in input_list: 
        position = input_list.index(item)
        tmp_tuple = (position, item)
        enumerate_object.append(tmp_tuple)
    return enumerate_object

# Testing Input
print(test_my_enumerate([""the"",""ultimate"",""question""], [(0,""the""),(1,""ultimate""),(2,""question"")]))
```",2018-11-27T23:10:42+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 3",ilsamoano,"I had to look at my colleagues examples, but in the end I've understood the logic behind the following example

```
def test_my_enumerate(oldlist,expected):
    result = my_enumerate(oldlist)
    
    if result == expected:
        return True
    else:
        return False


def my_enumerate(oldlist):
    newlist = list()
    position = 0
    
    for item in oldlist:
       new_list_item = position, item
       newlist.append(new_list_item)
       position += 1
       
    return newlist
       
print(test_my_enumerate([""Ron"",""Hermione"",""Draco""],[(0,""Ron""),(1,""Hermione""),(2,""Draco"")]))  
```",2018-11-28T00:25:13+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 3",mangiafrangette,"```
def test_my_enumerate(input_list, expected):
    return my_enumerate(input_list) == expected

def my_enumerate(input_list):
    enumerate_list = list()

    for i in range(len(input_list)):
        enumerate_list.append(i)
        enumerate_list.append(input_list[i])

    return enumerate_list

list1 = [""Vettel"", ""Hamilton"", ""Bottas""]
list2 = [""Rossi"", ""Marquez"", ""Dovizioso""]
list3 = [""Peroni"", ""Italia"", ""Tamburini""]

expected1 = [0, ""Vettel"", 1, ""Hamilton"", 2, ""Bottas""]
expected2 = [0, ""Rossi"", 1, ""Marquez"", 2, ""Dovizioso""]
expected3 = [0, ""Peroni"", 1, ""Italia"", 2, ""Tamburini""]

print(test_my_enumerate(list1, expected1))
print(test_my_enumerate(list2, expected2))
print(test_my_enumerate(list3, expected3))
```
@essepuntato shouldn't we put the built in function enumerate() as expected result?",2018-11-28T16:28:59+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 3",tceron,"![enumerate](https://user-images.githubusercontent.com/44325359/49178554-555ea780-f350-11e8-9028-757f0c3027fe.png)
",2018-11-28T19:58:29+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 3",simayguzel,"```
def test_my_enumerate(input_list, expected):
    result = my_enumerate(input_list)
    
    if result == expected:
        return True
    else:
        return False
    
def my_enumerate(input_list):
    
    result = []
    position = 0
    
    for item in input_list:
        new_list = position, item
        result.append(new_list)
        position += 1
        
    return result

print(test_my_enumerate([""T"", ""R"", ""S"", ""U""], [(0, ""T""), (1, ""R""), (2, ""S""), (3, ""U"")])) 
print(test_my_enumerate([""Bologna"", ""Roma"", ""Napoli"", ""Sicilia""], [(0, ""Bologna""), (3, ""Roma""), (2, ""Napoli""), (1, ""Sicilia"")])) 
print(test_my_enumerate([""pizza"", ""pasta"", ""cannoli"", ""lasagna""], [(0, ""pizza""), (1, ""cannoli""), (2, ""lasagna""), (3, ""pasta"")])) 

True
False
False

```",2018-11-29T16:56:54+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 3",andreamust,"```
def test_my_enumerate(input_list: object, expected: object):
    result = my_enumerate(input_list)
    if result == expected:
        return True
    else:
        return False

def my_enumerate(input_list):
    results = list()
    position = 0
    for item in input_list:
        new_item = position, item
        results.append(new_item)
        position += 1
    return results


print(test_my_enumerate([""red"", ""blue"", ""yellow"", ""pink""], [(0, ""red""), (1, ""blue""), (2, ""yellow""), (3, ""pink"")]))   #output: True
print(test_my_enumerate([""A"", ""B"", ""C"", ""D""], [(1, 'A'), (1, 'B'), (2, 'C'), (3, 'D')]))   #output: False
```",2018-11-29T18:36:43+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 3",essepuntato,"Hi all,

here my take on the exercise (available also as [Python file](https://comp-think.github.io/2018-2019/python/my_enumerate_ex3.py) in the GitHub repository), with some comments:

```
# Test case for the algorithm
def test_my_enumerate(input_list, expected):
    result = my_enumerate(input_list)
    if expected == result:
        return True
    else:
        return False


# Code of the algorithm
def my_enumerate(input_list):
    l = list()
    for i in range(len(input_list)):
        l.append((i, input_list[i]))
    return l


print(test_my_enumerate([], []))
print(test_my_enumerate([""a"", ""b"", ""c""], [(0, ""a""), (1, ""b""), (2, ""c"")]))
```

Some comments:

1. @mangiafrangette I would suggest **not to** use `enumerate` in the test, since actually that function does not return a proper list (i.e. what I've asked you to return) but rather an enumeration – which is similar to list but it is not.

2. **test-driven development**: all the tests must be passed in order to claim that an algorithm returns what it is expected. If a test execution return False, the test is not passed. If you need to check the non-compliancy of the execution of a function on purpose, then you have to create an additional testing function that returns True if the condition of the test is not passed. Remeber: first write the test, then develop the algorithm/function.

3. **Python code and indentation**: please, in your answers to the various questions, if you have to write down a Python code, **be sure** that the correct indent is preserved by previewing your post before to publish it. You can use the <code>```</code> environment for defining your Python code, e.g.:

<pre><code>
```
write your Python code here
```
</code></pre>",2018-12-01T06:51:30+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 2",delfimpandiani,"```
# Test case for the algorithm
def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if expected == result:
        return True
    else:
        return False

# Code of the algorithm
from collections import deque
def stack_from_list(input_list):
    output_stack = deque()
    for item in input_list:
        output_stack.append(item)

    return output_stack
    
# Three different test runs
print(test_stack_from_list([15, 38, 56, 4], deque([15, 38, 56, 4])))
print(test_stack_from_list([""A"", ""B"", ""C"", ""D""], deque([""A"", ""B"", ""C"", ""D""])))
print(test_stack_from_list([""A"", 78, ""Hola"", 6], deque([""A"", 78, ""Hola"", 6])))

```",2018-11-26T12:06:25+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 2",ilsamoano,"```
def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    
    if expected == result:
          return True 
    else:
          return False



from collections import deque

def stack_from_list(input_list):
    output_stack = deque() 
            
    for item in input_list:
             output_stack.append(item) 
     
    return output_stack


print (test_stack_from_list([12,13,14], deque([12,13,14])))
print (test_stack_from_list([""A"",13,""B""], deque([""A"",13,""B""])))
print (test_stack_from_list([""A"",13,""B""], deque([""B"",13,""A""])))

True
True
False
```",2018-11-26T16:37:58+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 2",EleonoraPeruch,"![cattura2](https://user-images.githubusercontent.com/45010379/49029779-c9a91780-f1a5-11e8-9ff8-4a11f5ad12f6.PNG)
",2018-11-26T17:05:07+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 2",LuciaGiagnolini12,"```
# Test case for the algorithm
def test_stack_from_list(chapters_list, expected):
    result = stack_from_list(chapters_list)
    if expected == result:
        return True
    else:
        return False

# Code of the algorithm
from collections import deque
def stack_from_list(chapters_list):
    chapters_stack = deque()
    for item in chapters_list:
        chapters_stack.append(item)

    return chapters_stack
    
# Two different test runs
print(test_stack_from_list([""chapter 1"", ""chapter 2"", ""chapter 3"", ""chapter 4""], deque([""chapter 1"", ""chapter 2"", ""chapter 3"", ""chapter 4""]))) # true
print(test_stack_from_list([""Owl Post"", ""Aunt Marge's Big Mistake"", ""The Knight Bus"", ""The Leaky Cauldron""], deque([""The Boggart in the Wardrobe"", ""Aunt Marge's Big Mistake"", ""The Knight Bus"", ""The Leaky Cauldron""]))) # false

```",2018-11-26T17:07:41+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 2",lisasiurina,"#Test case for the algorithm

def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    
    if expected == result:
          return True 
    else:
          return False

from collections import deque

def stack_from_list(input_list):
    output_stack = deque() 
            
    for item in input_list:
             output_stack.append(item) 
     
    return output_stack

print(test_stack_from_list([“Part 1"", “Part 2"", “Part 3"", “Part 4""], deque([“Part 1"", “Part 2"", “Part 3"", “Part 4”]))) Output: True
print(test_stack_from_list([“) “Poor Folk "", “The Double“, ""The Idiot”, “A Gentle Creature“], deque([""The Double"", “Poor Folk”, “The Idiot“, “A Gentle Creature“]))) Output: False
",2018-11-26T17:59:16+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 2",dersuchendee,"# Test case for the algorithm
def stack_from_list(input_list, value_to_search, expected):
result =stack_from_list(input_list, value_to_search)
if expected == result:
return True
else:
return False",2018-11-26T21:28:27+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 2",federicabologna,"```
from collections import deque

def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if expected == result:
        return True
    else:
        return False

def stack_from_list(input_list):
    output_stack = deque()
    for item in input_list:
        output_stack.append(item)
    return output_stack

print(test_stack_from_list(list([""a"", ""b"", ""c""]), deque([""c"", ""b"", ""a""])))
print(test_stack_from_list(list([""d"", ""e"", ""f""]), deque([""d"", ""e"", ""f""])))
```",2018-11-26T23:45:05+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 2",MattiaSpadoni,"I cannot understand why Github don't write the indentation in this case.

def test(input_list, expected):
    result = createstuck(input_list)
    if expected == result:
        return True
    else:
        return False

from collections import deque
def createstack(input_list):
    stack = deque()
    for item in input_list:
        stack.append(item)

    return stack
    
# some tests
print(createstack([55, 44, 32, 27], deque([27, 32, 44, 55]))) (True)
print(createstack([""A"", ""B"", ""C"", ""D""], deque([""A"", ""B"", ""C"", ""D""]))) (false)
",2018-11-27T11:51:14+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 2",friendlynihilist,"```
def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if expected == result:
        return True
    else:
        return False


from collections import deque
def stack_from_list(input_list):
    output_stack = deque()  # the stack to create


    for item in input_list:
        output_stack.append(item)

    return output_stack

print(test_stack_from_list([""a"", ""b"", ""c""], deque([""a"", ""b"", ""c""]))) #true
print(test_stack_from_list([""A"", ""b"", ""c""], deque([""a"", ""b"", ""c""]))) #false
print(test_stack_from_list([1, 2, 3], deque([3, 2, 1]))) #false
```",2018-11-27T15:37:15+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 2",SeverinJB,"```
from collections import deque

# Testing Algorithm
def test_stack_from_list(input_list, expected): 
    result = stack_from_list(input_list) 
    if expected == result: 
        return True 
    else: 
        return False 

# Algorithm
def stack_from_list(input_list):    
    output_stack = deque() # the stack to create 
    
    # Iterate each element in the input list and add it to the stack 
    for item in input_list: 
        output_stack.append(item) 
    
    return output_stack 

# Testing Input
print(test_stack_from_list([1,2,3,4,5], deque([1,2,3,4,5]))) 
print(test_stack_from_list([""the"",""answer"",""to"",""life"",""universe"",""and"",""everything""], deque([""the"",""answer"",""to"",""life"",""universe"",""and"",""everything""]))) 
print(test_stack_from_list([""the"",""ultimate"",""question""], deque([""the"",""ultimate"",""question""])))
```",2018-11-27T23:09:09+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 2",andreamust," ```
#test stack

def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if result == expected:
        return True
    else:
        return False


from collections import deque


def stack_from_list(input_list):
    output_stack = deque()
    # Iterate each element in the input list and add it to the stack
    for item in input_list:
        output_stack.append(item)
    return output_stack


print(test_stack_from_list([62, 54, 21, 6], deque([62, 54, 21, 6]))) #True
print(test_stack_from_list([""Anna"", ""Marco"", ""Luigi"", ""Andrea""], deque([""Anna"", ""Marco"", ""Luigi"", ""Andrea""])))   #True
print(test_stack_from_list([""red"", ""blue"", ""yellow""], deque([""red"", ""pink""])))   #False


```",2018-11-28T16:48:36+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 2",tceron,"from collections import deque

#test case for the algorithm
def test_stack_from_list(input_list, expected):

    result = stack_from_list(input_list)
    if expected == result:
        return True
    else:
        return False

#code of the algorithm
def stack_from_list(input_list):
    output_stack = deque()    #stack to create

    #iterate each element in the input list and add it to the stack
    for item in input_list:
        output_stack.append(item)

    return output_stack

#tests run
print(test_stack_from_list([10, 16, 82, 5], deque([10, 16, 82, 5])))
print(test_stack_from_list([""zebra"", ""donkey"", ""hippo"", ""giraffe""], deque([""zebra"", ""donkey"", ""hippo"", ""giraffe""])))",2018-11-28T18:31:41+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 2",simayguzel,"```
def test_output_stack(input_list, expected):
    result = output_stack(input_list)
    if expected == result:
        return True
    else:
        return False
from collections import deque

def output_stack(input_list):
    output_stack = deque()
    
    for item in input_list:
        output_stack.append(item)
        
        
    return output_stack

print (test_output_stack([19,18,17], deque([19,18,17])))
print (test_output_stack([""D"",""E"",""F""], deque([""D"",""E"",""F""])))
print (test_output_stack([22,""A"",""B""], deque([22,""A"",""B""])))

True
True
True
```",2018-11-29T15:42:13+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 2",DavideApolloni,"![screenshot at nov 29 17-29-45](https://user-images.githubusercontent.com/44606693/49236446-69f87980-f3fc-11e8-8831-5caba24757af.png)
",2018-11-29T16:30:30+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 2",essepuntato,"Hi all,

First, you can find my solution as [Python file](https://comp-think.github.io/2018-2019/python/stack_from_list_ex2.py) in the GitHub repository.

a few **very important** comments for this (and future) exercise:

1. **test-driven development**: all the tests must be passed in order to claim that an algorithm returns what it is expected. If a test execution return False, the test is not passed. If you need to check the non-compliancy of the execution of a function on purpose, then you have to create an additional testing function that returns True if the condition of the test is not passed. Remeber: first write the test, then develop the algorithm/function.

2. **Python code and indentation**: please, in your answers to the various questions, if you have to write down a Python code, **be sure** that the correct indent is preserved by previewing your post before to publish it. You can use the <code>```</code> environment for defining your Python code, e.g.:

<pre><code>
```
write your Python code here
```
</code></pre>",2018-11-30T11:45:26+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 1",delfimpandiani,"```
def linear_search(input_list, value_to_search):
    # defines the function linear_search and the parameters to be used
    for position, item in enumerate(input_list):
        # the input_list is enumerated (creates a list with each item being assigned a value for its position in the list
        # iterates over each item (and its position) on the enumerated list:
        
        if item == value_to_search:
        # if the current item is equal to the value to search
            return position
            # returns the positions of the current item
            # algorithm stops
            
linear_search(list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]), ""The Sandman"")

# Iteration 1
# position = 0
# item = ""Coraline""
# item == value_to_search is False
# Continue to the next iteration

# Iteration 2
# position = 1
# item = ""American Gods""
# item == value_to_search is False
# Continue to the next iteration

# Iteration 3
# position = 2
# item = ""The Graveyard Book""
# item == value_to_search is False
# Continue to the next iteration

# Iteration 4
# position = 3
# item = ""Good Omens""
# item == value_to_search is False
# Continue to the next iteration

# Iteration 5
# position = 4
# item = ""Neverwhere""
# item == value_to_search is False
# Continue to the next iteration

# There are no more items in the input_list
# No return statement is executed, so algorithm returns ""None""
```",2018-11-26T12:08:52+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 1",dersuchendee,"> Write down the execution steps of linear_search(list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]), ""The Sandman"")

A linear search finds a value in a list and then return its position.
In this case it doesn't return anything:

```
linear_search(list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]), ""The Sandman""):

 
linear_search(list, ""The Sandman"")

Iteration 1
 position = 0
item = ""Coraline""
 item == value_to_search is False
 **Continue to the next iteration**

Iteration 2
position = 1
item = ""American Gods""
item == value_to_search is False
 **Continue to the next iteration**

 Iteration 3
 position = 2
 item = ""The Graveyard Book""
 item == value_to_search is False
  **Continue to the next iteration**

 Iteration 4
position = 3
 item = ""Neverwhere""
 item == value_to_search is False
 **Continue to the next iteration**

 Iteration 5
 position = 4
 item = ""Good Omens""
 item == value_to_search is False
 **Continue to the next iteration**

**Output: None** -> end of the execution of the algorithm
```",2018-11-26T14:09:37+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 1",ilsamoano,"```

def linear_search(input_list, value_to_search): # define function ""linear_search""
    
  for position, item in enumerate(input_list):     # iterate all the items in the input list, getting also their position on the list 
      
      if item == value_to_search:                  # check if the current item is equal to the value to search 

        return position                            # if so, the position of the current item is returned # and the algorithm stops, if not it doesn't return any position

  



linear_search(list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]), ""The Sandman"")



# Iteration 1
​# position = 0
​# item = ""Coraline""
​# item == value_to_search is False
​# Continue to the next iteration ​#

​# Iteration 2
​# position = 1
​# item = ""American Gods""
​# item == value_to_search is False
​# ​Continue to the next iteration ​#

​# Iteration 3
​# position = 2
​# item = ""The Graveyard Book""
​# item == value_to_search is False
# ​Continue to the next iteration ​#


​# Iteration 4
​# position = 3
​# item = ""Good Omens""
​# item == value_to_search is False
# ​Continue to the next iteration ​#

​# Iteration 5
​# position = 4
​# item = ""Neverwhere""
​# item == value_to_search is False
# ​Continue to the next iteration ​#

# there are no more items to check, so, as the value_to_search is not in the list, the algorithm doesn't report any position.
```",2018-11-26T16:04:54+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 1",lisasiurina,"def linear_search(input_list, value_to_search):​  
    for ​position, item in enumerate(input_list):
        if item == value_to_search:
            return position

list_of_books = list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""])
linear_search(list)[""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""])

#enumerate(list_ of_books) will result in: # enumerate ([(0, ""Coraline""), (1, ""American Gods""), # (2, ""The Graveyard Book""), (3, ""Good Omens""), # (4, ""Neverwhere"")])


#Iteration 1
#position = 0
#item = ""Coraline""
#item == value_to_search is False
#continue to the next iteration

#Iteration 2
#position = 1
#item = ""American Gods""
#item == value_to_search is False
#continue to the next iteration

#Iteration 3
#position = 2
#item = ""The Graveyard Book""
#item == value_to_search is False
#Continue to the next iteration

#Iteration 4
#position = 3
#item = ""Good Omens""
#item == value_to_search is False
#Continue to the next iteration

#Iteration 5
#position = 4
#item = ""Neverwhere""
#item == value_to_search is False
#Continue to the next iteration
#Returns NONE

Output: None",2018-11-26T16:28:17+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 1",EleonoraPeruch,"![cattura](https://user-images.githubusercontent.com/45010379/49028510-da0bc300-f1a2-11e8-84de-cf6026858aa8.PNG)
",2018-11-26T16:44:10+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 1",MattiaSpadoni,"linear_search(list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]), ""The Sandman"")
#now we define the Algorithm , we are looking for the book ""The Sandman"" in a list
    
    for position, item in enumerate(""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", 
    ""Neverwhere"") 
     #now we have to enumerate the list, so we will have a kind of list with tuples (0, ""Coraline"", ecc...
     #in this case it will be
     if item == ""The sandman""
         return position

#the algorithm will run in the following way:
#Iteration 1
#position = 0
#item = ""Coraline""
#item == value_to_search is False
#continue to the next iteration

#Iteration 2
#position = 1
#item = ""American Gods""
#item == value_to_search is False
#continue to the next iteration

#Iteration 3
#position = 2
#item = ""The Graveyard Book""
#item == value_to_search is False
#Continue to the next iteration

#Iteration 4
#position = 3
#item = ""Good Omens""
#item == value_to_search is False
#Continue to the next iteration

#Iteration 5
#position = 4
#item = ""Neverwhere""
#item == value_to_search is False
#Continue to the next iteration
#Returns NONE

Output: None

",2018-11-27T11:43:26+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 1",tceron,"#function to enumerate the list
def linear_search(input_list, value_to_search):​
for ​position, item in enumerate(input_list):
if item == value_to_search:
return position

#creating the list
list_of_books = list ([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""])

#enumerate ([0, ""Coraline"", 1 ""American Gods"", 2 ""The Graveyard Book"", 3 ""Good Omens"", 4, ""Neverwhere""]))

linear_search(list_of_books, ""The Sandman"")

#iterate 1 
#position = 0 
#item =  ""Caroline""
#item == value_to_search is False

#iterate 2
#position = 1 
#item = ""American Gods""
#item == value_to_search is False

#iterate 3
#position = 2 
#item = ""The Graveyard Book""
#item == value_to_search is False

#iterate 4
#position = 3 
#item = ""Good Omens""
#item == value_to_search is False

#iterate 5
#position = 4 
#item = ""Nowhere""
#item == value_to_search is False

Return None
End the execution of the algorithm. 

",2018-11-27T19:52:26+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 1",andreamust,"def linear_search (input_list, value_to_search):
    # iterate all the items in the input list,
    # getting also their position on the list
    for position, item in enumerate(input_list):
        # check if the current item is equal to the value to search
        if item == value_to_search:
            # if so, the position of the current item is returned
            # and the algorithm stops
            return position
linear_search([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""] , ""The Sandman"")

#Iteration 1
#position = 0
#item = ""Coraline""
#item == value_to_search is False
#continue to the next iteration

#Iteration 2
#position = 1
#item = ""American Gods""
#item == value_to_search is False
#continue to the next iteration

#Iteration 3
#position = 2
#item = ""The Graveyard Book""
#item == value_to_search is False
#Continue to the next iteration

#Iteration 4
#position = 3
#item = ""Good Omens""
#item == value_to_search is False
#Continue to the next iteration

#Iteration 5
#position = 4
#item = ""Neverwhere""
#item == value_to_search is False
#Continue to the next iteration
#Returns NONE

Output: None",2018-11-27T22:43:39+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 1",SeverinJB,"```
list_of_books = list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", 
""Neverwhere""]) 
linear_search(list_of_books, ""The Sandman"") 

# FOREACH LOOP EXECUTION 
#  enumerate(input_list) will result in: 
#  enumerate([(0, ""Coraline""), (1, ""American Gods""), 
#  (2, ""The Graveyard Book""), (3, ""Good Omens""), 
#  (4, ""Neverwhere"")]) 
# 
#  Iteration 1 
#  position = 0 
#  item = ""Coraline"" 
#  item == value_to_search is False 
#  Continue to the next iteration 
# 
#  Iteration 2 
#  position = 1 
#  item = ""American Gods"" 
#  item == value_to_search is False 
#   Continue to the next iteration 
# 
#  Iteration 3 
#  position = 2 
#  item = ""The Graveyard Book"" 
#  item == value_to_search is False
# 
#  Iteration 4 
#  position = 3 
#  item = “Good Omens"" 
#  item == value_to_search is False
# 
#  Iteration 5
#  position = 4 
#  item = “Neverwhere"" 
#  item == value_to_search is False
# 
# End the execution of the algorithm, return nothing (None)
```",2018-11-27T23:07:48+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 1",simayguzel,"```

def linear_search(input_list, value):
    
    for position, item in enumerate(input_list):
        
        if item == ""The Sandman"":
            
            return position

list_of_books = [""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]

print(linear_search(list_of_books, ""The Sandman""))
```

 Iteration 1
​# position = 0
​# item = ""Coraline""
​# item == value_to_search is False
​# Continue to the next iteration ​#

​# Iteration 2
​# position = 1
​# item = ""American Gods""
​# item == value_to_search is False
​# ​Continue to the next iteration

 Iteration 3
​# position = 2
​# item = ""The Graveyard Book""
​# item == value_to_search is False
​# Continue to the next iteration ​#


​# Iteration 4
​# position = 3
​# item = ""Good Omens""
​# item == value_to_search is False
​# ​Continue to the next iteration

 Iteration 5
​# position = 4
​# item = ""Neverwhere""
​# item == value_to_search is False
​
output is NONE",2018-11-29T15:18:21+00:00
comp-think/2018-2019,"Lecture ""Brute-force algorithms"", exercise 1",DavideApolloni,"![screenshot at nov 29 17-05-04](https://user-images.githubusercontent.com/44606693/49234773-f739cf00-f3f8-11e8-90dc-e7c908ec9ef1.png)
",2018-11-29T16:06:02+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",hizclick,"'''
my_queue.popleft(): removes ""Draco"" from the queue. 
my_queue.append(""Voldemort""): add ""Voldemort"" to the last index of the queue. 
my_queue.popleft(): removes ""Harry"" from the queue. 

finally printing my_queue will look like
 deque([""Hermione"", ""Ron"", ""Severus"",""Voldemort""])
'''
",2018-11-23T13:36:06+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",delfimpandiani,"```
my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
# currently my_queue contains five elements:
# deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

print(my_queue) # check my queue looks right

my_queue.popleft() # this removes the first element added
# currently my_queue contains four elements:
# deque([""Harry"", ""Hermione"", ""Ron"", ""Severus""])

my_queue.append(""Voldemort"") # this adds a new element to the queue
# currently my_queue contains five elements:
# deque([""Harry"", ""Hermione"", ""Ron"", ""Severus"", ""Voldemort""])

my_queue.popleft() # this removes the first element added
# currently my_queue contains four elements:
# deque([""Hermione"", ""Ron"", ""Severus"", ""Voldemort""])
```",2018-11-23T13:41:15+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",mchiaraf,"`my_queue = dueue([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])` contains five elements

1. `my_queue.popleft()` removes the first element from the left, in this case ""Draco""
at the moment my_queue is composed by: `deque([""Harry"", ""Hermione"", ""Ron"", ""Severus""])`

2. `my_queue.append(""Voldemort"")` adds the chosen element, in this case ""Voldemord"", in the queue
at the moment my_queue is composed by: `deque([""Harry"", ""Hermione"", ""Ron"", ""Severus"", ""Voldemord""])`

3. `my_queue.popleft()` removes the first element from the left, in this case ""Harry""
at the moment my_queue is composed by: `deque([""Hermione"", ""Ron"", ""Severus"", ""Voldemord""])`

Finally `my_queue` contains four elements: ""Hermione"", ""Ron"", ""Severus"", ""Voldemord"".
",2018-11-23T16:02:15+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",bluebell94,"my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])- initial state of the queue

By executing my_queue.popleft()    - we remove ""Draco"" from the queue, rule of the queue FIFO - current state of the queue [""Harry"", ""Hermione"", ""Ron"", ""Severus""])

By  my_queue.append(""Voldemort"")  - we add ""Voldemort"" at the back of the queue, and now it looks like this -current state of the queue -[""Harry"", ""Hermione"", ""Ron"", ""Severus"", Voldemort""]

Next we execute once again my_queue.popleft() - we remove the  1st element on the left side, which in this case is ""Harry""

So the final look of the queue should be [""Hermione"", ""Ron"", ""Severus"", Voldemort""]
",2018-11-23T16:25:23+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",ilsamoano,"```
#Consider to have a queue obtained by processing, one by one, 
#the elements included in the list of the first exercise,
# i.e. my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""]). 
#Describe the status of my_queue after the execution of each of the following operations: 
#my_queue.popleft(), my_queue.append(""Voldemort""), my_queue.popleft().

from collections import deque

Grinwald_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

Grinwald_queue.popleft() 
#this operation modifies the queue ""Grinwald_queue"" removing the first element ""Draco""
#currently ""Grinwald_queue"" contains four elements:
# deque([""Harry"", ""Hermione"", ""Ron"", ""Severus""])

Grinwald_queue.append(""Voldemort"") 
#this operation modifies the queue ""Grinwald_queue"" adding the new element ""Voldemort""
#currently ""Grinwald_queue"" contains five elements:
# deque([""Harry"", ""Hermione"", ""Ron"", ""Severus"",""Voldemort""])

Grinwald_queue.popleft()
#this operation modifies the queue ""Grinwald_queue"" removing the first element ""Draco""
#currently ""Grinwald_queue"" contains four elements:
# deque([""Hermione"", ""Ron"", ""Severus"",""Voldemort""])

print (Grinwald_queue)

deque(['Hermione', 'Ron', 'Severus', 'Voldemort'])
```",2018-11-23T17:28:48+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",simayguzel,"```

my_queue = deque ( [""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""] )
my_queue.popleft( )
```      #'Draco' is extracted from my_queue because the element on the left is supposed to be removed first.

print (my_queue)
deque ( ['Harry', 'Hermione', 'Ron', 'Severus'])

my_queue.append(""Voldemort"")
print (my_queue)
deque ( ['Harry', 'Hermione', 'Ron', 'Severus', 'Voldemort']) 

# 'Voldemort' is added at the end on the right.

my_queue.popleft( )
#'Harry' is extracted from my_queue because the element on the left is supposed to be removed first.

print (my_queue)
deque ( ['Hermione', 'Ron', 'Severus', 'Voldemort'] )
```
So; after the execution of each of the following operations, my_queue is ( ['Hermione', 'Ron', 'Severus', 'Voldemort'] ) .
",2018-11-23T17:55:47+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",DavideApolloni,"my_queue=deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

my_queue.popleft()
my_queue=deque([""Harry"", ""Hermione"", ""Ron"", ""Severus""])

my_queue.append(""Voldemort"")
my_queue=deque([""Harry"", ""Hermione"", ""Ron"", ""Severus"", ""Voldemort""])

my_queue.popleft()
my_queue=deque([""Hermione"", ""Ron"", ""Severus"", ""Voldemort""])",2018-11-24T10:45:23+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",SeverinJB,"**1** from collections import deque
**2** harry_potter_und_ein_stein = deque([""Draco"",""Harry"",""Hermione"",""Ron"",""Severus""])
**3** harry_potter_und_ein_stein.popleft()
**4** harry_potter_und_ein_stein.append(""Voldemort"")
**5** harry_potter_und_ein_stein.popleft()

In line 3, ""Draco"" is removed from the queue. The queue now contains ""Harry"", ""Hermione"", ""Ron"", and ""Severus"".
In line 4, ""Voldemort"" is added to the queue on the right. The queue now contains ""Harry"", ""Hermione"", ""Ron"", ""Severus"", and ""Voldemort"".
In line 5, ""Harry"" is removed from the queue. The queue now contains ""Hermione"", ""Ron"", ""Severus"", and ""Voldemort"".",2018-11-24T11:18:04+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",MattiaSpadoni,"my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

- my_queue.popleft
  my_deque(""Harry"", ""Hermione"", ""Ron"", ""Severus"") #delete the first element of the stack, in this case 
 ""Draco""
- my_queue.append(""Voldemort"")
  my_queue(""Harry"", ""Hermione"", ""Ron"", ""Severus"", ""Voldemort"") #add a new element at the end of the 
  queue
- my_queue.leftpop()
  my_queue(""Hermione"", ""Ron"", ""Severus"", ""Voldemort"") #remove the first left item, according to the 
  FIFO rule.",2018-11-24T15:19:35+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",friendlynihilist,"```
from collections import deque
#import deque from module collections as before
potter_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
#my queue has five strings, ""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""
potter_stack.popleft()
#the first element from the left (""Draco"") has been removed from the queue
potter_stack.append(""Voldemort"")
#""Voldemort"" has been added as the rightmost element (after ""Severus"")
potter_stack.popleft()
#the first element from the left (""Harry"") has been removed from the queue, leaving, in order, ""Hermione"", ""Ron"", ""Severus"" and ""Voldemort""
print(potter_stack)
```",2018-11-24T16:17:40+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",Totaro1996,"my_queue=deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

my_queue.popleft() #it removes the first inserted element 
                                #output my_queue ([""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_queue.append(""Voldemort"") #it adds one element at the end of the queue
                                                    #output my_queue 
                                                    ([""Harry"",""Hermione"",""Ron"",""Severus"",""Voldemort""])
my_queue.popleft() #it removes the left-most element of the queue
                                #my_queue became ([""Hermione"",""Ron"", ""Severus"",""Voldemort""])",2018-11-24T18:25:50+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",federicabologna,"harry_potter_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
#creates stack
harry_potter_queue.popleft()
#takes ""Draco"" out since it is the first element of the queue
harry_potter_queue.append(""Voldemort"")
#adds ""Voldemort"" to the right of the queue
harry_potter_queue.popleft()
#takes ""Harry"" out
Thus: 'Hermione', 'Ron', 'Severus', 'Voldemort'


```
from collections import deque

harry_potter_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
harry_potter_stack.popleft()
harry_potter_stack.append(""Voldemort"")
harry_potter_stack.popleft()
print(harry_potter_stack)

deque(['Hermione', 'Ron', 'Severus', 'Voldemort'])
```",2018-11-25T10:09:28+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",saraarmaroli,"my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

my_queue.popleft () # Draco is remove, because in this case the first it’s the first out 
my_queue = deque([ ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

My_queque.append (“Voldemort”) #add Voldermort at the end of the  queue
my_queue = deque([ ""Harry"", ""Hermione"", ""Ron"", ""Severus"", “Voldemort”])

my_queue.popleft () # Harry is remove, because in this case the first it’s the first out 
my_queue = deque( ""Hermione"", ""Ron"", ""Severus"", “Voldemort”])







",2018-11-25T15:28:28+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",VittoriaMoccia,"Consider to have a queue obtained by processing, one by one, the elements included in the list of the first exercise, i.e. my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""]). Describe the status of my_queue after the execution of each of the following operations: my_queue.popleft(), my_queue.append(""Voldemort""), my_queue.popleft().

Let's first create the queue:

my_queue = deque()
my_queue.append(""Draco"")
my_queue.append(""Harry"")
my_queue.append(""Hermione"")
my_queue.append(""Ron"")
my_queue.append(""Severus"")

print(my_queue)

Result: ['Draco', 'Harry', 'Hermione', 'Ron', 'Severus']

Since in a queue, the first element added is even the first that is deleted (FIFO strategy):
my_queue.popleft() --> this operation would remove ""Draco"", because it was the first element added
my_queue.append(""Voldemort"") --> this operation would add ""Voldemort"" as the last item on the right
my_queue.popleft () --> this operation would remove ""Harry"", which was the second element added after ""Draco"", so the first element still present in the queue
",2018-11-25T17:23:15+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",lisasiurina,"my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

my_queue.popleft() 
#it removes the first element added which is Draco

my_queue.append(""Voldemort"")
#it adds a name in this case Voldemort

my_queue.popleft()
#it removes the first element added which is Harry

Output would be [“Hermione"", ""Ron"", ""Severus"", Voldemort""]",2018-11-25T20:11:32+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",MilenaCorbellini,"characters_queue = deque()
characters_queue.append(""Draco"")
characters_queue.append(""Harry"")
characters_queue.append(""Hermione"")
characters_queue.append(""Ron"")
characters_queue.append(""Severus"")
characters_queue.popleft()
characters_queue.append(""Voldemort"")
characters_queue.popleft()
print(characters_queue)
The first operation (characters_queue.popleft()) cancelled the first element added in the queue (""Draco"").
The opertion characters_queue.append(""Voldemort"") added the string ""Voldemort"".
The last operation (characters_queue.popleft()) cancelled the first element in the queue (""Harry"").",2018-11-25T20:49:24+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",tceron,"my_hp_queue = deque()
my_hp_queue.append(""Draco"")
my_hp_queue.append(""Harry"")
my_hp_queue.append(""Hermione"")
my_hp_queue.append(""Ron"")
my_hp_queue.append(""Severus"")

print (my_hp_queue)

Output [""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""]

my_hp_queue.popleft()       # removes the first element added
my_hp_queue = deque (""Harry"", ""Hermione"", ""Ron"", ""Severus"")
my_hp_queue.append(Voldemort)       # adds Voldemort to the queue
my_hp_queue = deque (""Harry"", ""Hermione"", ""Ron"", ""Severus"", ""Voldemort"")
my_hp_queue.popleft()       # removes the first element added

print (my_hp_queue)

Output [ ""Hermione"", ""Ron"", ""Severus"", ""Voldemort""]",2018-11-27T07:34:26+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 3",andreamust,"from collections import deque
my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""]) 
print(my_queue) # creates a queue containing 5 elements

my_queue.popleft() 
print(my_queue) # deletes the first element of the queue ""Draco""

my_queue.append(""Voldemort"")
print(my_queue) # adds a new element ""Voldemord"" at the end of the queue

my_queue.popleft() 
print(my_queue) # deletes the first element of the queue ""Harry""

Here the results obtained after every 'print' stage:

deque(['Draco', 'Harry', 'Hermione', 'Ron', 'Severus'])
deque(['Harry', 'Hermione', 'Ron', 'Severus'])
deque(['Harry', 'Hermione', 'Ron', 'Severus', 'Voldemort'])
deque(['Hermione', 'Ron', 'Severus', 'Voldemort'])
",2018-11-27T15:41:42+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",hizclick,"excuting **my_stuck.pop**** will remove the last element of the list, in this case Serveus. 
my_stack.pop() again remove ""Ron"" from the stack. 
my_stack.append(""Voldemort"") will add ""Volemort"" to the right of the stack. 
so the final output of the stack **my_stack** will be
deque(['Draco', 'Harry', 'Hermione', 'Voldemort'])
",2018-11-23T12:06:04+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",delfimpandiani,"```
my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

# currently my_stack contains five elements:
#        ""Severus""])
#        ""Ron"",
#        ""Hermione"",
#        ""Harry"",
# deque([""Draco"",

print(my_stack) # check my stack looks right

my_stack.pop() # this removes the element on top of the stack
# currently my_stack contains four elements:
#        ""Ron""])
#        ""Hermione"",
#        ""Harry"",
# deque([""Draco"",

my_stack.pop() # this, again, removes the element on top of the stack
# currently my_stack contains three elements:
#        ""Hermione""])
#        ""Harry"",
# deque([""Draco"",

my_stack.append(""Voldemort"") # this adds a new item ot the stack, on top
# currently my_stack contains four elements:
#        ""Voldemort""])
#        ""Hermione"",
#        ""Harry"",
# deque([""Draco"",
```",2018-11-23T13:40:10+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",bluebell94,"my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""]) - initial state of the stack

by executing my_stack.pop() for the 1st time- we have to eliminate the lastly added element on the stack in this case ""Severus"", 
so after that the stack will look like this [""Draco"", ""Harry"", ""Hermione"", ""Ron""]

by executing my_stack.pop() for the 2nd time-we have to follow the same procedure, however in this case on top of the stack is ""Ron"", so we eliminate this element and now our stock should like like this [""Draco"", ""Harry"", ""Hermione""]

Lastly, we execute my_stack.append(""Voldemort"") - so by this we are adding on top of the stack ""Voldemort"", and the stack has to contain the following 4  elements
 deque ([""Draco"", ""Harry"", ""Hermione"", ""Voldemort""])
",2018-11-23T16:09:34+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",ilsamoano,"```
#Consider to have a stack obtained by processing, one by one, the elements included in the list of the first exercise,
# i.e. ​my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])​.
# Describe the status of my_stack after the execution of each of the following operations:
# ​my_stack.pop()​, ​my_stack.pop()​, my_stack.append(""Voldemort"")​.


from collections import deque 

Grinwald_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

Grinwald_stack.pop() 
#this operation modifies the stack ""Grinwald_stack"" removing the last value ""Severus""
#currently the stack ""Grinwald_stack"" contains four elements
#deque([""Draco"", ""Harry"", ""Hermione"", ""Ron""])

Grinwald_stack.pop() 
#this operation modifies the stack removing the (now new) last value ""Ron""
#currently the stack ""Grinwald_stack"" contains three elements
#deque([""Draco"", ""Harry"", ""Hermione""])

Grinwald_stack.append(""Voldemort"") 
#this operation modifies the stack ""Grinwald_stack"" adding at the very top the value ""Voldemort""
#currently the stack ""Grinwald_stack"" contains three elements
#deque([""Draco"", ""Harry"", ""Hermione"", ""Voldermort""])

print(Grinwald_stack)


deque(['Draco', 'Harry', 'Hermione', 'Voldemort'])

```

",2018-11-23T17:02:54+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",simayguzel,"my_stack = deque ( )
my_stack = ([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_stack.pop( )
output is 'Severus' #""Severus"" is extracted from my_stack.

Now my_stack is ['Draco', 'Harry', 'Hermione', 'Ron'].

my_stack.pop( ) 
output is 'Ron' #'Ron' is extracted from my_stack.
#Now my_stack is ['Draco', 'Harry', 'Hermione'].

my_stack.append(""Voldemort"")
print (my_stack) 
output = ['Draco', 'Harry', 'Hermione', 'Voldemort']

So, my_stack after is ['Draco', 'Harry', 'Hermione', 'Voldemort'] .",2018-11-23T17:40:21+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",DavideApolloni,"my_stack=deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

my_stack.pop()
my_stack=deque([""Draco"", ""Harry"", ""Hermione"", ""Ron""])

my_stack.pop()
my_stack=deque([""Draco"", ""Harry"", ""Hermione""])

my_stack.append(""Voldemort"")
my_stack=deque([""Draco"", ""Harry"", ""Hermione"", ""Voldemort""])",2018-11-24T10:37:30+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",Totaro1996,"from collections import deque

Characters_stack=deque([""Draco"", ""Harry"", ""Hermione"", ""Severus""])

Characters_stack.pop()   #it removes ""Severus"", the last element in the stack. 
                                        #Characters_stack currently contains 4 elements [""Draco"", ""Herry"", 
                                        ""Hermione"", ""Ron""]

Characters_stack.pop()   #it applies again to the last element and consequently it removes ""Ron"". 
                                       #Characters_stack is now composed by 3 elements 
                                         [""Draco"",""Herry"",""Hermione""]

Characters_stack.append(""Voldemort"") #it adds a new element
 
print(Characters_stack)

Characters_stack=deque([""Draco"", ""Herry"", ""Hermione"", ""Voldemort""])

                                      
",2018-11-24T11:00:32+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",SeverinJB,"**1** from collections import deque
**2** harry_potter_und_ein_stein = deque([""Draco"",""Harry"",""Hermione"",""Ron"",""Severus""])
**3** harry_potter_und_ein_stein.pop()
**4** harry_potter_und_ein_stein.pop()
**5** harry_potter_und_ein_stein.append(""Voldemort"")

In line 3, ""Severus"" is removed from the stack. The stack now contains ""Draco"", ”Harry"", ""Hermione"", and ""Ron"". 
In line 4, ""Ron"" is removed from the stack. The stack now contains ""Draco"", ""Harry"", and ""Hermione"".
In line 5, ""Voldemort"" is added to the stack on the right. The stack now contains ""Draco"", ""Harry"", ""Hermione"", and ""Voldemort"".",2018-11-24T11:17:22+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",MattiaSpadoni,"- my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
- my_stack.pop #remove the fist element, in this case ""Draco""
   my_stack = deque([""Harry"", ""Hermione"", ""Ron"", ""Severus""])
- my_stack.pop #remove the fist element, in this case ""Harry""
   my_stack = deque([""Hermione"", ""Ron"", ""Severus""])
- my_stack.append (""Voldemort"") #add an element on the top of the stack

my_stack = deque([""Voldemort"", ""Hermione"", ""Ron"", ""Severus""]) #final state.",2018-11-24T15:00:03+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",friendlynihilist,"```
from collections import deque 
#first of all I need to import the construct _deque_ from the module _collections_
potter_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""]) 
#I've created a stack containing five different strings, ordered alphabetically. In this case, ""Severus"" is the last on top of it.
potter_stack.pop() 
#By using the _.pop_ method I'm removing the variable on top of the pile, in this case ""Severus""
potter_stack.pop() 
#Now poor ""Ron"" is going to be removed.
potter_stack.append(""Voldemort"") 
#And, through the _.append_ method, evil ""Voldemort"" is going to be added on top.
print(potter_stack) 
#Printing the result on screen I can see that my stack now contains, in order: ""Draco"", ""Harry"", ""Hermione"", ""Voldemort"".
```",2018-11-24T16:00:07+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",federicabologna,"harry_potter_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
#stack created with elements in the order I provided
harry_potter_stack.pop()
#take ""Severus"" out, since is the last element added
harry_potter_stack.pop()
#take ""Ron"" out, since is the second last element added
harry_potter_stack.append(""Voldemort"")
#add ""Voldemort""
Thus: 'Draco', 'Harry', 'Hermione', 'Voldemort'

```
from collections import deque

harry_potter_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
harry_potter_stack.pop()
harry_potter_stack.pop()
harry_potter_stack.append(""Voldemort"")
print(harry_potter_stack)

deque(['Draco', 'Harry', 'Hermione', 'Voldemort'])
```",2018-11-25T10:05:19+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",saraarmaroli,"my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

my stack.pop () # i Remove Severus, the element on the top of my stack
my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron""])

my stack.pop () # i Remove Ron
my_stack = deque([""Draco"", ""Harry"", ""Hermione""])

My_stack.append (“Voldemort”)
my_stack = deque([""Draco"", ""Harry"", ""Hermione"", “Voldemort”])


",2018-11-25T15:14:54+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",VittoriaMoccia,"Consider to have a stack obtained by processing, one by one, the elements included in the list of the first exercise, i.e. my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""]). Describe the status of my_stack after the execution of each of the following operations: my_stack.pop(), my_stack.pop(), my_stack.append(""Voldemort"").

First we create a new stack:

my_stack = deque()
my_stack.append(""Draco"")
my_stack.append(""Harry"")
my_stack.append(""Hermione"")
my_stack.append(""Ron"")
my_stack.append(""Severus"")

print(my_stack)

Result: ['Draco', 'Harry', 'Hermione', 'Ron', 'Severus']

Since a stack is a particular list seen from bottom to top:

my_stack.pop() --> this first operation would remove ""Severus"", since it's the last item added
my_stack.pop() --> this time would delete ""Ron"", which was added right before ""Severus""
my_stack.append(""Voldemort"") --> this would add a new item to the stack, so the final result will be:

['Draco', 'Harry', 'Hermione', 'Ron', 'Voldemort']",2018-11-25T17:13:54+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",MilenaCorbellini,"from collections import deque
characters_stack = deque()
characters_stack.append(""Draco"")
characters_stack.append(""Harry"")
characters_stack.append(""Hermione"")
characters_stack.append(""Ron"")
characters_stack.append(""Severus"")
characters_stack.pop()
characters_stack.pop()
characters_stack.append(""Voldemort"")
print(characters_stack)

After the first characters_stack.pop the last element of the stack is cancelled, after the second the previous one.
After the characters_stack.pop operation the string ""Voldemort"" is added.",2018-11-25T19:40:46+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",lisasiurina,"HPCharacters_stack = deque ( ) 
HPCharacters_stack = ([""Draco"",""Harry"",""Hermione"",""Ron"",""Severus""])
#stack creation 

HPCharacters_stack.pop( ) 
#it removes the element on top of the stack which is Severus

HPCharacters_stack.pop( ) 
#it removes the element on top of the stack which is Ron""

HPCharacters_stack.append(""Voldemort"")
 #it adds a new name

print (HPCharacters_stack)
output = ['Draco', 'Harry', 'Hermione', 'Voldemort']",2018-11-25T19:58:41+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",tceron,"my_hp_stack = deque()
my_hp_stack.append(""Draco"")
my_hp_stack.append(""Harry"")
my_hp_stack.append(""Hermione"")
my_hp_stack.append(""Ron"")
my_hp_stack.append(""Severus"")

print (my_hp_stack)
 
Output [""Draco"", ""Harry"", ""Hermione"", ""Voldemort""]

my_hp_stack.pop()       # removes the element on top (stacks are seen from bottom to top)
my_hp_stack = ([""Draco"", ""Harry"", ""Hermione"", ""Ron""])
my_hp_stack.pop()     # removes the element on top
my_hp_stack = ([""Draco"", ""Harry"", ""Hermione""])
my_hp_stack.append(""Voldemort"")       # add one element to the top

print (my_hp_stack)
[""Draco"", ""Harry"", ""Hermione"", ""Voldemort""]
",2018-11-27T07:19:10+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 2",andreamust,"from collections import deque
my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""]) # this passage creates a stack containing 5 names
print(my_stack)

my_stack.pop() # removes the last element ""Severus""
print(my_stack)

my_stack.pop() # removes the last element ""Ron""
print(my_stack)

my_stack.append(""Voldemort"") #adds a new element ""Voldemord"" on the top of the stack
print(my_stack)",2018-11-27T15:32:38+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",hizclick,"```
names =  [""Harry"",""Draco"",""Hermione"",""Ron"",""Severus""]
sorted_names = sorted(names)
print(sorted_names)
```
/////////////////////////////////////////////////////////////
```
names= []
names.insert(0, 'Harry')
names.insert(1, 'Draco')
names.insert(2, 'Hermione')
names.insert(3, 'Ron')
names.insert(4, 'Severus')
sorted_names = sorted(names)
print(sorted_names)
```
/////////////////////////////////////////////////////////////
```

names= list()
names.append('Harry')
names.append('Draco')
names.append('Hermione')
names.append( 'Ron')
names.append('Severus')
sorted_names = sorted(names)
print(sorted_names)
```",2018-11-23T07:43:45+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",delfimpandiani,"```
# METHOD 1: alphabetize manually and add apend them already in alphabetical order

harrypotter_list0 = list()  # this creates a new list

harrypotter_list0.append(""Draco"")
harrypotter_list0.append(""Harry"")
harrypotter_list0.append(""Hermione"")
harrypotter_list0.append(""Ron"")
harrypotter_list0.append(""Severus"")

# check our list looks right
print(harrypotter_list0)


# METHOD 2: first create the list without regard the alphabetization and alphabetize later
harrypotter_list = list()  # this creates a new list

harrypotter_list.append(""Harry"")
harrypotter_list.append(""Draco"")
harrypotter_list.append(""Hermione"")
harrypotter_list.append(""Ron"")
harrypotter_list.append(""Severus"")
# so far harrypotter_list contains:
# list([ ""Harry"", ""Draco"", ""Hermione"", ""Ron"", ""Severus""])

# now, find a way of sorting alphabetically (used Google to find the command)
harrypotter_list.sort()

# check our list looks right
print(harrypotter_list)
```",2018-11-23T13:39:00+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",bluebell94,"protagonist_list ={""Harry"",""Draco"",""Hermione"",""Ron"",""Severus""}

  | 1 | protagonist_list=list()
-- | -- | --
2 | protagonist_list.append(""Harry"")
3 | protagonist_list.append(""Draco"")
4 | protagonist_list.append(""Hermione"")
5 | protagonist_list.append(""Ron"")
6 | protagonist_list.append(""Severus"")
7 | protagonist_list.sort()
8 | print (protagonist_list)

I was thinking also about  using the commands >, < in order to put the names in alphabetical order, However, it seems as a too long and much more complex process, especially when the command ""sort"" is available and has the same functions.",2018-11-23T15:53:30+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",ilsamoano,"```
# Write a sequence of instructions in Python 
# so as to create a list with the following elements ordered alphabetically: 
#​""​Harry""​​, ​""​Draco""​​, ​""​Hermione""​​, ​​""​Ron""​​, ""​Severus""​​.


Grinwald = list () 
Grinwald.append(""Hermione"")
Grinwald.append(""Draco"")
Grinwald.append(""Harry"")
Grinwald.append(""Severus"")
Grinwald.append(""Ron"")

Grinwald.sort()

print(Grinwald)

```",2018-11-23T16:13:51+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",LuciaGiagnolini12,"```
hp_list = list()

hp_list.append(""Draco"")
hp_list.append(""Harry"")
hp_list.append(""Hermione"")
hp_list.append(""Ron"")
hp_list.append(""Severus"")

print(hp_list)
```",2018-11-23T16:15:08+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",simayguzel,"
list_str = list ( )
list_str.append(""Harry"")
list_str.append(""Draco"")
list_str.append(""Hermione"")
list_str.append(""Ron"")
list_str.append(""Severus"")

list_str.sort( )
print (list_str)
output : ['Draco', 'Harry', 'Hermione', 'Ron', 'Severus']


",2018-11-23T17:07:51+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",Totaro1996,"Characters_list=list( )

Characters_list.append (""Draco"")
Characters_list.append (""Harry"")
Characters_list.append (""Hermione"")
Characters_list.append (""Ron"")
Characters_list.append (""Severus"")

print (Characters_list)

",2018-11-24T09:50:08+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",DavideApolloni,"![screenshot at nov 24 11-22-27](https://user-images.githubusercontent.com/44606693/48967042-5653aa00-efdb-11e8-90a0-4e37ccaf57cb.png)

Output: ['Draco', 'Harry', 'Hermione', 'Ron', 'Severus']
",2018-11-24T10:23:42+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",SeverinJB,"harry_potter_und_ein_stein = list([""Harry"",""Draco"",""Hermione"",""Ron"",""Severus""])
harry_potter_und_ein_stein = sorted(harry_potter_und_ein_stein)

_Optional:_
print(harry_potter_und_ein_stein)",2018-11-24T11:16:22+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",friendlynihilist,"```
potter_list = list() #I've just sorted the list manually
potter_list.append(""Draco"")
potter_list.append(""Harry"")
potter_list.append(""Hermione"")
potter_list.append(""Ron"")
potter_list.append(""Severus"")
print(potter_list)
```

```
potter_list = list()
potter_list.append(""Hermione"")
potter_list.append(""Draco"")
potter_list.append(""Ron"")
potter_list.append(""Harry"")
potter_list.append(""Severus"")
potter_list.sort() #I've found that built-in function named _sort_, 
don't know if it's considered cheating for the sake of the exercise :)
I suppose it's also possible to write just one line and put strings inside the sort bracket.
print(potter_list)
```",2018-11-24T13:12:51+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",MattiaSpadoni,"""​Harry""​, ""​Draco""​, ""​Hermione""​, ​""​Ron""​, ""​Severus""

dislike_harrypotter = list()
dislike_harrypotter.append (""draco"")
dislike_harrypotter.append (""Harry"")
dislike_harrypotter.append (""Hermione"")
dislike_harrypotter.append (""Ron"")
dislike_harrypotter.append (""Severus"")

print dislike_harrypotter

With the use of ""sort"" built-in function

dislike_harrypotter = list()
dislike_harrypotter.append(""​Harry""​, ""​Draco""​, ""​Hermione""​, ​""​Ron""​, ""​Severus"")
dislike_harrypotter.sort
dislike_harrypotter(""Draco"",""Harry"",""Hermione"",""Ron"",""severus"")



",2018-11-24T14:54:16+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",federicabologna,"```
harry_potter_list = list()
harry_potter_list.append(""Harry"")
harry_potter_list.append(""Draco"")
harry_potter_list.append(""Hermione"")
harry_potter_list.append(""Severus"")
harry_potter_list.append(""Ron"")
sorted_harry_potter_list = sorted(harry_potter_list)
print(sorted_harry_potter_list)
```

or

```
harry_potter_list = list([""Harry"", ""Ron"", ""Hermione"", ""Draco"", ""Severus""])
sorted_harry_potter_list = sorted(harry_potter_list)
print(sorted_harry_potter_list)
```",2018-11-25T09:59:49+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",saraarmaroli,"harry_potter_list=list ()
harry_potter_list.append (“Draco”)
harry_potter_list.append (“Harry”)
harry_potter_list.append (“Hermione”)
harry_potter_list.append (“Ron”)
harry_potter_list.append (“Severus”)

Print(harry_potter_list)",2018-11-25T15:02:30+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",VittoriaMoccia,"Write a sequence of instructions in Python so as to create a list with the following elements ordered alphabetically: ""​Harry""​, ""​Draco""​, ""​Hermione""​, ​""​Ron""​, ""​Severus""​.

Starting from the list items in the given order, the first list would look this way:

harry_potter_characters = list()
harry_potter_characters.append(""Harry"")
harry_potter_characters.append(""Draco"")
harry_potter_characters.append(""Hermione"")
harry_potter_characters.append(""Ron"")
harry_potter_characters.append(""Severus"")

print(harry_potter_characters)

And the result would be: 

['Harry', 'Draco', 'Hermione', 'Ron', 'Severus']

But then, we need to order properly all the names. This can be done in two ways (even though the third one is writing them by hand, of course). The first method doesn't use instructions to give the order. It just removes all the items but ""Draco"" from the list, and then adds them back in order. Like this:

[...]
harry_potter_characters.remove(""Harry"")
harry_potter_characters.remove(""Hermione"")
harry_potter_characters.remove(""Ron"")
harry_potter_characters.remove(""Severus"")

And here only ""Draco"" remains in the list. Then:

harry_potter_characters.append(""Harry"")
harry_potter_characters.append(""Hermione"")
harry_potter_characters.append(""Ron"")
harry_potter_characters.append(""Severus"")

print(harry_potter_characters)

The result is the list in the alphabetical order: 

['Draco', 'Harry', 'Hermione', 'Ron', 'Severus']

The second method uses a proper instruction:

[...]
harry_potter_characters.remove(""Draco"")
harry_potter_characters.insert(0, ""Draco"")

print(harry_potter_characters)

And the result is the same, but it's way faster to obtain it: ['Draco', 'Harry', 'Hermione', 'Ron', 'Severus']",2018-11-25T16:58:42+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",katalu,"my_harrypotter_list = list ()

my_harrypotter_list.append(""Harry"")
my_harrypotter_list.append(""Draco"")
my_harrypotter_list.append(""Hermione"")
my_harrypotter_list.append(""Ron"")
my_harrypotter_list.append(""Severus"")

my_harrypotter_list.sort()

print(my_harrypotter_list)",2018-11-25T18:51:41+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",lisasiurina,"HPCharacters_list = list()

HPCharacters_list.append(""Draco"")
HPCharacters_list.append(""Harry"")
HPCharacters_list.append(""Hermione"")
HPCharacters_list.append""Ron"")
HPCharacters_list.append(""Severus"")

HPCharacters_list.sort( )

print(HPCharacters_list)

Output: [‘Draco', 'Harry', 'Hermione', 'Ron', 'Severus']",2018-11-25T19:03:49+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",dersuchendee,"```
list_hp = list ()
list_hp.append(""Draco"")
list_hp.append(""Harry"")
list_hp.append(""Hermione"")
list_hp.append(""Ron"")
list_hp.append(""Severus"")

print(list_hp)

[""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""]
```

I don't see in the pdf where the .sort method is, and how to use it.",2018-11-25T19:21:16+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",MilenaCorbellini,"characters_list = list()
characters_list.append(""Severus"")
characters_list.append(""Draco"")
characters_list.append(""Harry"")
characters_list.append(""Hermione"")
characters_list.append(""Ron"")
characters_list.append(""Severus"")
characters_list.remove(""Severus"")
print(characters_list)",2018-11-25T19:22:06+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",essepuntato,"Hi all,

thanks for the answers, and also thanks for proposing additional strategies that go beyond the simpler ""organise the item in the list by hand"", that was of course one of the possibilities.

Just a suggestion: try always to test your code in Python (if you didn't), since I've found a bunch of syntactical error here and there.",2018-11-27T06:38:16+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",tceron,"""​Harry""​, ""​Draco""​, ""​Hermione""​, ​""​Ron""​, ""​Severus""

happy_potter_list = list ()
happy_potter_list.append = list (""Harry"")
happy_potter_list.append = list (""Draco"")
happy_potter_list.append = list (""Hermione"")
happy_potter_list.append = list (""Ron"")
happy_potter_list.append = list (""Severus"")

happy_potter_list.sort()

print (happy_potter_list)

list [""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""]",2018-11-27T06:50:05+00:00
comp-think/2018-2019,"Lecture ""Organising information: ordered structures"", exercise 1",andreamust,"harry_potter_list = list()
harry_potter_list.append('Harry')
harry_potter_list.append('Draco')
harry_potter_list.append('Hermione')
harry_potter_list.append('Ron')
harry_potter_list.append('Severus')
harry_potter_list.sort()
print(harry_potter_list)


result: ['Draco', 'Harry', 'Hermione', 'Ron', 'Severus']
",2018-11-27T11:55:41+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",delfimpandiani,"```
def test_find_words(first_word, second_word, bib_entry, expected):
    result = find_words(first_word, second_word, bib_entry)
    if result == expected:
        return True
    else:
        return False

def find_words(first_word, second_word, bib_entry):
    result = 0
    if first_word in bib_entry:
        result += 1
        if second_word in bib_entry:
            result += 1
            return result
        else:
            return result
    elif second_word in bib_entry:
        result += 1
        return result
    else:
            return result

print(test_find_words(""poema"", ""storni"", ""los poemas de Alfonsina Storni"", 2)
print(test_find_words(""delfina"", ""sol"", ""delfina sol martinez pandiani"", 2)
print(test_find_words(""complexity"", ""trick"", ""A few complex tricks to simplify"", 1)
```",2018-11-19T16:18:25+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",giuliapl,"I tried but I am not sure.

```
def test_contains_words (first_word, second_word, bib_entry, expected):
    result = contains_words (first_word, second_word, bib_entry)
    if result == expected:
        return True
    else:
        return False

def contains_words (first_word, second_word, bib_entry):
    if first_word in bib_entry and second_word in bib_entry:
        return 2
    else:
        (first_word in bib_entry or second_word in bib_entry)
        return 1
    if first_word not in bib_entry and second_word not in bib_entry:
        return 0

print(test_contains_words(""Peroni"", ""HTML"", ""Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132"", 2))
print(test_contains_words(""Peroni"", ""HTML"", ""Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132"", 1))
print(test_contains_words(""Peroni"", ""HTML"", ""Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132"", 0))
```",2018-11-19T18:21:56+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",simayguzel,"`
def test_contains_word(first_word, second_word, bib_entry, expected): 
    result = contains_word(first_word, second_word, bib_entry)
    if expected == result:
        return True 
    else:
        return False

def contains_word(first_word, second_word, bib_entry):
    result = 0
    
    if first_word in bib_entry and second_word in bib_entry:
        return result + 2
    elif first_word in bib_entry or second_word in bib_entry:
        return result + 1
    else:
        return result
        


print(contains_word(""Problem"", ""Solving"", ""Miller, B. N., Ranum, D. L. (2011). Problem Solving with Algorithms and Data Structures using Python"") output = 2
print(contains_word(""Development"", ""Programming"", "" Beck, K. (2003). Test-Driven Development by Example. Addison Wesley"")   output = 1 `",2018-11-19T19:35:14+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",federicabologna,"def test_words(first_word, second_word, bib_entry, expected_result):
  result = words(first_word, second_word, bib_entry)

  if result == expected_result:
    return True
  else:
    return False

def words(first_word, second_word, bib_entry):
  contains_first_word = first_word in bib_entry
  contains_second_word = second_word in bib_entry
  result = 0

  if contains_first_word:
    result += 1
    if contains_second_word:
      result += 1
      return result
    else:
      return result
  if contains_second_word:
    result +=1
    return result
  else:
    return result

print(test_words(""move"", ""sole"", ""amor che move il sole"", 2))
print(test_words(""mani"", ""sera"", ""queste tue mani a difesa di te"", 1)) 
print(test_words(""anima"", ""bicicletta"", ""ho sceso dandoti"", 0))",2018-11-19T23:10:04+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",EleonoraPeruch,"def test_contains_word (first_word, second_word, bib_entry, expected):
    result = contains_word (first_word, second_word,bib_entry)
    if expected == result :
        return True
    else :
        return False

def contains_word (first_word, second_word, bib_entry) :
    result_value = 0
    contains_first_word = first_word in bib_entry
    contains_second_word = second_word in bib_entry
    if contains_first_word and contains_second_word :
        return result_value + 2
    elif contains_first_word or contains_second_word :
        return result_value + 1
    else:
        return result_value

print (test_contains_word (""a"", ""b"", ""abcd"", 2))
print (test_contains_word (""a"", ""b"", ""acde"", 1))
print (test_contains_word (""a"", ""b"", ""cdef"", 0))

",2018-11-20T17:28:48+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",mangiafrangette,"```
def test_words_in_bib(word1, word2, bibentry, expected):
    result = words_in_bib(word1, word2, bibentry)

    if expected == result:
        return True
    else: 
        return False


def words_in_bib(word1, word2, bibentry):
    result = 0

    if word1 in bibentry:
        result = result + 1
    if word2 in bibentry:
        result = result + 1

    return result
    
print(test_words_in_bib(""Pink"", ""Floyd"", ""Pink Floyd were an English rock band"", 2))
print(test_words_in_bib(""Pink"", ""Monkeys"", ""Arctic Monkeys are an English rock band"", 1))
print(test_words_in_bib(""bau"", ""Stelle"", ""Baustelle is an indie rock band from Siena, Italy"", 2))
```
First and second test calls return True, the last one is False (the words are not found in bibentry due to case sensitiveness)",2018-11-20T17:57:15+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",beccadelbens,"def test_contains_word (first_word, second_word, bib_entry, expected_result)
 result= contains_word (first_word, second_word, bib_entry)
 if expected == result
  return True
 else:
  return False

def contains_word (first_word, second_word, bib_entry)
 contains_first_word = first_word in bib_entry
 contains_second_word = second_word in bib_entry

 if contains_first_word and contains_second_word
  return 2
 elif contains_first_word or contains_second_word
  return 1
 else:
  return 0

print (test_contains_word (""cura"", ""opera"", ""L'opera d'arte nell'epoca della sua riproducibilità tecnica (2012)/ W. Benjamin; a cura di F. Desideri""), 2)
print (test_contains_word (""cura"", ""opera"", ""Minima culinaria (2015)/ Z. Ciuffoletti; a cura di C. Costagli""), 1)
print (test_contains_word (""cura"", ""opera"", ""Il piccolo principe (1981)/ A. de Saint-Exupéry""), 0)






",2018-11-20T17:57:32+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",hizclick,"```def test_contains_word(first_word, second_word, bib_entry, expected):
	result = contains_word(first_word, second_word, bib_entry)
	if expected == result:
		return True
	else:
		return False
		
def contains_word(first_word, second_word, bib_entry):
	contains_first_word = first_word in bib_entry
	contains_second_word = second_word in bib_entry
	result = 0
	if contains_first_word and contains_second_word:
		result += 2
		return result
	elif contains_first_word or contains_second_word:
		result +=1
		return result
	else:
		return result

print(test_contains_word(""h"", ""i"", ""hiii"", 2))
print(test_contains_word(""h"", ""k"", ""hiii"", 1))
print(test_contains_word(""l"", ""m"", ""hiii"", 0))
```",2018-11-20T19:11:42+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",leticiasandra,"

def  test_contains_word(first_word, second_word, bib_entry, expected):
       result = contains_word(first_word, second_word, bib_entry)
       if expected == result:
            return True
       else:
            return False
 
def  contains_word(first_word, second_word, bib_entry):
       contains_first_word = first_word in bib_entry
       contains_second_word = second_word in bib_entry
       result_value = 0

       if contains_first in bib_entry:
          result_value= +1
          return result
       elif contains_second_word:
             result_value = +1
             return result
      else:
            return result_value
 
print(test_contains_word(""food"", ""craft"", ""eat food"", 1))
print(test_contains_word(""craft"", ""art"", ""craft chair"", 1))
print(test_contains_word(""food"", ""craft"", ""enjoy living"", 0))



",2018-11-20T22:53:21+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",ilsamoano,"```
#Following the template in ​Listing 11,​ write in Python the algorithm proposed originally ​in
#Figure 4 of the lecture notes entitled ""Algorithms"" as a flowchart, and accompany such code 
#with the related test function and some executions with different input values

def test_thereader(string1, string2, string3, expected):
    result = thereader(string1, string2, string3)
    
    if expected == result: 
        return True
    else:
        return False
    
def thereader(string1, string2, string3):
    result = 0
    
    if string1 and string2 in string3:
       result = result + 2
    
    elif string1 or string2 in string3:
            result = result + 1
    
    else:
       result = result
       
       
    return result
    
print(test_thereader(""a"", ""b"", ""abcd"", 2))
print(test_thereader(""a"", ""d"", ""abce"", 1))
print(test_thereader(""c"", ""e"", ""abcd"", 1))

```
True 
True
True",2018-11-20T23:29:57+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",friendlynihilist,"```
def test_match_words (first_word, second_word, bib_entry, expected):
    result = match_words (first_word, second_word, bib_entry)
    if result == expected:
        return True
    else:
        return False

def match_words (first_word, second_word, bib_entry):
    result = 0

    if first_word in bib_entry:
        result += 1
    if second_word in bib_entry:
        result += 1

    return result

print(test_match_words(""heart"", ""gold"", ""I've been a miner for a heart of gold"", 2))
print(test_match_words(""Martin"", ""Heidegger"", ""I'm sitting here reading Heidegger and hoping this water will boil"", 1))
print(test_match_words(""Pavese"", ""1945"", ""Hai viso di pietra scolpita, sangue di terra dura, sei venuta dal mare"", 0))
```",2018-11-20T23:41:40+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",SeverinJB,"```
def test_flowchart(term_1, term_2, bib_entry, expected): 
    result = flowchart(term_1, term_2, bib_entry)
    if result == expected:
        return True 
    else:
        return False

def flowchart(term_1, term_2, bib_entry): 
    result_value = 0
    if term_1 in bib_entry: 
        result_value = result_value + 1
    if term_2 in bib_entry:
        result_value = result_value + 1
    return result_value

print(test_flowchart(""ab"",""cd"",""abcd"",2)) 
print(test_flowchart(""ab"",""cd"",""abef"",1))
print(test_flowchart(""ab"",""cd"",""xycd"",1)) 
print(test_flowchart(""ab"",""cd"",""xyz"",0))
```",2018-11-21T09:32:35+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",MattiaSpadoni,"I had some problems with the correct syntax of summing something to the variable. But I checked it and now it works.

P.S. I think that we don't need a ""If... else"" statement here, we don't have an alternative set of instruction if the first if is false, the only thing that we have to do is going on to the next one.

def test(first_word, second_word, bib_entry, expected):
     result = istheretheword (first_word, second_word, bib_entry)
	    
	    if expected == result:
	        
	        return True
	    
	    else:
	        
	        return False
	
	def istheretheword (first_word, second_word, bib_entry):
	    x = first_word in bib_entry
	    y = second_word in bib_entry
	    result = 0
	    
	    if x:
	       result += 1
	    if y:
	       result += 1
	
               return result
	    
      print(test(""a"", ""b"", ""abcd"", 2))
	
      print(test(""a"", ""b"", ""acde"", 1))
      print(test(""a"", ""b"", ""cdef"", 0))",2018-11-21T10:21:45+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",lisasiurina,"def test_find_words(first_word, second_word, bib_entry, expected):

result = contains_word(first_word, second_word, bib_entry)

 if result == expected:
        return True
    else:
        return False

def contains_words(first_word, second_word, bib_entry):
    result = 0
If first_word in bib_entry:
result +=1
return result

If second_word in bib_entry:
result +=1
return result

else:
	return result 

 elif  second_word in bib_entry:

result += 1
        return result
    else:
            return result


print(test_words(""Peroni"", ""HTML"", ""Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132))

True, output 2

print(test_words)(“Mesmerizing”, “Miracle”, “Mesmerizing Ghost Doctor”))

True, output 1
",2018-11-21T10:56:58+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",DavideApolloni,"
![screenshot at nov 21 15-13-43](https://user-images.githubusercontent.com/44606693/48846730-1b196700-eda0-11e8-93fb-30a6a3f2d1ad.png)

",2018-11-21T14:15:03+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",dersuchendee,"def test_<text_contains_words>(<word1, word2, bib-entry>, expected):
result = <algorithm>(<word1, word2, bib-entry>)
if result == expected:
return True
else:
return False

def <text_contains_words>(<word1, word2, bib-entry>):
If word1 in bib_entry:
return 1
If word 2 in bib_entry:
return 1
If word1 and word2 in bib_entry:
return 2
else
return 0

print(test_<text_contains_words>(""Ada"", ""of"", ""Ada Lovelace was the daughter"", 1))
print(test_<text_contains_words>(""Ada"", ""Lovelace"", ""Ada Lovelace was the daughter"", 2))
print(test_<text_contains_words>(""cat"", ""dog"", ""Ada Lovelace was the daughter"", 0))",2018-11-21T14:46:37+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",tceron,"def test_containing_word(firstword, secondword, bibentry, expected):
result = test_containing_word(firstword, secondword, bibentry)

if result == expected:
return True
else:
return False

def test_containing_word (firstword, secondword, bibentry):
return = 0

if firstword and secondword:
       result 2
       return result
if firstword or secondword:
       result 1
       return result
else:
      return result

print(test_containing_word(""linguistics"", ""Alan"", ""Davies, Alan, and Catherine Elder, eds. The handbook of applied linguistics. John Wiley & Sons, 2008."", 2))
print(test_containing_word(""linguistics"", ""Alan"", ""Church, Kenneth W., and Robert L. Mercer. ""Introduction to the special issue on computational linguistics using large corpora."" Computational linguistics 19.1 (1993): 1-24."", 1))
print(test_containing_word(""linguistics"", ""Alan"", ""Chowdhury, Gobinda G. ""Natural language processing."" Annual review of information science and technology 37.1 (2003): 51-89."", 0))",2018-11-22T06:49:15+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",MilenaCorbellini,"def contains_word(first_word, second_word,  bib_entry):
    contains_first_word = first_word in bib_entry
    contains_second_word = second_word in bib_entry
    if contains_first_word and contains_second_word:
       return 2
    elif contains_first_word or contains_second_word:
         return 1
    else:
         return 0
def test_contains_word(first_word, second_word, bib_entry, expected):
    result = contains_word(first_word, second_word, bib_entry)
    if expected == result:
        return True
    else:
         return False
print(contains_word(""Shakespeare"", ""Sogno"", ""Sogno di una notte di mezz'estate, Shakespeare""))
print(contains_word(""Shakespeare"", ""la"", ""la locandiera, Goldoni""))
print(contains_word(""Sakespeare"", ""Giulietta"", ""Capuleti e Montecchi, Bellini""))",2018-11-25T19:00:57+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 3",essepuntato,"Hi all,

Thanks for your comment. The idea of the exercise is just to convert literally the various widgets in the flowchart as proper constructs in Python. In particular – since several of you have done that – you should not use more than one result statements, because in the flowchart only **one** output widget is actually used.

The solution of the exercise is shown as follows - and it is also available as [Python file](http://comp-think.github.io/2018-2019/python/first_algorithm_ex3.py) in the GitHub repository:

```
# Test case for the algorithm
def test_contains_word(first_word, second_word, bib_entry, expected):
    result = contains_word(first_word, second_word, bib_entry)
    if expected == result:
        return True
    else:
        return False


# Code of the algorithm
def contains_word(first_word, second_word, bib_entry):  # input/output: input two words and a bibliographic entry
    result = 0  # process: initialize the result value to 0

    if first_word in bib_entry:  # decision: the first word is in the bibliographic entry
        result = result + 1  # process: sum 1 to the result value

    if second_word in bib_entry:  # decision: the second word is in the bibliographic entry
        result = result + 1  # process: sum 1 to the result value

    return result  # input/output: return the result value


# Three different test runs
print(test_contains_word(""a"", ""b"", ""abcd"", 2))
print(test_contains_word(""a"", ""b"", ""acde"", 1))
print(test_contains_word(""a"", ""b"", ""cdef"", 0))
```",2018-11-26T12:16:06+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",dersuchendee,"“Spam” not in “spa span sparql” = T

Not (“egg”>”span”)= F

T and F = F",2018-11-19T15:00:02+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",delfimpandiani,"Mmmm.. I wonder if I got this wrong:

(""spam"" not in ""spa span sparql"") --> is ""spam"" not in ""spa span sparql""? --> No = True

(""egg"" > ""span"") --> is ""egg"" bigger than ""span"" (is egg alphabetically bigger than span?) --> No = False

True and not (False)

True and True

True

",2018-11-19T16:15:21+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",mangiafrangette,"""spam"" not in ""spa span sparql"" = True
and
not (""egg"" > ""span"") = True
True and True = True

Note: I agree with @delfimpandiani:  if ""a string S1 is less than another string S2 if the former one precedes the latter one according to a pure alphabetic order"" (Table 2, Programming languages lecture notes), I suppose that a string is greater than another string if the former _follows_ the latter in alphabetical order, therefore ""egg"" > ""span"" = False because ""egg"" does not follow ""span"" in the alphabet.",2018-11-19T16:42:52+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",lisasiurina,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")

""spam"" not in ""spa span sparql""  = True
not (""egg"" > ""span"") = not False = True

True and True = True",2018-11-19T18:50:27+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",simayguzel,"""spam"" not in ""spa span sparql"" = True
(""egg"" > ""span"") = False  --- not False = True
According to the Boolean value; 
True and True = True",2018-11-19T19:33:58+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",federicabologna,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")
True and not (False)
True and True
True",2018-11-19T21:34:29+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",EleonoraPeruch,"![ex 2 programming languages](https://user-images.githubusercontent.com/45010379/48764795-fc887280-ecb0-11e8-8cb6-ff90b6ba2054.PNG)
",2018-11-20T09:42:39+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",Totaro1996,"""spam"" not in ""spa span sparql"" and not (""egg"">""span"")
T and not F
T and t
True",2018-11-20T09:49:15+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",tceron,"`""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")`
True and not (False)
True and True
True",2018-11-20T10:35:14+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",MattiaSpadoni,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")

- I phase: brackets and first not don't influence each other so I can do them at the same time. Spam Is not in the string ""spa span sparql"" so ""not"" will return True. ""Egg"" is located before ""span"" so the operator ""&gt"" will return False (egg is ""less"" than ""span"")
Result:
True and not False

- II phase: I have to do ""not"" before ""and""
Result:
True and True

- III phase: now I can do the last operation ""And""
result: True",2018-11-20T16:24:55+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",friendlynihilist,"`""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")`
`""spam"" not in ""spa span sparql"" and not (False)`
`True and True`
`True`

Again, we need to execute the operation contained in round brackets `""egg"" > ""span""`. Alphabetically, _e_ is not bigger than _s_ (that is, it comes first in order) so the output is `False`. Then we resolve `not` operators and, finally, the `and` operator.
",2018-11-20T17:00:27+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",HiImBono,"Question

In the absence of round brackets, string operations have priority over boolean operations right? I was just wondering since _""spam"" not in ""spa span sparql""_ is not between round brackets but _(""egg"" > ""span"")_ is. It does completely make sense to me if it works like this, otherwise you might have boolean operators operating on strings rather than booleans. If this is correct this would mean that the round brackets around _(""egg"" > ""span"")_ are redundant. Any body could confirm this by commenting the hooray on my question?",2018-11-20T17:30:26+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",ilsamoano,"What is the boolean value of ​""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")​?

""spam"" not in ""spa span sparql"" and not (False) ​ >> ""egg"" should be less than ""span""
true and not false
true",2018-11-20T17:43:38+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",SeverinJB,"Applied with strings, the logical operator > (_""egg"" > ""span""_) uses the alphabetic order for the operation, e.g. ""a"" < ""b"" is true, because the letter ""a"" is listed before ""b"" in the alphabetic order. Based on this rule, the computation ""egg"" > ""span"" is false. 

""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")
true and not(false)
true and true
true",2018-11-20T18:57:44+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",Saraa04,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")

""spam"" not in ""spa span sparql"" = **_True_**
not (""egg"" > ""span"") = **_not (False)_**
True and not (False) = **_True and True_**
=> **True**
",2018-11-20T22:29:29+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",DavideApolloni,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")

""spam"" not in ""spa span sparql"" --> true
(""egg"" > ""span"") --> false

true and not (false)
true and true
true",2018-11-21T14:10:27+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 2",essepuntato,"@HiImBono 

Answering your question, indeed all the comparisons will be executed before any other boolean operation.",2018-11-26T12:03:40+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",AriannaPizzicori,"not (not True or False and True) or False
not (False or False) or False
not False or False
True or False
True",2018-11-19T14:35:14+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",dersuchendee,"Not true or false and true= false and true= false

Not (false)= true

True or false= true",2018-11-19T14:57:12+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",giuliapl,"not (not True or False and True) or False
not (False or Flase and True) or False
not (False and True) or False
not (False) or False
True or False = True",2018-11-19T15:56:20+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",delfimpandiani,"Rules to keep in mind:

Order of operations (without counting brackets):
1. not
2. and
3. or

False and True = False
True and False = False
False or True = True
True or False = True

Then:

not (not True or False and True) or False
since not True = False --> not (False or False and True) or False
since False and True = False -> not (False or False) or False
since False or False = False --> not (False) or False
since not False = True --> True or False
since True or False = True --> True

True!
",2018-11-19T16:08:32+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",lisasiurina,"not (not True or False and True) or False?--> 
not (False or False and True) or False--> 
not (False or False) or False--> 
not False or False--> 
True or False = True 

True",2018-11-19T18:45:50+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",federicabologna,"not (not True or False and True) or False
not (False or False and True) or False
not (False or False) or False
not False or False
True or False
True",2018-11-19T21:33:21+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",Totaro1996,"not (not True or False and True) or False
not (False or False and True) or False
not (False or False) or False
not False or False
True or False
True",2018-11-20T09:22:38+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",EleonoraPeruch,"![ex 1 programming languages](https://user-images.githubusercontent.com/45010379/48764583-58063080-ecb0-11e8-9aad-4663aa32da5d.PNG)
",2018-11-20T09:38:04+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",tceron,"In round brackets the rules are:
- _and_ is the first operation, the result is the first value of the operation _or_

No brackets:
First - _not_ operation
Second - _and_ operation
Third - remaining _or_ operations

Therefore, the boolean value of `not (not True or False and True) or False` is:
`not (not True or False) or False`
`not (False) or False`
`True or False`
True ",2018-11-20T10:15:06+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",saraarmaroli,"not (not true or false and true) or false
not (**false** or false and true ) or false
not (flase or **false**) or false
not (**false**) or false
**true** or false
true
",2018-11-20T15:36:06+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",MattiaSpadoni,"not (not true or false and true) or false 

- I phase: (do the ""not"" inside brackets)
not (false or false and true) or false
- II phase: (do the And inside brackets)
 not (false or false) or flase
- III phase: (do the or inside brackets)
- not false or false
- IV phase: (do ""not"")
- true or false
- V (do final ""or""):
True",2018-11-20T16:13:57+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",friendlynihilist,"1. not (not True or False and True) or False
2. not (False or False and True) or False
3. not (False or False) or False
4. True or False
5. True

First of all we need to execute operations in round branches and, in particular, `not True`. Then we resolve the `and` operator. Then the `not False` and, finally, the `or` operator.
",2018-11-20T16:53:43+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",ilsamoano,"What is the boolean value of not (not True or False and True) or False?

not (not True or False and True) or False
not (False or False) or False
not False or False
True or False
True



















",2018-11-20T17:38:00+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",SeverinJB,"{not[(not true) or (false and true)]} or false
{not[false or (false and true)]} or false
{not[false or false]} or false
{not false} or false
true or false
true",2018-11-20T18:49:34+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",hizclick,TRUE,2018-11-20T19:08:28+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",Saraa04,"not (not True or False and True) or False
not (**_False_** or False and True) or False
not (**_False_** or False) or False
not (**_False_**) or False
**_True_** or False => **True**",2018-11-20T22:20:34+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",DavideApolloni,"not (not true or false and true) or false
not (false or false and true) or false
not (false or false) or false
not (false) or false
not false or false
true or false
true",2018-11-21T14:07:22+00:00
comp-think/2018-2019,"Lecture ""Programming languages"", exercise 1",essepuntato,"Hi all,

Thanks for all the answers! Some comments: it is important, in these cases, to clarify in which order the passages have been executed, in particular for the part `not True or False and True`. In this case the paggages should be (between ""**"" the operation that is considered every time):

```
**not** True or False and True -->
False or False **and** True -->
False **or** False -->
False
```

While using another way for executing the operation can result in the same final outputs, it is important to use the right order. For instance, the following approach (exchanging the way the boolean operators are commonly considered) is **wrong** even if the final result is correct:

```
not True **or** False and True -->
not True **and** True -->
**not** True -->
False
```",2018-11-26T11:40:57+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 2",ilsamoano,"2 questions about the above:

A] the algorithm should be able to solve all the possible 0-1 sequences?
i.e. 11100 00111 10101 01110 etc?
or we must pick one of the above only?

B] do we have to have the algorithm write the result in the starting cell?
if I input 5 symbols in http://turingmachine.io/ , the starting position is the first one of the five symbols: so I'll have 4 inputs following the starting position, while in the exercise description seems that the inputs are 6 in total: starting position + 5 five cells following

If we can pick only one sequence at time as an input and we must write the output on the left side of the first input (6 inputs)
input: ""11100""
blank: ' '
start state: A
table:
A:
1: {R: B}
0: {R: B}
B:
1: {R: C}
0: {R: C}
C:
1: {L: D}
0: {R: A}
D:
1: {L: E}
E:
1: {L: F}
F:
' ': {write: 1, R: done}

done:

If we can pick only one sequence at time as an input and we must write the output on the first input (5 inputs)
`input: ""11100""
blank: ' '
start state: A
table:
A:
1: {R: B}
0: {R: B}
B:
1: {R: C}
0: {R: C}
C:
1: {L: D}
0: {R: A}
D:
1: {L: E}
E:
1: {write: 1,L: end}

end:`

p.s. I spent a considerable amount of time trying to set an algorithm for multiple 1-0 sequences of five inputs, at max I was able to cover a couple of possibilities.. if this is the request and someone wants to share with me how to do it, it would be really appreciated :)",2018-11-17T00:57:07+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 2",federicabologna,"Hi everyone!

I was asking myself the same thing you mentioned in A]. I would be very interested in knowing how to build and implement such an algorithm. @essepuntato could you please explain it class or at another more convenient time?
In case we had to pick only one possibility, here's what I did:

input: '11000'
blank: ' '  
start state: A
table:
  A: 
   1: {R: B}
  B:
   1: {R: C}
  C:
   0: {write: 1, L: C}
   1: {L: D}
  D:
   0: {write: 0, L: E}
   1: {write: 0, L: E}
  E:
end state: E

Hope that's ok!
See you in class :)",2018-11-17T13:49:26+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 2",giuliapl,"```
blank: '0'
start state: First
table:

FIRST:
     1: {write: 1, R, UA’_FIRST}
     0: {write: 1, R, SECOND}
UA’_FIRST
     1: {write: 1, R, UA’’_FIRST}
     0: {write: 1, R, UA’_THIRD}
UA’_THIRD
     1: {write: 1, R, UA’’_THIRD}
     0: {write: 1, R, END}
UA’’_THIRD
     1: {write: 1, R, UA’’’}
     0: {write: 1, R, END}
UA’’’
     1: {write: 1, L, ACCEPT}
     0: {write: 1, L, END}
ACCEPT
     1: {write: 1, L, ACCEPT}
     0: {write: 1m L, END}
SECOND
     1: { write: 1, R, UA’_SECOND}
     0: {write: 1, R, UA’_THIRD}
UA’_SECOND
     1: {write: 1, R, UA’’_SECOND}
     0: {write: 1, R, END}
UA’’_SECOND
     1: {write: 1, R, UA’’’}
     0: {write: 1, R, END}
UA’’_FIRST
     1: {write: 1, R, UA’’’}
     0: {write: 1, R, END}
```",2018-11-17T15:02:26+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 2",mangiafrangette,"I came up with two different solutions (they work with any given input): the first makes the assumption of having a blank cell at the starting position pointed by the head (using an extra blank symbol at the start of the input), the second one only uses 0 and 1 and shifts the cells to the right before running the algorithm.
First solution:
```
input: ' 00111'
blank: ' '
start state: start
table:
  start:
    [0,1,' ']: {R: count0}
  count0:
    1: {R: count1}
    0: {R: count0}
    ' ': {L: fail}
  count1:
    1: {R: count2}
    0: {R: count0}
    ' ': {L: fail}
  count2:
    1: {L: success}
    0: {R: count0}
    ' ': {L: fail}
  success:
    ' ': {write: 1, L: return}
    [0,1]: {L: success}
  fail:
    ' ': {write: 0, L: return}
    [0,1]: {L: fail}
  return:
```

Second solution:
```
input: '00111'
blank: ' '
start state: start
table:
  start:
    0: {write: ' ', R: copy0}
    1: {write: ' ', R: copy1}
  copy0:
    0: {write: 0, R: copy0}
    1: {write: 0, R: copy1}
    ' ': {write: 0, L: count0}
  copy1:
    0: {write: 1, R: copy0}
    1: {write: 1, R: copy1}
    ' ': {write: 1, L: count1}
  count0:
    0: {write: 0, L: count0}
    1: {write: 1, L: count1}
    ' ': {write: '0', L: return}
  count1:
    0: {write: 0, L: count0}
    1: {write: 1, L: count2}
    ' ': {write: '0', L: return}
  count2:
    0: {write: 0, L: count0}
    1: {write: 1, L: success}
    ' ': {write: '1', L: return}
  success:
    [0,1]: {L: success}
    ' ': {write: 1, L: return}
  return:

```",2018-11-17T17:42:37+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 2",MattiaSpadoni,"2 different ways:
The first one is developed on my own, after a discussion with @mangiafrangette  I understand that my code is too long and too complicated.
So I've tried to simplify it in the second way. Thanks to Francesca for her advices


input: ' 10111'
blank: ' '
start state: a
table:
  a:
    ' ': {R: a1}
  a1:
    1: {R: b2}
    0: {R: b1}
  b1:
    1: {R: c3}
    0: {R: c1}
  c1:
    1: {R: d2}
    0: {R: x}
  b2:
    0: {R: c1}
    1: {R: c2}
  c2:
    0: {L: x}
    1: {L: y}
  c3:
    0: {L: x}
    1: {R: d3}
  d3:
    0: {L: x}
    1: {L: y}
  d2:
    0: {L: x}
    1: {R: e2}
  e2:
    0: {R: x}
    1: {L: y}
  x:
    [0,1]: {L: x}
    ' ': {write: 0, L: end}
  y:
    [0,1]: {L: y}
    ' ': {write: 1, L: end}
  end:

Way 2

input: ' 01101'
blank: ' '
start state: A
table:
  A:
    [0,1,' ']: {R: b}
  b:
    1: {R: c}
    0: {R: b}
    ' ': {L: x}
  c:
    1: {R: d}
    0: {R: b}
  d:
    1: {L: y}
    0: {R: b}
  y:
    ' ': {write: 1, L: return}
    [0,1]: {L: y}
  x:
    ' ': {write: 0, L: return}
    [0,1]: {L: x}
  return:",2018-11-17T18:54:38+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 2",friendlynihilist,"This solution is based on the approach that if the first (or the second) value '1' is followed by the value '0' in the next cell, then it couldn't be possible to have three 1's in a row (in a five digits context). That's the reason why it doesn't need to always scan to the rightmost cell to return 0.

The output of the first is '0':
```
input: ' 01101'
blank: ' '
start state: start
table:
  start:
    1: {R: scan}
    0: {R: scan}
    ' ': {R: scan}
  scan:
    0: R
    1: {R: value1}
  value1:
    0: {R: retneg}
    1: {R: value2}
  value2:
    0: {R: retneg}
    1: {L: retpos}
  retpos:
    0: L
    1: L
    ' ': {write: 1, L: done}
  retneg:
    0: L
    1: L
    ' ': {write: 0, L: done}
  done:
```
While the output of the second is '1':
```
input: ' 00111'
blank: ' '
start state: start
table:
  start:
    1: {R: scan}
    0: {R: scan}
    ' ': {R: scan}
  scan:
    0: R
    1: {R: value1}
  value1:
    0: {R: retneg}
    1: {R: value2}
  value2:
    0: {R: retneg}
    1: {L: retpos}
  retpos:
    0: L
    1: L
    ' ': {write: 1, L: done}
  retneg:
    0: L
    1: L
    ' ': {write: 0, L: done}
  done:
```",2018-11-18T14:46:14+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 2",delfimpandiani,"I struggled with this one and decided to check out my classmates' answers;

> I came up with two different solutions (they work with any given input): the first makes the assumption of having a blank cell at the starting position pointed by the head (using an extra blank symbol at the start of the input), the second one only uses 0 and 1 and shifts the cells to the right before running the algorithm.
> First solution:
> 
> ```
> input: ' 00111'
> blank: ' '
> start state: start
> table:
>   start:
>     [0,1,' ']: {R: count0}
>   count0:
>     1: {R: count1}
>     0: {R: count0}
>     ' ': {L: fail}
>   count1:
>     1: {R: count2}
>     0: {R: count0}
>     ' ': {L: fail}
>   count2:
>     1: {L: success}
>     0: {R: count0}
>     ' ': {L: fail}
>   success:
>     ' ': {write: 1, L: return}
>     [0,1]: {L: success}
>   fail:
>     ' ': {write: 0, L: return}
>     [0,1]: {L: fail}
>   return:
> ```
> Second solution:
> 
> ```
> input: '00111'
> blank: ' '
> start state: start
> table:
>   start:
>     0: {write: ' ', R: copy0}
>     1: {write: ' ', R: copy1}
>   copy0:
>     0: {write: 0, R: copy0}
>     1: {write: 0, R: copy1}
>     ' ': {write: 0, L: count0}
>   copy1:
>     0: {write: 1, R: copy0}
>     1: {write: 1, R: copy1}
>     ' ': {write: 1, L: count1}
>   count0:
>     0: {write: 0, L: count0}
>     1: {write: 1, L: count1}
>     ' ': {write: '0', L: return}
>   count1:
>     0: {write: 0, L: count0}
>     1: {write: 1, L: count2}
>     ' ': {write: '0', L: return}
>   count2:
>     0: {write: 0, L: count0}
>     1: {write: 1, L: success}
>     ' ': {write: '1', L: return}
>   success:
>     [0,1]: {L: success}
>     ' ': {write: 1, L: return}
>   return:
> ```

@mangiafrangette this is genius! Both of them. The idea of the count states really makes things so much easier. I especially find the second solution ingenious, with the separate copy and count states, and the count state being ""backwards"" (from L to R). It took me a while (trying different inputs) to fully understand its workings, but now I do and love it!",2018-11-18T23:39:48+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 2",SeverinJB,"**Note:** 
I read the lecture notes after doing the exercise. Hence, the following solution was created without the webpage http://turingmachine.io. Also, the following solution does not use blank fields as input. As the examples in class, the solution is based on 0s and 1s as possible inputs. The solution works for every input: 00000 – 11111

Initial state: A
Successful ending: E
Unsuccessful ending: F

Issue: Machine does not stop, but continues writing the result in an endless loop. 
A possible solution to issue: Introducing as many states as necessary to return ""home"".

<table>
    <tbody>
        <tr>
            <td align=""center"" rowspan=2>Tape symbol</td>
            <th colspan=3>Current state (A)</th>
            <th colspan=3>Current state (B)</th>
            <th colspan=3>Current state (C)</th>
        </tr>
        <tr>
            <td align=""center"">Write symbol</td>
            <td align=""center"">Move tape</td>
            <td align=""center"">Next state</td>
            <td align=""center"">Write symbol</td>
            <td align=""center"">Move tape</td>
            <td align=""center"">Next state</td>
            <td align=""center"">Write symbol</td>
            <td align=""center"">Move tape</td>
            <td align=""center"">Next state</td>
        </tr>
        <tr>
            <td align=""right"">0</td>
            <td>0</td>
            <td>R</td>
            <td>B</td>
            <td>0</td>
            <td>R</td>
            <td>G</td>
            <td>0</td>
            <td>R</td>
            <td>I</td>
        </tr>
        <tr>
            <td align=""right"">1</td>
            <td>0</td>
            <td>R</td>
            <td>B</td>
            <td>0</td>
            <td>R</td>
            <td>C</td>
            <td>0</td>
            <td>R</td>
            <td>D</td>
        </tr>
        <tr>
            <td colspan=10></td>
        </tr>
        <tr>
            <td align=""center"">Tape symbol</td>
            <th colspan=3>Current state (D)</th>
            <th colspan=3>Current state (E)</th>
            <th colspan=3>Current state (F)</th>
        </tr>
        <tr>
            <td align=""right"">0</td>
            <td>0</td>
            <td>L</td>
            <td>F</td>
            <td>1</td>
            <td>L</td>
            <td>E</td>
            <td>0</td>
            <td>L</td>
            <td>F</td>
        </tr>
        <tr>
            <td align=""right"">1</td>
            <td>1</td>
            <td>L</td>
            <td>E</td>
            <td>1</td>
            <td>L</td>
            <td>E</td>
            <td>0</td>
            <td>L</td>
            <td>F</td>
        </tr>
        <tr>
            <td colspan=10></td>
        </tr>
        <tr>
            <td align=""center"">Tape symbol</td>
            <th colspan=3>Current state (G)</th>
            <th colspan=3>Current state (H)</th>
            <th colspan=3>Current state (I)</th>
        </tr>
        <tr>
            <td align=""right"">0</td>
            <td>0</td>
            <td>R</td>
            <td>I</td>
            <td>0</td>
            <td>L</td>
            <td>F</td>
            <td>0</td>
            <td>L</td>
            <td>F</td>
        </tr>
        <tr>
            <td align=""right"">1</td>
            <td>0</td>
            <td>R</td>
            <td>H</td>
            <td>0</td>
            <td>R</td>
            <td>D</td>
            <td>0</td>
            <td>R</td>
            <td>H</td>
        </tr>
    </tbody>
</table>

<img width=""937"" alt=""turing_machine_2"" src=""https://user-images.githubusercontent.com/32867365/48698097-8586a780-ebe6-11e8-965d-ab7259d13211.png"">",2018-11-19T08:28:25+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 2",HiImBono,"I tried to write a solution to all 5 digit combinations in the most abstract way. I do not use any ingenious techniques to minimize computation time but at least I feel like it would provide
the correct solution to all combinations. Also I assumed a total of 5 digits not 6. 

Note that I wrote the initial digit combination the machine has read so far after the percentage sign. In this way one can see what the machine has seen so far.
I make every digit the machine has seen into a 1. Everytime the machine has seen three 1's in a row it is done (I dont know how the machine terminates i maybe thought jumping to an empty state 'DONE')
When the machine reaches a point where there is not more possibility to have three consecutive 1's the machine stwitches to on of the four END states depending on the current state.
The END states guide the machine to make its way back to the starting digit to turn it into a 0.

input: ..... (5 random digits either 1 or 0)
start state: A
table:
	A:
		0: { write: 1, R: B1}  	% 0
		1: { write: 1, R: B2}  	% 1
	B1:
		0: { write: 1, R: C1}  	% 00
		1: { write: 1, R: C2}  	% 01
	B2:
		0: { write: 1, R: C3}  	% 10
		1: { write: 1, R: C4}  	% 11
	C1:
		0: { L: END2}  		% 000
		1: { write: 1, R: D1} 	% 001
	C2:
		0: { L: END2}  		% 010
		1: { write: 1, R: D2}  	% 011
	C3:
		0: { L: END2} 		% 100
		1: { write: 1, R: D3}  	% 101
	C4:
		0: { L: END2}	  	% 110
		1: { L: DONE}  		% 111
	D1:
		0: { L: END3}  		% 0010
		1: { write: 1, R: E1} 	% 0011
	D2:
		0: { L: END3}  		% 0110
		1: { L: DONE}  		% 0111
	D3:
		0: { L: END3} 		% 1010
		1: { write: 1, R: E2}  	% 1011
	E1:
		0: { L: END4}  		% 00110
		1: { L: DONE}  		% 00111
	E2:
		0: { L: END4}  		% 10110
		1: { L: DONE}  		% 10111
        END4:	
		1: { L: END3}
	END3:	
		1: { L: END2}
	END2:	
		1: { L: END1}
	END1:	
		1: { write:0, L: DONE}
	DONE: 
		empty state",2018-11-19T15:00:24+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 2",lisasiurina,"input: '00111'
blank: ' '
start state: A
table:
  A:
 [0,1,' ']: {R: b}

B:
1: {R:C}
0: {R:B}

C: 
1: {R:D}
0: {R:B}

D: 
1: {L:y}
0: {R:B}

y:

 ' ‘ : {write: 1, L: return}
[0,1]: {L:y}

x: 
' ‘ : {write: O, L: return}
[0,1]: {L:x}
",2018-11-21T13:37:46+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 2",essepuntato,"Hi all,

As you already know, there are plenty of possible different solutions to this problem, and you guys have already provide different working approaches here – thanks a lot for this! 

I'm providing the solution to this exercise I've sketched during the previous lecture so as to be reused in the [Turing Machine Visualization tool](http://turingmachine.io/) for testing it. Remember that when one do not specify any ""write"" instruction implicitly means that the head will write on the tape exactly the same symbol that is already written there.

```
input: '011101'
blank: '0'
start state: start
table:
  start: 
    [0,1]: { R: a }
  a:
    1: { R: a1 }
    0: { R: a0 }
  a1:
    1: { R: a11 }
    0: { R: a10 }
  a0:
    1: { R: a10 }
    0: { R: a00 }
  a11:
    1: { L: success3 }
    0: { R: a110 }
  a10:
    1: { R: a110 }
    0: { R: a100 }
  a00:
    1: { R: a100 }
    0: { L: stop }
  a110:
    1: { L: success4 }
    0: { R: a1100 }
  a100:
    1: { R: a1100 }
    0: { L: stop }
  a1100:
    1: { L: success5 }
    0: { L: stop }
  
  success5:
    [0,1]: { L: success4 }
  success4:
    [0,1]: { L: success3 }
  success3:
    [0,1]: { L: success2 }
  success2:
    [0,1]: { L: success1 }
  success1:
    [0,1]: { write: 1, L: stop }
  
  stop:
```",2018-11-22T15:16:56+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 1",ilsamoano,"I've initially tried trying to stick to the process

```
blank: '0'
start state: A
table:
  A:
   0: { write: 0, L: B }
  B:
    0: { write: 1, R: C }
  C:
    0: { write: 0, R: D }
  D:
   0: { write: 1, L: A }
```

...and I miserably failed (""D"" needed a state instruction to print the 1 on the right side of the initial position), so I've tried to modify the context..and it worked, but I can't really say if this was the method intended to be used..I feel like I've cheated

```
input: '0100'
blank: ' '
start state: A
table:
  A:
    0:  {write: 0, L: B}  
  B:
    ' ': {write: 1, R: C}
  C:
     0:  {write: 0, R: D}
  D:

```

",2018-11-16T15:48:44+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 1",hizclick,"    blank:  '0'
    start state: A
    table:
             A: 
                  0: {write: 1, L: B}
                  1: {write: 0, R: C}
             B:
                  0: {write: 1, R: A}
             C:
                  0: {write: 1, R: D}
             D:

this worked for me ",2018-11-16T16:09:25+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 1",ilsamoano,that's nice! I didn't think about to use the new A state!,2018-11-16T17:15:32+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 1",giuliapl,"```
blank: '0'
start state: A
table:
  A: 
              0: {write: 1, L: B}
              1: {write: 0, R: C}
         B:
              0: {write: 1, R: A}
         C:
              0: {write: 1, R: D}
         D:
end state: D
```
",2018-11-17T11:08:50+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 1",MattiaSpadoni,"input: ''
blank: '0'
start state: A
table:
  A:
    0: {write: 1, R: B}
    1: {write: 1, R: D}
  B:
     0     : {write: 1, R: C}
  C: 
     0     : {write: 1, L: C}
     1     : {write: 0, L: A}
  D:  

2:
(it has shorter instructions)

input: ''
blank: '0'
start state: A
table:
  A:
    0       : {write: 1, R: B}
  B:
     0     : {write: 0, R: C}
  C:
     0     : {write: 1, L: D}
  D:",2018-11-17T15:05:19+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 1",lisasiurina,"blank:  '0'
start state: A
table:
         A: 
              0: {write: 1, L: B}
              1: {write: 0, R: C}
         B:
              0: {write: 1, R: A}
         C:
              0: {write: 1, R: D}
 end state: D",2018-11-17T16:09:41+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 1",LuciaGiagnolini12,"I'll try to express what I've thought with words, but I'm _definitely not sure_ if I've understood well the mechanism (if not, can someone please correct me?)

blank: '0'
start state: A
table:
        A: 
              0: {write: 1, L: B}  The tape is initialized with 0, so the machine reads ""0"", then writes ""1"" (and   turns left to state B)
              1: {write: 0, R: C} So, since the machine has previously wrote it, now in state A there's ""1"": the machine reads ""1"", then writes ""0"" (and turns right to state C) 
         B:
              0: {write: 1, R: A} In state B the machine reads ""0"", writes ""1"" and move right to A
         C:
              0: {write: 1, R: D} In state C the machine reads ""0"", writes ""1"" and move right to D
         D:
end state: D

",2018-11-17T16:48:48+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 1",EleonoraPeruch,"I have tried to solve the issue by creating a proper table as we saw in class; however I'm not sure about the sequence of instructions:

Current state | Tape symbol | Write symbol | Move tape | Next state
-- | -- | -- | -- | --
A | 0 or 1 | 0 | left | B
B | 0 or 1 | 1 | right | C
C | 0 or 1 | 1 | right | D
D | 0 or 1 | 0 |   |  

After today's lecture I provide the correction to the previous table. Here I reuse the state A. 

Current    state | Tape    symbol | Write    symbol | Move tape | Next state
-- | -- | -- | -- | --
A | 0 or 1 | 1 | left | B
B | 0 or 1 | 1 | right | A
A | 0 or 1 | 0 | right | C
C | 0 or 1 | 1 | right | D
D | 0 or 1 | 0 |   |  

",2018-11-17T17:13:56+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 1",SeverinJB,"Given a tape which initially has only zeros. 

Blank: ... 0000 ...

<table>
    <tbody>
        <tr>
            <td align=""center"" rowspan=2>Tape symbol</td>
            <th colspan=3>Current state (A)</th>
            <th colspan=3>Current state (B)</th>
            <th colspan=3>Current state (C)</th>
        </tr>
        <tr>
            <td align=""center"">Write symbol</td>
            <td align=""center"">Move tape</td>
            <td align=""center"">Next state</td>
            <td align=""center"">Write symbol</td>
            <td align=""center"">Move tape</td>
            <td align=""center"">Next state</td>
            <td align=""center"">Write symbol</td>
            <td align=""center"">Move tape</td>
            <td align=""center"">Next state</td>
        </tr>
        <tr>
            <td align=""right"">0</td>
            <td>1</td>
            <td>L</td>
            <td>B</td>
            <td>1</td>
            <td>R</td>
            <td>A</td>
            <td>1</td>
            <td>L</td>
            <td>D</td>
        </tr>
        <tr>
            <td align=""right"">1</td>
            <td>0</td>
            <td>R</td>
            <td>C</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
    </tbody>
</table>",2018-11-17T19:19:34+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 1",friendlynihilist,"They both work, I've just changed the directions.
```
blank:  '0'
start state: A
table:
         A: 
              0: {write: 1, R: B}
              1: {write: 0, L: C}
         B:
              0: {write: 1, L: A}
         C:
              0: {write: 1, L: D}
         D:
```

```
blank:  '0'
start state: A
table:
         A: 
              0: {write: 1, L: B}
              1: {write: 0, R: C}
         B:
              0: {write: 1, R: A}
         C:
              0: {write: 1, R: D}
         D:
```",2018-11-17T23:05:34+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 1",delfimpandiani,"My original approach (before giving a look to you guys') gives the right result but has the defect of running forever:

| Current State| Type Symbol | Write Symbol | Move Type     | Next State | 
| ------------- | ------------- | ------------- | ------------- | ------------- |
| A  | 0 or 1 | 0  | L |B  |
| B  | 0 or 1  | 1 | R |C  |
| C  | 0 or 1  | 0  | R |D  |
| D  | 0 or 1  | 1  | L | A  |

```
blank:  '0'
start state: A
table:
         A: 
              0: {write: 0, L: B}
              1: {write: 0, L: B}
         B:
              0: {write: 1, R: C}
              1: {write: 1, R: C}
         C:
              0: {write: 0, R: D}
              1: {write: 0, R: D}
         D:
              0: {write: 1, L: A}
              1: {write: 1, L: A}
```

I looked at you guys' approaches and it all made sense to me when I realized I could have the initial box be 1 and then change it back to 0. Smart!

",2018-11-18T22:46:03+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 1",ilsamoano,"```
blank: ' '
start state: A
table:
  A:
    ' ': {write: 0, R: B}
    0: {L: C}
  B:
    ' ': {write: 1, L: A}
  C:
    ' ': {write: 1, L: D}
  D:
```",2018-11-19T17:44:55+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 1",tceron,"blank:  '0'
start state: A
table:
         A: 
              Read 0: {write: 1, Left: B}
              or
              Read 1: {write: 0, Right: C}
         B:
              Read 0: {write: 1, Right: A}
         C:
              Read 0: {write: 1, R: D}
         D:
End state.",2018-11-21T09:19:31+00:00
comp-think/2018-2019,"Lecture ""Computability"", exercise 1",essepuntato,"Hi all,

I'm providing the solution to this exercise so as to be reused in the [Turing Machine Visualization tool](http://turingmachine.io/) for testing it:

```
blank: '0'
start state: A
table:
  A:
    0: { write: 1, R: B }
    1: { write: 0, L: C }
  B:
    0: { write: 1, L: A }
  C:
    0: { write: 1, L: D }
  D:
```",2018-11-22T15:10:39+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 3",MattiaSpadoni,"I try, but I'm not so sure about something.
Ah, above the line there is the first algorith, under the line the second.

P.S. I've forgotten some ""no"" along the flowchart

![diagram ex 3](https://user-images.githubusercontent.com/44199892/48495430-38928200-e830-11e8-9405-5d6f2e77703d.jpg)
",2018-11-14T16:11:07+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 3",mangiafrangette,"![algorithms3a](https://user-images.githubusercontent.com/44606486/48505428-56b7ac80-e847-11e8-91c2-e3b466034696.png)

![algorithms3b](https://user-images.githubusercontent.com/44606486/48505907-74394600-e848-11e8-8d9b-6a0516fc4194.png)


I'm not sure about the graphical representation of recursion in the second flowchart!

EDIT: added the ending terminals",2018-11-14T17:10:45+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 3",friendlynihilist,"I'll come back later to add other solutions that I was thinking of.
![fibonacci1 2](https://user-images.githubusercontent.com/41264663/48500799-025aff80-e83c-11e8-8d36-37fe2637856a.png)

",2018-11-14T17:31:41+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 3",friendlynihilist,"


> ![algorithms3a](https://user-images.githubusercontent.com/44606486/48499270-5c59c600-e838-11e8-8301-e962e4bbe8b6.png)
> ![algorithms3b](https://user-images.githubusercontent.com/44606486/48499278-611e7a00-e838-11e8-970c-58d744df6ed7.png)
> I'm not sure about the graphical representation of recursion in the second flowchart!

I think you need to add two ending terminals! Love you anyway. 💃",2018-11-14T17:41:18+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 3",simayguzel,"
![untitled diagram](https://user-images.githubusercontent.com/44606954/48515864-4103b080-e862-11e8-9a31-aa230ed07f7a.png)


",2018-11-14T22:08:56+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 3",lisasiurina,"![untitled diagram 1](https://user-images.githubusercontent.com/44965813/48517203-de141880-e865-11e8-938f-b6e68612c649.jpg)
",2018-11-14T22:34:49+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 3",MilenaCorbellini,"





![untitled diagram](https://user-images.githubusercontent.com/45001201/48548093-675e3600-e8cc-11e8-9218-0a05f063e1e7.png)
![diagram 2](https://user-images.githubusercontent.com/45001201/48548117-793fd900-e8cc-11e8-9852-5700b1cd9f81.png)


",2018-11-15T10:49:17+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 3",EleonoraPeruch,"
![algorithms-exercise 3a](https://user-images.githubusercontent.com/45010379/48567642-d7d17b00-e8fd-11e8-87af-d353129d9551.PNG)

![algorithms-exercise 3b](https://user-images.githubusercontent.com/45010379/48567652-e3bd3d00-e8fd-11e8-966a-615178519b8a.PNG)





",2018-11-15T16:43:11+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 3",delfimpandiani,"Curious to hear what you guys think of this first way, making the algorithm save f(0) and f(1) to later retrieve them:
<img width=""840"" alt=""fibonacci 2"" src=""https://user-images.githubusercontent.com/44606644/48568290-5549bb00-e8ff-11e8-8f9c-0ff2a6d127b6.png"">

and then a, b, c way similar to others'
<img width=""744"" alt=""fibonacci 1"" src=""https://user-images.githubusercontent.com/44606644/48568303-5b3f9c00-e8ff-11e8-8303-37302a9ff8f7.png"">
",2018-11-15T16:54:51+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 3",Ioanna96,"
![untitled diagram 2](https://user-images.githubusercontent.com/44606701/48573699-58e43e80-e90d-11e8-9521-20280368cf1a.jpg)
![untitled diagram 1](https://user-images.githubusercontent.com/44606701/48573703-5a156b80-e90d-11e8-8238-4c6a7ecc1acb.jpg)
",2018-11-15T18:36:28+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 3",andreamust,"![untitled diagram 2](https://user-images.githubusercontent.com/44606182/48579866-f0ea2400-e91d-11e8-9749-071282036f45.jpg)
",2018-11-15T20:33:14+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 3",SeverinJB,"![algorithms_exercise_3a](https://user-images.githubusercontent.com/32867365/48582025-b1bed180-e923-11e8-9d66-3b35d344bfff.jpg)

It is necessary to define f before addressing the function. Here: Fib(int n)
![algorithms_exercise_3b 1](https://user-images.githubusercontent.com/32867365/48583623-dd43bb00-e927-11e8-818f-5016029817ac.jpg)


_Sidenote:_ 
The second paragraph was difficult to understand because it is not clear what ""the same function"" means.",2018-11-15T21:15:53+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 3",ilsamoano,"![3 issue flowchart 1](https://user-images.githubusercontent.com/44072915/48616225-3f85d580-e993-11e8-983f-419fe55f4ba8.png)
![3 issue flowchart 2](https://user-images.githubusercontent.com/44072915/48616232-43b1f300-e993-11e8-8ff8-44281479a2d6.png)
",2018-11-16T10:32:24+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 3",tceron,"![function f1](https://user-images.githubusercontent.com/44325359/48663883-d7b8b300-ea96-11e8-8f7a-4acc9d56c1db.png)


Applying recursion:
![function f2](https://user-images.githubusercontent.com/44325359/48663887-de472a80-ea96-11e8-9ee4-2b4acbea9b7a.png)
",2018-11-17T17:31:02+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 3",essepuntato,"Hi all,

thanks for all the proposed solutions, that look correct to a first sight. Indeed, representing the recursive step with a flowchart could be tricky, but I really liked the simplicity of the approach that have been proposed in your diagrams.",2018-11-19T06:59:37+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 2",delfimpandiani,"![exercise 2 delfina](https://user-images.githubusercontent.com/44606644/48475841-ff411e80-e7fd-11e8-97e4-f0c049962371.PNG)
",2018-11-14T10:28:54+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 2",dersuchendee,"
![diagram](https://user-images.githubusercontent.com/25482210/48487606-04fb2c00-e81f-11e8-9df3-b692112fa720.jpg)
 I also thought- not sure about that, though-: if the two objects are numbers:



![diagramuu](https://user-images.githubusercontent.com/25482210/48488169-696abb00-e820-11e8-8629-0cad233719d8.jpg)
",2018-11-14T14:18:16+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 2",MattiaSpadoni,"![msdiagram](https://user-images.githubusercontent.com/44199892/48490471-d3399380-e825-11e8-835f-60fd045ff7b7.jpg)
",2018-11-14T14:56:27+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 2",friendlynihilist,"![untitled diagram](https://user-images.githubusercontent.com/41264663/48514596-f3d20f80-e85e-11e8-91b3-2a6f94765eaa.png)
",2018-11-14T15:18:05+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 2",mangiafrangette,"![untitled diagram 1](https://user-images.githubusercontent.com/44606486/48494724-c3727d00-e82e-11e8-9e09-acf9c2399957.png)
",2018-11-14T16:00:33+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 2",Ioanna96,"
![same](https://user-images.githubusercontent.com/44606701/48503889-b90eae00-e843-11e8-9ce4-16a90a7f8fd2.jpg)
",2018-11-14T18:30:44+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 2",lisasiurina,"
![untitled diagram](https://user-images.githubusercontent.com/44965813/48509239-d1d19080-e850-11e8-9fb2-3e52915f5a67.jpg)
",2018-11-14T20:04:08+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 2",VittoriaMoccia,"![ex2 diagram](https://user-images.githubusercontent.com/44604343/48546651-244e9380-e8c9-11e8-83c1-1d03071000d4.jpg)
",2018-11-15T10:25:32+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 2",tceron,"
![diagram](https://user-images.githubusercontent.com/44325359/48553077-d2166e00-e8da-11e8-89ea-a7443e705e8b.png)
",2018-11-15T12:32:08+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 2",Totaro1996,"![untitled diagram](https://user-images.githubusercontent.com/44606764/48563412-96889d80-e8f4-11e8-9f16-80a8d0885787.jpg)
",2018-11-15T15:36:37+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 2",beccadelbens,"![algoritmo](https://user-images.githubusercontent.com/44618424/48576691-77e6ce80-e915-11e8-8667-bb562244c78b.PNG)
",2018-11-15T19:31:53+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 2",andreamust,"![untitled diagram](https://user-images.githubusercontent.com/44606182/48577048-6ce06e00-e916-11e8-8f20-1f90c55b15fe.jpg)
",2018-11-15T19:39:19+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 2",SeverinJB,"![algorithms_exercise_2](https://user-images.githubusercontent.com/32867365/48581876-5ab8fc80-e923-11e8-96a6-ac8a47ef7f2d.jpg)
",2018-11-15T21:11:15+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 2",ilsamoano,"![2 issue flowchart](https://user-images.githubusercontent.com/44072915/48613450-05650580-e98c-11e8-9576-9019f808fe2f.png)
",2018-11-16T09:41:43+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 2",essepuntato,"Hi all,

Thanks for your answers. Please remember that, even if the flowcharts are an informal way to describe an algorithm, if the computational problem in input says that one should return ""yes"" or ""no"", then that is what it is expected. In particular, returning numbers, for instance, is not the right way of implementing the algorithm – even if it is pretty clear to me what the numbers actually stand for.

Another issue that I saw is that some of you have used explicitly names of different objects in body of the algorithm (e.g. marker vs. pen). This should be avoided in the definition of the algorithm, since it seems that the only possibility that such algorithm has is to take in input a marker and a pen, while it is supposed to work with any input object – e.g. what if I want to run it using two pens, or an apple and an orange?

Finally, if you initialise something (e.g. ""initialise result = 0""), then one should use it somehow (e.g. by returning the result value). See the example in the lecture notes for clarification on this passage.",2018-11-19T06:56:40+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 1",delfimpandiani,"The result is 2

```
A=""HTML""
B=""Peroni""
C=""Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132""

score = 0

if A in C:
    score += 1
elif B in C:
    score += 1
else:
   score = 0

print(score)


```
First test, is A in C? A is in C ---> score is increased by 1 --> 0 + 1 = 1
Second test,  is B in C? B is in C ---> score is increased by 1 --> 1 + 1 = 2
Print(score) --> score is 2",2018-11-14T10:29:18+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 1",MattiaSpadoni,"The output will be ""2"" because both ""HTML"" and ""Peroni"" are in the bibliographic entry.",2018-11-14T14:12:13+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 1",friendlynihilist,"The output is 2, given the fact that both _HTML_ and _Peroni_ are included in the bibliographic entry.",2018-11-14T15:27:44+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 1",mangiafrangette,"Following the flowchart in Fig. 4 I wrote a Python algorithm to find the result: 

```
word1 = ""Peroni""
word2 = ""HTML""
bibentry = ""Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A.G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132"" 

result = 0

if word1 in bibentry:
    result = result + 1
	
if word2 in bibentry:
    result = result + 1

print (result)
```
The output is 2!",2018-11-14T15:40:21+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 1",lisasiurina,"The result (return) =2 since both the words ""HTML"" and ""Peroni"" are contained in the bibliographic entry.",2018-11-14T19:36:36+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 1",simayguzel,"string1 = ""Peroni""
string2 = ""HTML""

bibentry = ""Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132""


if string1 or string2 in bibentry:
    sum = 1

if string1 and string2 in bibentry:
     sum = 2
else: 
    sum = 0

print (sum)

output: 2
",2018-11-14T20:27:40+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 1",VittoriaMoccia,"The output would be 2 because both strings/words, ""Peroni"" and ""HTML"", are included in the bibliographic entry, if you consider them both together. If instead you consider just one of them at time, the output would be 1. ",2018-11-15T10:14:50+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 1",giuliapl,"Both the words ""Peroni"" and ""HTML"" are contained in the bibliographic entry, so the output is 2.",2018-11-15T10:27:07+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 1",tceron,"Bibliographic entry: 
""Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132""

Both ""HTML"" and ""Peroni"" appear in the bibliographic entry, therefore the result is 2. ",2018-11-15T12:02:31+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 1",ilsamoano,"```
A = ""Peroni""
B = ""HTML""
Def = ""Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132""

if A or B in Def:
    sum = 1
if A and B in Def:
    sum = 2
 
else:
    sum = 0
    
print `(sum)`
```

output = 2



",2018-11-15T18:06:06+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 1",SeverinJB,"“Peroni” and “HTML” are both parts of the input value. Hence, the result is 2. 

Followed Path:  … —> Initialise the result value to 0 —> The first word (“Peroni”)  is in the bibliography entry —> Sum 1 to the result value —> The second word (“HTML”) is in the bibliography entry —> Sum 1 to the result value —> Return the result value (“2”) —> … ",2018-11-15T21:10:24+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 1",essepuntato,"@delfimpandiani, while the answer to the exercise is correct, the pseudocode describe a different flow, in particular in the instruction: 

> elif B in C:

This instruction will be executed if and only if the condition in the previous `if` is not satisfied. Thus, following your code, the actual result that will be returned in this case should be 1.

Similarly, @simayguzel and @ilsamoano, the two `if` in your pseudocode make the whole process erroneus, even if you returned the corrent answer to the question. In fact, if you run your pseodocode with a different input, e.g. by substituting the first word ""Peroni"" with ""Pippo"", you will see that the algorithm will return 0 even if you expected to get a 1.",2018-11-19T06:46:55+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 1",ilsamoano,"Hi Prof,
thanks for the heads up.
I’ve tried to sub “Peroni” with “Pippo”,
but my code still gives 2 as a result, not 0 and neither 1.

```

A = ""Pippo""
B = ""HTML""
Def = ""Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132""

if A or B in Def:
    sum = 1
if A and B in Def:
    sum = 2

else:
    sum = 0

print (sum)


2

```

If I change both the values of A and B the result is 0 despite “Computer” is a word in Def

```

A= ""Computer""
B = ""ojojo""
Def = ""Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132""

if A or B in Def:
    sum = 1
if A and B in Def:
    sum = 2

else:
    sum = 0

print (sum)


0
```",2018-11-19T17:23:40+00:00
comp-think/2018-2019,"Lecture ""Algorithms"", exercise 1",essepuntato,"@ilsamoano and @simayguzel 

Sorry guys, you are totally right. I really don't know how I've read ""elif"" instead of ""if"". 

Apologies.
",2018-11-19T19:30:16+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 3",MattiaSpadoni,"Situation 1: you are searching a book in a library
Situation 2: a warehouse employee is searching an item in the shelves

They have the need of searching something that has a precise location.",2018-11-12T16:28:27+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 3",ilsamoano,"1)  play rugby
2)  play soccer

common features:
- score
- bring the ball over a certain limit (border)
- avoid enemies from taking the ball
- stay within certain borders
- respect a set of rules
- have fun
- try to win the match",2018-11-12T17:46:37+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 3",simayguzel,"Situation 1: Assembling some furniture's parts
Situation 2: Implementing an algorithm 

Common features:
- there are some steps to be followed,
- the steps should be followed respectively.",2018-11-12T20:39:22+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 3",dersuchendee,"1. Painting portraying something you see in real life

2. Taking pictures

Common features:

- You choose what to include and what not to in your creations;

- You need to use some specific, concrete means to reach the goal of representation;

- In both cases, you can choose to make your subject different from how it really is, even if you are using it as a reference.",2018-11-13T11:14:13+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 3",MilenaCorbellini,"1. Translating an anciet document

2. Composing a piece of music
 
Common features:

- you need to define and identify the language you are translating or using;

- you need to deconstruct the text you are analysing or creating in their minimal parts;

- you need to create a mental scheme of your working;

- you need to use some intruments to work;

- in both cases you can use your personal interpretations.",2018-11-13T12:13:07+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 3",delfimpandiani,"1. Creating a specific color hue of acrylic paint
2. Making bechamel 

Common features:

- Different ingredients have to be mixed in together
- There is a specific result desired, in terms of color and consistency
- For the result to be achieved, each ingredient has to be added in specific amounts
- Constant stirring is necessary, and at a specific speed
- sense of touch, vision, and smell are engaged",2018-11-13T12:24:43+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 3",LuciaGiagnolini12,"1.  A bee building a beehive
2. A construction worker who builds a house

Common features:
They are both working ""manually"" to build a structure with a precise architecture/shape aimed to satisfy specific needs. ",2018-11-13T16:18:15+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 3",lisasiurina,"1. Using proper allusions in the texts
2. Buying goods to match interior design 

Common features: a possible algorithm to follow
1. Identify the main theme
2. Use source of data: (Dictionary of allusions, home interior design ideas)
3. Compare possible options, choosing the most suitable one
",2018-11-13T16:27:43+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 3",EleonoraPeruch,"1. Do the laundry
2. Clean up the dishes

•	In both cases you can choose between washing by hand or using a machine;
•	In both cases, if you use the machine you have to set it and to press the start bottom, then wait and 
        take off the clothes/dishes;
•	In both cases, if you wash by hand you have to wash and then put the clothes/dishes into a place 
        where they can dry, finally, you will wait for them to dry. 
",2018-11-13T16:33:17+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 3",SeverinJB,"1. Identifier: Keywords and Attributes
Even though often by itself insufficient, people try to describe a matter in as few words as possible. For example, for books librarians use keywords and for social interactions we assign attributes. Even though rating a book by a few keywords is insufficient, the tags are giving a hint whether or not the book contains a compelling story, a theoretical explanation, or something else. Equally, knowing a few attributes of another person allows people to get to know each other quicker, but a character cannot be judged solely on this knowledge. Keywords and attributes are both used as the identifier for a complex sum. 

2. Gratefulness: Meditation and Religion  
For example, worshipping food is essential in many religions and is also part of meditation. Instead of eating as fast as possible without being present in the situation, believers and those who practice meditation, equally try to be grateful for the meal and to embrace the moment. In a religious context, people speak a prayer and thank god for the meal. In meditation, you should pause for a moment and might thank the earth for providing the meal. The act of showing gratefulness might be carried out with different words and actions, but the sequence is quite similar.",2018-11-13T16:50:00+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 3",Ioanna96,"1. Getting under the blankets to stay warm
2. Creating a fort under the covers of the sofa as a kid to come up with a strategy along with my sister against our imaginary enemies (a game my mom didn't appreciate for some reason)
Common feature: Covers/Blankets connote safety and comfort, function as a shelter

",2018-11-13T18:06:31+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 3",tceron,"1. Creating a playlist on Spotify.
2. Writing a list for the groceries.

Common features:
- Listing items in order to highlight, order or make them handy. ",2018-11-13T20:59:12+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 3",essepuntato,"Hi guys,

Thanks a lot for all these new suggestions! I'll try to integrate them in next years lecture notes as additional material!

Great work!

S.",2018-11-16T07:07:49+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 2",MattiaSpadoni,"Input= 7
Output= (?)

n=7   a=1 b=1 c=2;
n--
n= 6 a=1 b=2 c=3;
n--
n= 5 a=2 b=3 c=5;
n--
n= 4 a=3 b=5 c=8;
n--
n=3 (now I can return ""c"") a= 5 b=8 C= 13;

Output= 13",2018-11-12T16:12:04+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 2",ilsamoano,"The function for calculating the nt​ h Fibonacci number takes as input an integer “n”. 
If “n” is less than or equal to 0, then 0 is returned as result. 
Otherwise, if “n” is equal to 1, then 1 is returned. 
Otherwise, return the sum of the same function with “n-1” as input and still the same function with “n-2” as input.

```
def Fibo(n): 
    if n<0: 
        return 0 
    elif n==1: 
        return 1
    else: 
        return Fibo(n-1)+Fibo(n-2) 

print(Fibo(7)) 

```
output: 13  

(for code explanation: https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/)",2018-11-12T17:31:08+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 2",simayguzel,"def F(n):
    if (n == 0) :
        return 0
    if (n == 1 or n== 2) :
        return 1
    else:
        return F(n-1)+F(n-2)
    
    print (F(7))

Output: 13
",2018-11-12T19:36:21+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 2",mangiafrangette,"> The function for calculating the nt​ h Fibonacci number takes as input an integer “n”.
> If “n” is less than or equal to 0, then 0 is returned as result.
> Otherwise, if “n” is equal to 1, then 1 is returned.
> Otherwise, return the sum of the same function with “n-1” as input and still the same function with “n-2” as input.
> 
> ```
> def Fibo(n): 
>     if n<0: 
>         return 0 
>     elif n==1: 
>         return 1
>     else: 
>         return Fibo(n-1)+Fibo(n-2) 
> 
> print(Fibo(7)) 
> ```
> output: 13
> 
> (for code explanation: https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/)

Add an equal on line 2 (""if n is less than or equal to 0 [...]"").
`if n <= 0:`
 Also, maybe is not clear to everyone that is written in Python. 
Good job!
",2018-11-13T11:54:04+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 2",delfimpandiani,"The function for calculating the n-th Fibonacci number takes as input an integer “n”.
If “n” is less than or equal to 0, then 0 is returned as result.
Otherwise, if “n” is equal to 1, then 1 is returned.
Otherwise, return the sum of the same function with “n-1” as input and still the same function with “n-2” as input.

def F(n):
if (n <= 0) :
return 0
if (n == 1 or n== 2) :
return 1
else:
return F(n-1)+F(n-2)

F(7) = 13
The logic behind this result is the following:

F(7) = F(6) + F(5) = 8 + 5 = 13
F(6) = F(5) + F(4) = 5 + 3 = 8
F(5) = F(4) + F(3) = 3 + 2 = 5
F(4) = F(3) + F(2) = 2 + 1 = 3
F(3) = F(2) + F(1) = 1 + 1 = 2
F(2) = F(1) + F(0) = 1 + 0 = 1
F(1) = 1
F(0) = 0",2018-11-13T12:19:06+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 2",tceron," a = 1;         
b = 1;         
while (1) {    c = a + b;         }    
if (n <= 3)
return c;             
a = b;            
b = c;
{    c = a + b;         }                 
n--;  (which means to subtract 1)

Input = 7

**n= 7**  a= 1 b= 1 c = 2 
n--  (subtract one)
n=6 (n <= 3 so return c)
**n= 6**  a= 1 b= 2 c = 3
n-- 
n= 5 
**n= 5**  a= 2 b= 3 c = 5
n--
n= 4 
**n= 4**  a= 3 b= 5 c = 8
n= 3  
**n= 3**  a= 5 b= 8 c = 13

{    c = a + b;         }  So the output is 13. 

",2018-11-13T12:40:06+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 2",lisasiurina,"Input= 7

If (n <=0)
then return 0
If (n <=2)
then return 1
If (n <=3)
then return c 

а=1 
b=1
c=a+b

a=b
b=c

If n=7 a=1 b=1 c=2;
 then n--
 If n n= 6 a=1 b=2 c=3; 
then n--
 If n= 5 a=2 b=3 c=5;
 then n--
If n= 4 a=3 b=5 c=8;
 then n--
 If n=3  a= 5 b=8 C= 13;
then return 13
Output 13",2018-11-13T12:46:46+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 2",friendlynihilist,"The function for calculating the n<sup>th</sup> Fibonacci number takes as input an integer “n”. If “n” is less than or equal to 0, then 0 is returned as result. Otherwise, if “n” is equal to 1, then 1 is returned.
Otherwise, return the sum of the same function with “n-1” as input and still the same function with “n-2” as input.


input=7
a=1
b=1
c=(a+b)

If n=7 a=1 b=1 c=2;
n-- (subtract 1)
If n=6 a=1 b=2 c=3;
n--
If n=5 a=2 b=3 c=5;
n--
If n=4 a=3 b=5 c=8;
n--
If n=3 a=5 b=8 c=13;
then return c
output=13",2018-11-13T16:19:30+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 2",SeverinJB,"A return statement in a while loop is equal to a break statement. Hence, as soon as n <= 3 the return function is trigged and the while loop stops. Based on this, the while loop stops as soon as n was reduced to 3 by n--. The loop runs a total of 5 times. During the last run, it returned c = 13. 

n = 7 —> a = 1, b = 1 —> c = a + b = 2 —>  a = b = 1, b = c = 2 —> n = 7 - 1 = 6 —> c = a + b = 3 —>  a = b = 2, b = c = 3 —> n = 6 - 1 = 5 —> c = a + b = 5 —>  a = b = 3, b = c = 5 —> n = 6 - 1 = 4 —> c = a + b = 8 —>  a = b = 5, b = c = 8 —> n = 6 - 1 = 3 —> c = a + b = 13 —> **c = 13**",2018-11-13T16:48:35+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 2",Ioanna96,"n=7 a=1 b=1 c=2
n--
n=6 a=1 b=2 c=3
n--
n=5 a=2 b=3 c=5
n--
n=4 a=3 b=5 c=8
n--
n=3 a=5 b=8 c=13
if “n” is less than or equal to “3” then return “c”
Output=13
",2018-11-13T17:16:19+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 2",dafnikitsiki,"> Input= 7
> Output= (?)
> 
> n=7 a=1 b=1 c=2;
> n--
> n= 6 a=1 b=2 c=3;
> n--
> n= 5 a=2 b=3 c=5;
> n--
> n= 4 a=3 b=5 c=8;
> n--
> n=3 (now I can return ""c"") a= 5 b=8 C= 13;
> 
> Output= 13

So, F(3) in Fibonacci's sequence is the key to find the output for any input number!",2018-11-15T20:41:23+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 1",MattiaSpadoni,"regular grammar
&lt;sentence&gt; ::= ""I"" <verb>
&lt;sentence&gt; ::= ""you"" <verb>
&lt;verb&gt; ::= ""write""
&lt;verb&gt; ::= ""read""
Possible sentences:
 I write (terminal ""I""+ non terminal &lt;verb&gt; in this case ""write"")
 I read (terminal ""I""+ non terminal &lt;verb&gt; in this case ""read"")
 you write (terminal ""You""+ non terminal &lt;verb&gt; in this case ""write"")
 you read (terminal ""you""+ non terminal &lt;verb&gt; in this case ""read"")
",2018-11-12T15:27:18+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 1",ilsamoano,"Regular grammar possible generic sentence:
`<non terminal>` ::= ""terminal"" 
`<non terminal>` ::= ""terminal"" `<non terminal>`

i.e.

`<sentence>` ::= ""I"" <verb>
`<sentence>` ::= ""you"" <verb>
`<verb>` ::= ""write""
`<verb>` ::= ""read""

possible example sentences

I write (""terminal"" = ""I"" and `<non terminal>` = `<verb>`('write'))
I read (""terminal"" = ""I"" and `<non terminal>` = `<verb>`('read'))
you write (""terminal"" = ""you"" and `<non terminal>` = `<verb>`('write'))
you read (""terminal"" = ""you"" and `<non terminal>` = `<verb>`('read'))",2018-11-12T15:33:28+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 1",VittoriaMoccia,"Regular grammar rules can be summarized in:
`<non-terminal>` ::= ""terminal"" 
`<non-terminal>` ::= ""terminal"" <non-terminal> 

For example, in order to create a sentence, this could be the combination:

`<sentence> `::= ""I""` <verb>`
`<verb>` ::= ""eat""
`<verb>` ::= ""sleep"" 

Possible combinations:
I eat (composed by the terminal ""I"" and the `<non-terminal>`/`<verb>` ""eat"")
I sleep (composed by the terminal ""I"" and the `<non-terminal>`/`<verb>` ""sleep"")",2018-11-13T11:57:06+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 1",delfimpandiani,"From regular grammar with production rules:

`<sentence>` ::= ""I"" `<verb>`
`<sentence>` ::= ""you"" `<verb>`
`<verb>` ::= ""write""
`<verb>` ::= ""read""

Possible sentences:

I write ( `<terminal>` = ""I""; `<non-terminal>=<verb>(""write""))`
I read( `<terminal>` = ""I""; `<non-terminal>=<verb>(""read""))`
you write ( `<terminal>` = ""you""; `<non-terminal>=<verb>(""write""))`
you read ( `<terminal>` = ""you""; `<non-terminal>=<verb>(""read""))`",2018-11-13T12:02:32+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 1",tceron,"Forms of production:
`<non terminal>` ::= ""terminal""
`<non terminal>` ::= ""terminal"" `<non terminal>`

For instance:
`<sentence>` ::=  ""He"" `<verb>`
`<sentence>` ::= ""She"" `<verb>`
`<verb>` ::= ""runs""
`<verb>` ::= ""works""

Possible combinations:
He runs (""terminal"" = ""He"" and <non-terminal> = `<verb>` ""runs"")
He works (""terminal"" = ""He"" and <non-terminal> = `<verb>` ""works"")
She runs (""terminal"" = ""She"" and <non-terminal> = `<verb>` ""runs"")
She works (""terminal"" = ""She"" and <non-terminal> = `<verb>` ""works"")",2018-11-13T12:06:25+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 1",friendlynihilist,"Form of production rules for regular grammar:
`<non-terminal>`::=""terminal"" **and** `<non-terminal>`::=""terminal"" `<non-terminal>`

`<sentence>`::=""I"" `<verb>`
`<sentence>`::=""We"" `<verb>`

`<verb>`::=""cry""
`<verb>`::=""die""

I cry (""terminal"" = I and `<verb>`, specifically `<verb>` = cry)
I die (""terminal"" = I and `<verb>`, specifically `<verb>` = die)
We cry (""terminal"" = We and `<verb>`, specifically `<verb>` = cry)
We die (""terminal"" = We and `<verb>`, specifically `<verb>` = die)

That allows me to create all the two-word sentences having as a terminal either the first person singular or the first person plural pronoun accompanied by either the (non-terminal part) `<verb>` ""cry"" or the `<verb>` ""die"", for a total of four combinations.",2018-11-13T12:12:49+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 1",Ioanna96,"`<sentence>::`= ""I"" `<verb>`
`<sentence>::`= ""They"" `<verb>`
`<verb>::`= ""walk""
`<verb>::`=""fly""

I walk (terminal: ""I"", terminal: ""walk"", non-terminal: `<verb>` )
I fly (terminal: ""I"", terminal: ""fly"", non-terminal: `<verb>` )
They walk (terminal:""They"", terminal: ""walk"", non-terminal: `<verb>` )
They fly (terminal:""they"", terminal:""fly"", non-terminal: `<verb>` )",2018-11-13T12:18:13+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 1",lisasiurina," Possible sentences that can be produced by using the regular grammar:

&lt;non terminal&gt; ::= ""terminal""
&lt;non terminal&gt; ::= ""terminal"" <non terminal>

Examples: 

&lt;sentence&gt; ::= “I” <verb>
&lt;sentence&gt; ::= “You” <verb>
&lt;verb&gt; ::= “write”  &lt;verb&gt;  ::= “read”  

Possible example sentences:

I write (""terminal"" = ""I"" and <non terminal> = <verb> “write”) I read (""terminal"" = ""I"" and <non terminal> = <verb>“read”) You write (""terminal"" = “You"" and <non terminal> = <verb> “write”) You read (""terminal"" = “You"" and <non terminal> = <verb> “read”)
",2018-11-13T12:38:34+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 1",mchiaraf,"Form of production rules of **regular grammars**:
`non-terminal ::= ""terminal""` and `<non-terminal> ::= ""terminal"" <non-terminal>`.

**i.e.**
`<sentence> ::= ""I"" <verb>`
`<sentence> ::= ""we"" <verb>`
`<verb> ::= ""run""`
`<verb> ::= ""walk""`

Considering these non-terminal elements we can produce **four possible sentences**:
1. **I run**  - `<pronoun> ::= ""I""` and `<verb> ::= ""run""` 
2. **I walk** - `<pronoun> ::= ""I""` and `<verb> ::= ""walk""`
3. **we run** - `<pronoun> ::= ""we""` and `<verb> ::= ""run""`
4. **we walk** - `<pronoun> ::= ""we""` and `<verb> ::= ""walk""`
",2018-11-13T15:39:07+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 1",SeverinJB,"A sentence can either contain ""I"" plus a verb or ""You"" plus a verb. There are two defined verbs: ""write"" and ""read"". Hence, four constellations are possible. 

1. I write
2. I read 
3. You write
4. You read",2018-11-13T16:39:03+00:00
comp-think/2018-2019,"Lecture ""Introduction to Computational Thinking"", exercise 1",essepuntato,"@MattiaSpadoni and  @ilsamoano and  @lisasiurina 

> `<sentence>` ::= ""I""
> `<sentence>` ::= ""you""

There is something strange here... maybe you wanted to refer to `<pronoun>` instead of `<sentence>`?",2018-11-16T07:02:46+00:00
