repo_name,issue_title,comment_user,comment_text,comment_datetime
comp-think/2023-2024,Exercise 6: Find the Maximum Element in a List,valetedd,"```
def find_max_element(number_list):
    if len(number_list) == 1:
        return number_list[0]
    if len(number_list) == 2:
        if number_list[0] >= number_list[1]:
            return number_list[0]
        else:
            return number_list[1]
    else:
        mid_pos = len(number_list) // 2
        if find_max_element(number_list[0:mid_pos]) >= find_max_element(number_list[mid_pos:len(number_list)]):
            return find_max_element(number_list[0:mid_pos])
        else:
            return find_max_element(number_list[mid_pos:len(number_list)])
```",2023-12-27T19:30:43+00:00
comp-think/2023-2024,Exercise 4: Multiply List Elements,Pepe066,"```
def multiply_elements(number_list):
    mid = len(number_list) // 2
    if len(number_list) == 1:
        return number_list[0]
    else:
        return  multiply_elements(number_list[0:mid]) * multiply_elements(number_list[mid:len(number_list)])

print(multiply_elements([5,5,6]))
```",2023-12-19T17:25:59+00:00
comp-think/2023-2024,Exercise 4: Multiply List Elements,MariaFrancesca6,"```py
def multiply_elements(number_list):
    if len(number_list) == 1:
        return number_list[0]
    else: 
        mid = len(number_list) //2
        first_part = number_list[0:mid]
        second_part = number_list[mid:len(number_list)]
        return multiply_elements(first_part) * multiply_elements(second_part)
        
number_list = [1,2,3]
print(multiply_elements(number_list))
```",2023-12-19T17:36:03+00:00
comp-think/2023-2024,Exercise 4: Multiply List Elements,enricabruno,"``` py
def multiply_elements(number_list):
    result = list()
    mid = len(number_list) // 2
    if len(number_list) ==1:
        return number_list[0]
    else:
        left_part = number_list[0:mid]
        right_part = number_list[mid:]

        return multiply_elements(left_part) * multiply_elements(right_part)


print(multiply_elements([0, 3, 4, 6, 7]))
```",2023-12-19T17:51:07+00:00
comp-think/2023-2024,Exercise 4: Multiply List Elements,valetedd,"```
def multiply_elements(number_list):
    if 0 in number_list:
        return 0
    if len(number_list) == 1:
        return number_list[0]
    elif len(number_list) == 2:
        return number_list[0] * number_list[1]
    else:
        mid_pos = len(number_list) // 2
        return multiply_elements(number_list[0:mid_pos]) * multiply_elements(number_list[mid_pos:len(number_list)])
```",2023-12-27T17:47:38+00:00
comp-think/2023-2024,"Lecture ""Greedy algorithms"", exercise 2",Liber-R,"![Screenshot 2023-12-19 123848](https://github.com/comp-think/2023-2024/assets/132198967/486c47e7-d947-4e21-af54-71ed07751d80)

",2023-12-19T11:38:06+00:00
comp-think/2023-2024,"Lecture ""Greedy algorithms"", exercise 2",frammenti,"```python
def test_select_activities(set_of_activities, expected):
    return select_activities(set_of_activities) == expected

def select_activities(set_of_activities):
    most_productive = []
    sorted_activites = sorted(list(set_of_activities), key=lambda tup: tup[1])
    while sorted_activites:
        activity = sorted_activites.pop(0)
        if not most_productive:
            most_productive.append(activity)
        elif activity[0] > most_productive[-1][1]:
            most_productive.append(activity)
    return most_productive

activities = {(7, 8), (5, 8), (9, 11), (8, 10), (13, 15), (16, 18), (15, 18)}
activites2 = {(6, 7), (7, 9), (9, 11), (11, 13), (13, 15), (15, 18), (18, 20)}


print(test_select_activities(activities, [(5, 8), (9, 11), (13, 15), (16, 18)]))
print(test_select_activities(activites2, [(6, 7), (9, 11), (13, 15), (18, 20)]))
```",2023-12-19T13:18:45+00:00
comp-think/2023-2024,"Lecture ""Greedy algorithms"", exercise 1",Liber-R,"![Screenshot 2023-12-19 111314](https://github.com/comp-think/2023-2024/assets/132198967/b2f0971a-8ef9-428d-a4a7-bd48d17252c0)
![Screenshot 2023-12-19 111327](https://github.com/comp-think/2023-2024/assets/132198967/19bc5a6d-0e72-41bc-9393-d300c56ee68f)
",2023-12-19T10:33:09+00:00
comp-think/2023-2024,"Lecture ""Greedy algorithms"", exercise 1",vattelalberto,"```python
def test_calc_change(price, cash, expected):
    result = calc_change(price, cash)
    if result == expected:
        return True
    else:
        return False

def calc_change(price, cash):
    if cash < price:
        return None
    tot_change = cash - price
    change = dict()
    for coin in [2, 1, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01]:
        number_of_coins = tot_change // coin
        if number_of_coins > 0:
            change[coin] = number_of_coins
            tot_change -= coin * number_of_coins
    
    return change

print(test_calc_change(7.34, 10, {2:1, 0.5:1, 0.1:1, 0.05:1, 0.01:1}))
print(test_calc_change(1.11, 10, {2:4, 0.5:1, 0.2:1, 0.1:1, 0.05:1, 0.02:2}))
print(test_calc_change(10, 10, {}))
print(test_calc_change(10, 5, None))
print(test_calc_change(0, 0, {}))
print(test_calc_change(0.01, 10, {2:4, 1:1, 0.5:1, 0.2:2, 0.05:1, 0.02:2}))
```",2023-12-19T11:24:11+00:00
comp-think/2023-2024,"Lecture ""Greedy algorithms"", exercise 1",MariaFrancesca6,"```py
def test_greedy_algo(my_coins,change,expected):
    result = greedy_algo(my_coins,change)
    if result == expected:
        return True
    else: 
        return False

def greedy_algo(my_coins,change):
    result = list()
    pos = 0
    for coin in my_coins: 
        
        if coin <= change:
            result.append(coin)
            change = change - coin
            if change >= coin:
                result.append(coin)
                change = change - coin
        else:
            coin > change
            pos += 1

    return result
    
my_coins = [2,1,0.50,0.20,0.10,0.05,0.02,0.01]
print(test_greedy_algo(my_coins,4.62,[2,2,0.5,0.1,0.02]))
print(test_greedy_algo(my_coins,5,[2,2,1]))
```",2023-12-19T11:58:21+00:00
comp-think/2023-2024,"Lecture ""Greedy algorithms"", exercise 1",valetedd,"```
def opt_change(change, coin_list):
    result = list()
    index = 0
    while change > 0 and index < len(coin_list):
        current_coin = coin_list[index]
        if round(change - current_coin, 2) >= 0:
            result.append(current_coin)
            change -= current_coin
        else:
            index += 1
    return result

def test_opt_change(change, coin_list, expected):
    result = opt_change(change, coin_list)
    print(result)
    if expected == result:
        return True 
    else:
        return False

coins = [2.00, 1.00, 0.50, 0.20, 0.10, 0.05, 0.02, 0.01]

print(test_opt_change(5.83, coins, [2.00, 2.00, 1.00, 0.50, 0.20, 0.10, 0.02, 0.01]))
print(test_opt_change(2.57, coins, [2.00, 0.50, 0.05, 0.02]))
print(test_opt_change(3.48, coins, [2.00, 1.00, 0.20, 0.20, 0.05, 0.02, 0.01]))
print(test_opt_change(1.74, coins, [1.00, 0.50, 0.20,0.02, 0.02]))
print(test_opt_change(9.55, coins, [2.00, 2.00, 2.00, 2.00, 1.00, 0.50, 0.05]))
```",2023-12-19T12:07:41+00:00
comp-think/2023-2024,"Lecture ""Greedy algorithms"", exercise 1",enricabruno,"``` py
# test function
def test_your_change(coins_list, change, expected):
    result = your_change(coins_list, change)
    if result == expected:
        return True
    else:
        return False

# function
def your_change(coins_list, change):
    result = []
    position = 0
    for i in coins_list:
        if i == change:
            result.append(i) 
            return result
        elif i < change:
            result.append(i)
            change = change - i
            if change >= i:
                result.append(i)
                change = change - i
            else:
                new_position = position + 1
    
    return result

print(test_your_change([2, 1, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01], 2,[2]))
print(test_your_change([2, 1, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01], 7,[2,2,1,1,0.5,0.5]))
print(test_your_change([2, 1, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01], 11.3,[2,2,1,1,0.5,0.5,0.2,0.2,0.1,0.1,0.05,0.05,0.02,0.02,0.01,0.01]))
```",2023-12-20T09:14:06+00:00
comp-think/2023-2024,"Lecture ""Greedy algorithms"", exercise 1",qwindici,"```
def calculate_coins_change(change):
    coins_euros = [2, 1, 0.50, 0.20, 0.10, 0.05, 0.02, 0.01]
    result = []

    for coin in coins_euros:
        while sum(result) + coin <= change:
            result.append(coin)

    return result


def test_calculate_coins_change(change, expected):
    if calculate_coins_change(change) == expected:
        return True
    else:
        return False


test_calculate_coins_change(4.62, [2, 2, 0.5, 0.1, 0.02])
test_calculate_coins_change(5.43, [2, 2, 1, 0.2, 0.2, 0.02, 0.01])
test_calculate_coins_change(8.05, [2, 2, 2, 2, 0.05])
test_calculate_coins_change(1.50, [1, 0.5])
```",2023-12-21T16:33:32+00:00
comp-think/2023-2024,"Lecture ""Organising information: graphs"", exercise 2",frammenti,"```python
import networkx as nx

G = nx.DiGraph()

G.add_nodes_from([
    ""Ocean's Twelve"", ""Fight Club"", ""Dark Shadows"",
    ""Brad Pitt"", ""Eva Green"", ""George Clooney"",
    ""Catherine Zeta-Jones"", ""Johnny Depp"", ""Helena Bonham Carter"",
    ])
G.add_edges_from([
    (""George Clooney"", ""Ocean's Twelve""), (""Brad Pitt"", ""Ocean's Twelve""), (""Catherine Zeta-Jones"", ""Ocean's Twelve""),
    (""Brad Pitt"", ""Fight Club""), (""Helena Bonham Carter"", ""Fight Club""),
    (""Johnny Depp"", ""Dark Shadows""), (""Eva Green"", ""Dark Shadows""), (""Helena Bonham Carter"", ""Dark Shadows""),
    ])

print(G.reverse().adj[""Ocean's Twelve""])
# {'Brad Pitt': {}, 'George Clooney': {}, 'Catherine Zeta-Jones': {}}
print(G.reverse().adj[""Fight Club""])
# {'Brad Pitt': {}, 'Helena Bonham Carter': {}}
print(G.reverse().adj[""Dark Shadows""])
# {'Eva Green': {}, 'Johnny Depp': {}, 'Helena Bonham Carter': {}}
```
![Figure_2](https://github.com/comp-think/2023-2024/assets/146438454/c0b6e9ad-223e-4166-9e45-0f9ceb3ffbd1)
",2023-12-18T08:42:13+00:00
comp-think/2023-2024,"Lecture ""Organising information: graphs"", exercise 2",Liber-R,"![Screenshot 2023-12-18 130146](https://github.com/comp-think/2023-2024/assets/132198967/62171fdb-d951-434b-a9b2-e089d3f5a42f)
",2023-12-18T12:03:55+00:00
comp-think/2023-2024,"Lecture ""Organising information: graphs"", exercise 2",Chiaramartina,"<img width=""741"" alt=""Schermata 2023-12-18 alle 17 54 19"" src=""https://github.com/comp-think/2023-2024/assets/106493111/1285868a-f8c4-4b04-9ed6-9a8b549823d6"">
",2023-12-18T16:55:05+00:00
comp-think/2023-2024,"Lecture ""Organising information: graphs"", exercise 2",simocasaz,"```
from networkx import MultiDiGraph

my_graph = MultiDiGraph()

my_graph.add_node(1, type = ""movie"", title = ""Ocean's Twelve"")
my_graph.add_node(2, type = ""movie"", title = ""Fight Club"")
my_graph.add_node(3, type = ""movie"", title = ""Dark Shadows"")
my_graph.add_node(4, type = ""actor"", name = ""Brad"", surname = ""Pitt"")
my_graph.add_node(5, type = ""actor"", name = ""Eva"", surname = ""Green"")
my_graph.add_node(6, type = ""actor"", name = ""George"", surname = ""Clooney"")
my_graph.add_node(7, type = ""actor"", name = ""Catherine"", surname = ""Zeta-Jones"")
my_graph.add_node(8, type = ""actor"", name = ""Johnny"", surname = ""Depp"")
my_graph.add_node(9, type = ""actor"", name = ""Helena"", surname = ""Bonham Carter"")

my_graph.add_edge(4, 1, relation = ""starred in"")
my_graph.add_edge(1, 4, relation = ""has in the cast"")
my_graph.add_edge(4, 2, relation = ""starred in"")
my_graph.add_edge(2, 4, relation = ""has in the cast"")
my_graph.add_edge(5, 3, relation = ""starred in"")
my_graph.add_edge(3, 5, relation = ""has in the cast"")
my_graph.add_edge(6, 1, relation = ""starred in"")
my_graph.add_edge(1, 6, relation = ""has in the cast"")
my_graph.add_edge(7, 1, relation = ""starred in"")
my_graph.add_edge(1, 7, relation = ""has in the cast"")
my_graph.add_edge(8, 3, relation = ""starred in"")
my_graph.add_edge(3, 8, relation = ""has in the cast"")
my_graph.add_edge(9, 2, relation = ""starred in"")
my_graph.add_edge(2, 9, relation = ""has in the cast"")
my_graph.add_edge(9, 3, relation = ""starred in"")
my_graph.add_edge(3, 9, relation = ""has in the cast"")
```",2023-12-22T14:03:26+00:00
comp-think/2023-2024,"Lecture ""Organising information: graphs"", exercise 2",qwindici,"```py
from networkx import DiGraph

films = {
    ""Ocean's Twelve"": [""Catherine Zeta-Jones"", ""George Clooney"", ""Brad Pitt""],
    ""Fight Club"": [""Brad Pitt"", ""Helena Bonham Carter""],
    ""Dark Shadows"": [""Johnny Depp"", ""Helena Bonham Carter"", ""Eva Green""],
}

starred_in = DiGraph()

for film in films:
    starred_in.add_node(film)
    for actor in films[film]:
        starred_in.add_node(actor)
        starred_in.add_edge(film, actor, relationship='starring')
```",2023-12-24T11:17:31+00:00
comp-think/2023-2024,"Lecture ""Organising information: graphs"", exercise 1",frammenti,"```python
import networkx as nx

G = nx.Graph()

G.add_node(1, name=""Tim"", surname=""Berners-Lee"")

G.add_node(2, name=""Tom"", surname=""Heath"")
G.add_node(3, name=""Christian"", surname=""Bizer"")
G.add_node(4, name=""James A."", surname=""Hendler"")
G.add_node(5, name=""Sören"", surname=""Auer"")
G.add_node(6, name=""Nigel"", surname=""Shadbolt"")

G.add_edge(1, 2, weight=19)
G.add_edge(1, 3, weight=19)
G.add_edge(1, 4, weight=10)
G.add_edge(1, 5, weight=10)
G.add_edge(1, 6, weight=9)

# Merging of the two View objects in a dictionary for check
nodes = G.nodes.data()
adjacents = G.adj[1].items()
top_coauthors_dict = dict()

for n, attr in adjacents:
    top_coauthors_dict[nodes[n][""surname""]+"", ""+nodes[n][""name""]] = attr[""weight""]

print(top_coauthors_dict)
# {'Heath, Tom': 19, 'Bizer, Christian': 19, 'Hendler, James A.': 10, 'Auer, Sören': 10, 'Shadbolt, Nigel': 9}
```
![Figure_1](https://github.com/comp-think/2023-2024/assets/146438454/18c4bae1-26a4-4d08-8753-79ec3d3433c4)
",2023-12-18T08:26:30+00:00
comp-think/2023-2024,"Lecture ""Organising information: graphs"", exercise 1",MariaFrancesca6,"```py
from networkx import MultiGraph

authors_graph = MultiGraph()

authors_graph.add_node(""Tim Berners-Lee"")
authors_graph.add_node(""Sören Auer"")
authors_graph.add_node(""Christian Bizer"")
authors_graph.add_node(""Tom Heath"")
authors_graph.add_node(""James A. Hendler"")
authors_graph.add_node(""Lalana Kagal"")

authors_graph.add_edge(""Tim Berners-Lee"",""Sören Auer"", weight=10)
authors_graph.add_edge(""Tim Berners-Lee"",""Christian Bizer"", weight=19)
authors_graph.add_edge(""Tim Berners-Lee"",""Tom Heath"", weight=19)
authors_graph.add_edge(""Tim Berners-Lee"",""James A. Hendler"", weight=10)
authors_graph.add_edge(""Tim Berners-Lee"",""Lalana Kagal"", weight=9)
```

",2023-12-18T11:11:37+00:00
comp-think/2023-2024,"Lecture ""Organising information: graphs"", exercise 1",Liber-R,"![Screenshot 2023-12-18 123308](https://github.com/comp-think/2023-2024/assets/132198967/a367d06d-f950-49c0-bb69-a8bb3b316fb0)
",2023-12-18T11:33:54+00:00
comp-think/2023-2024,"Lecture ""Organising information: graphs"", exercise 1",Chiaramartina,"<img width=""631"" alt=""Schermata 2023-12-18 alle 17 05 42"" src=""https://github.com/comp-think/2023-2024/assets/106493111/e179deb6-09d0-46d6-962f-40066f9eb944"">
",2023-12-18T16:06:19+00:00
comp-think/2023-2024,"Lecture ""Organising information: graphs"", exercise 1",enricabruno,"``` py
import networkx as nx

co_authors_Tim = nx.Graph()

# create nodes
co_authors_Tim.add_node(""Berners-Lee, Tim"")
co_authors_Tim.add_node(""Heath, Tom"")
co_authors_Tim.add_node(""Bizer, Christian"")
co_authors_Tim.add_node(""Hendler, James.A"")
co_authors_Tim.add_node(""Auer, Sören"")
# create edges
co_authors_Tim.add_edge(""Berners-Lee, Tim"", ""Heath, Tom"", weight=19)
co_authors_Tim.add_edge(""Berners-Lee, Tim"", ""Bizer, Christian"", weight=19)
co_authors_Tim.add_edge(""Berners-Lee, Tim"", ""Hendler, James.A"", weight=10)
co_authors_Tim.add_edge(""Berners-Lee, Tim"", ""Auer, Sören"", weight=10)

# export the graph to GraphML
nx.write_graphml(co_authors_Tim, ""co_authors_Tim.graphml"")
```
Graph with Gephi tool:
<img width=""765"" alt=""prova_gephi"" src=""https://github.com/comp-think/2023-2024/assets/83347862/00bef002-178c-4e18-b30c-7a84fd80e08f"">



",2023-12-20T10:45:30+00:00
comp-think/2023-2024,"Lecture ""Organising information: graphs"", exercise 1",simocasaz,"```
from networkx import Graph

my_graph = Graph()
my_graph.add_node(1, name = ""Tim"", surname = ""Berners-Lee"")
my_graph.add_node(2, name = ""Tom"", surname = ""Heath"")
my_graph.add_node(3, name = ""Christian"", surname = ""Bizer"")
my_graph.add_node(4, name = ""James Alexander"", surname = ""Hendler"")
my_graph.add_node(5, name = ""Soren"", surname = ""Auer"")
my_graph.add_node(6, name = ""Nigel"", surname = ""Shadbolt"")

my_graph.add_edge(1, 2, weight = 19)
my_graph.add_edge(1, 3, weight = 19)
my_graph.add_edge(1, 4, weight = 10)
my_graph.add_edge(1, 5, weight = 10)
my_graph.add_edge(1, 6, weight = 9)
```
",2023-12-22T13:40:33+00:00
comp-think/2023-2024,"Lecture ""Organising information: graphs"", exercise 1",qwindici,"```py
from networkx import Graph

co_authors = Graph()
# central node
co_authors.add_node(""Tim Berners-Lee"")
# co-authors nodes
co_authors_list = {
    ""Nigel Shadbolt"": 9,
    ""Christian Bizer"": 19,
    ""Tom Heath"": 19,
    ""James A. Hendler"": 10,
    ""Sören Auer"": 10,
}

for key in co_authors_list:
    co_authors.add_node(key)
    co_authors.add_edge(""Tim Berners-Lee"", key, weight=co_authors_list[key])
```",2023-12-24T10:57:01+00:00
comp-think/2023-2024,Exercise 4: Find Missing Combination Write the body of the Python ,FranciscoWu,"```
def find_missing_combination(n1, n2, n3, combinations):
    missing_combination = []
    for i in range(n1+1):
        for j in range(n2+1):
            for k in range(n3+1):
                if (i,j,k) not in combinations:
                    missing_combination.append((i,j,k))
    return set(missing_combination)


if __name__ == ""__main__"":
    n1 = 4
    n2 = 4
    n3 = 4
    combinations =  [(0, 0, 0), (1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4), (0, 1, 2)]
    print(find_missing_combination(n1, n2, n3, combinations))",2023-12-15T09:43:47+00:00
comp-think/2023-2024,Exercise 4: Find Missing Combination Write the body of the Python ,MariaFrancesca6,"solution by me and @enricabruno
```py
def find_missing_combination(n1, n2, n3, combinations):
    result = set()
    for x1 in range(n1 + 1):
        for x2 in range(n2 + 1):
            for x3 in range(n3 + 1):
                if (x1,x2,x3) not in combinations:
                    my_tuple = (x1,x2,x3)
                    result.add(my_tuple)
    return result
print(find_missing_combination(4, 4, 4, [(0, 0, 0), (1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4), (0, 1, 2)]))
```",2023-12-15T10:38:45+00:00
comp-think/2023-2024,Exercise 4: Find Missing Combination Write the body of the Python ,valetedd,"```
def find_missing_combination(n1, n2, n3, combinations):
    missing = set()
    for digit_1 in range(n1+1):
        for digit_2 in range(n2+1):
            for digit_3 in range(n3+1):
                current_tuple = (digit_1, digit_2, digit_3)
                if current_tuple not in combinations:
                    missing.add(current_tuple)
    return missing
```",2023-12-18T10:53:26+00:00
comp-think/2023-2024,Exercise 3: Character Combination,FranciscoWu,"```
def combine_characters(string1, string2):
    combined_string = """"
    longest_string = max([string1,string2],key = len)
    shortest_string = min([string1,string2], key = len)
    i = 0
    while i < len(shortest_string):
        combined_string += string1[i]
        combined_string += string2[i]
        i += 1
    combined_string += longest_string[len(shortest_string):]
    return combined_string


if __name__ == ""__main__"":
    string1 = ""Thinking""
    string2 = ""Compuational""
    print(combine_characters(string1, string2))",2023-12-15T09:18:00+00:00
comp-think/2023-2024,Exercise 3: Character Combination,rufferbaraldi,"```
string1 = ""789""
string2 = ""12345""

def combine_characters(string1, string2):
    combined_result = """"
    len1 = len(string1)
    len2 = len(string2)
    
    if len1 >= len2:
        max_len = len1
    else:
        max_len = len2
      
    for i in range(max_len):
        if i < len1:
            combined_result += string1[i]
        if i < len2:
            combined_result += string2[i]
    return combined_result

print(combine_characters(string1, string2))
```",2023-12-15T09:34:05+00:00
comp-think/2023-2024,Exercise 3: Character Combination,enricabruno,"``` py
def combine_characters(string1, string2):
    combined = ''
    i, j = 0, 0

    while i < len(string1) and j < len(string2):
        combined += string1[i] + string2[j]
        i += 1
        j += 1

    combined += string1[i:] + string2[j:]

    return combined

print(combine_characters(""abc"", ""12345""))
```
",2023-12-16T10:02:37+00:00
comp-think/2023-2024,Exercise 3: Character Combination,MariaFrancesca6,"```py
def combine_characters(str1, str2):
    result = list()
    i = 0
    j = 0
    while i < len(str1) and j < len(str2):
        result.append(str1[i])
        result.append(str2[j])
        i += 1
        j += 1
    result.extend(str1[i:] + str2[j:])
    return """".join(result)

print(combine_characters(""natale"",""capodanno""))
```",2023-12-16T11:43:18+00:00
comp-think/2023-2024,Exercise 3: Character Combination,qwindici,"```
def combine_characters(string1, string2):
    long = string1 if len(string1) > len(string2) else string2
    short = string1 if long == string2 else string2
    result = """"
    for i in range(len(short + long)):
        if i < len(short):
            result += short[i]
        if i < len(long):
            result += long[i]

    return """".join(result)
```",2023-12-17T23:34:59+00:00
comp-think/2023-2024,Exercise 3: Character Combination,valetedd,"```
def combine_characters(string1, string2):
    combined_string = """"
    if len(string1) > len(string2):
        longer = len(string1)
    else:
        longer = len(string2)

    for i in range(longer + 1):
        if i <= len(string1) - 1:
            combined_string += string1[i]
        if i <= len(string2) - 1:
            combined_string += string2[i]

    return combined_string
```",2023-12-18T10:52:53+00:00
comp-think/2023-2024,Esercise 2: Filtering Long Words from a Sentence,FranciscoWu,"![image](https://github.com/comp-think/2023-2024/assets/146438244/8ec14916-5058-4b77-9c9b-c2b45145cb8b)
",2023-12-15T08:45:45+00:00
comp-think/2023-2024,Esercise 2: Filtering Long Words from a Sentence,valentinabertelli,"```
def filter_long_words(sentence, length):
    words_list = sentence.split()
    result = []
    for word in words_list:
        if len(word) > length:
            result.append(word)
    return result    

print(filter_long_words(""i like reading books"", 4)) #result = ['reading', 'books']
```",2023-12-15T08:55:25+00:00
comp-think/2023-2024,Esercise 2: Filtering Long Words from a Sentence,MariaFrancesca6,"```py
def  filter_long_words(sentence, length):
    result = list()
    list_sentence = sentence.split()
    for word in list_sentence:
        len_word = len(word)
        if len_word > length:
            result.append(word)
    return result

print(filter_long_words(""Sono andata al mercato e ho comprato il radicchio"", 4))
```
",2023-12-15T08:57:39+00:00
comp-think/2023-2024,Esercise 2: Filtering Long Words from a Sentence,annapasetto0,"def filter_long_words(sentence, length):
    w_list = list()
    sentence_split = sentence.split("" "")
    
    for i in sentence_split:
        if len(i) > length:
            w_list.append(i)
    return w_list

sentence = ""returns a list of the words in the sentence that are longer than the given number""
length = 5

print(filter_long_words(sentence, length))
#['returns', 'sentence', 'longer', 'number']",2023-12-15T09:00:02+00:00
comp-think/2023-2024,Esercise 2: Filtering Long Words from a Sentence,enricabruno,"``` py
def filter_long_words(sentence, length):
    my_list = sentence.split("" "")
    my_new_list = list()
    for word in my_list:
        if len(word) > length:
            my_new_list.append(word)
    return my_new_list

print(filter_long_words(""Un esercizio da laboratorio"", 4)) # ['esercizio', 'laboratorio']
```",2023-12-15T09:00:22+00:00
comp-think/2023-2024,Esercise 2: Filtering Long Words from a Sentence,Chiaramartina,"<img width=""1040"" alt=""Schermata 2023-12-15 alle 10 01 02"" src=""https://github.com/comp-think/2023-2024/assets/106493111/6c4caadc-7272-40e4-9177-ff1e6c1348f5"">
",2023-12-15T09:01:33+00:00
comp-think/2023-2024,Esercise 2: Filtering Long Words from a Sentence,rufferbaraldi,"```
sentence = ""eu sei que isso não funciona""
length = 3

def filter_long_words(sentence, length):
    words = sentence.split("" "")
    filtered_words = list()
    for item in words:
        if len(item) > length:
           filtered_words.append(item) 
    return filtered_words
    
print(filter_long_words(sentence, length))
```",2023-12-15T09:10:41+00:00
comp-think/2023-2024,Esercise 2: Filtering Long Words from a Sentence,Theengwar,"def filter_long_words(sentence,length):
    the_list=sentence.split()
    New_list = []
    for item in the_list:
        if len(item) > length:
           New_list.append(item)
    return (New_list)",2023-12-15T09:11:48+00:00
comp-think/2023-2024,Esercise 2: Filtering Long Words from a Sentence,qwindici,"```
def filter_long_words(sentence, length):
  return [x for x in sentence.split(' ') if len(x) > length]

filter_long_words(sentence='Ciao mi chiamo Ludovica', length=4)
```",2023-12-17T18:43:15+00:00
comp-think/2023-2024,Esercise 2: Filtering Long Words from a Sentence,valetedd,"```
def filter_long_words(sentence, length):
    result = list()
    sentence.split("" "")
    for token in sentence:
        if token > length:
            token.append(result)
    return result
```",2023-12-18T10:51:55+00:00
comp-think/2023-2024,Exercise 1: Reverse String and Count Vowels,annapasetto0,"def f(s):
    final_list = list()
    s_reversed = list(reversed(s))
    for i in s:
        if i in ""aeiou"":
            final_list.append(i)
    return  s_reversed, len(final_list)

s = ""string""

print(f(s))",2023-12-15T08:26:40+00:00
comp-think/2023-2024,Exercise 1: Reverse String and Count Vowels,FranciscoWu,"![image](https://github.com/comp-think/2023-2024/assets/146438244/986778e2-8dee-446a-b512-9fb723c290e9)
",2023-12-15T08:27:31+00:00
comp-think/2023-2024,Exercise 1: Reverse String and Count Vowels,enricabruno,"``` py
def reverse_and_count(string):
    reverse_string = string[::-1]
    vowels = [""a"", ""e"", ""i"", ""o"", ""u""]
    count_vowels = 0
    for x in string:
        if x in vowels:
            count_vowels +=1
    my_tuple = (reverse_string, count_vowels)
    return my_tuple

print(reverse_and_count(""Enrica"")) # ('acirnE', 2)
```",2023-12-15T08:31:25+00:00
comp-think/2023-2024,Exercise 1: Reverse String and Count Vowels,Pepe066,"def test_reverse_and_count(string, expected):
    
    result = reverse_and_count(string)
    if result == expected:
        return True 
    else:
        return False

def reverse_and_count(string):
    
    r_string = string[::-1]
    n = 0
    for v in string:
        if v in ""aeiou"":
            n+=1
    return (n , r_string)

test_reverse_and_count(""pollo"", (2,""ollop""))",2023-12-15T08:31:36+00:00
comp-think/2023-2024,Exercise 1: Reverse String and Count Vowels,valentinabertelli,"```
def reverse_and_count(s):
    s = list(s)
    s.reverse()
    n = 0
    for c in s:
        if c in ""aeiou"":
            n = n + 1
    return (s, n)        

print(reverse_and_count(""hello"")) 
```",2023-12-15T08:31:37+00:00
comp-think/2023-2024,Exercise 1: Reverse String and Count Vowels,Theengwar,"def reverse_and_count(string):
    reversed_string = string[::-1]
    vowel_count = sum(1 for char in reversed_string if char.lower() in 'aeiou')
    return (reversed_string, vowel_count)",2023-12-15T08:34:31+00:00
comp-think/2023-2024,Exercise 1: Reverse String and Count Vowels,Chiaramartina,"<img width=""1011"" alt=""Schermata 2023-12-15 alle 09 37 39"" src=""https://github.com/comp-think/2023-2024/assets/106493111/a588fe1e-328c-4765-88aa-f1bbf15327d1"">
",2023-12-15T08:38:05+00:00
comp-think/2023-2024,Exercise 1: Reverse String and Count Vowels,simocasaz,"```
def test_reverse_and_count(string, expected):
    result = reverse_and_count(string)
    if result == expected:
        return True
    else:
        return False
        


def reverse_and_count(string):
    set_vowels = {""a"", ""e"", ""i"", ""o"", ""u""}
    reversed_string = """".join(reversed(string))
    count_vowels = 0
    for letter in reversed_string:
        if letter in set_vowels:
            count_vowels += 1
    result = (reversed_string, count_vowels)
    return result

print(test_reverse_and_count(""andrea"", (""aerdna"", 3)))
print(test_reverse_and_count(""elio"", (""oile"", 3)))
print(test_reverse_and_count(""drfght"", (""thgfrd"", 0)))
```",2023-12-15T08:48:51+00:00
comp-think/2023-2024,Exercise 1: Reverse String and Count Vowels,MariaFrancesca6,"```py
vowels = [""a"",""e"",""i"",""o"",""u""]
def reverse_and_count(string):
    list_string = list(string)
    reversed_string = reversed(list_string)
    final_str = """".join(reversed_string)
    counter = 0
    for x in list_string:
        if x in vowels:
            counter += 1
    return (final_str,counter,)

print(reverse_and_count(""natale""))
```",2023-12-15T08:50:49+00:00
comp-think/2023-2024,Exercise 1: Reverse String and Count Vowels,rufferbaraldi,"```
def reverse_and_count(s_string):
    list_from_string = list(s_string)
    reversed_list = reversed(list_from_string)
    string_from_reversed_list = """".join(reversed_list)
    count = 0
    vowels = [""a"", ""e"", ""i"", ""o"", ""u""]
    i = 0
    for i in range(len(s_string)):
        if s_string[i] in vowels:
            count += 1
    return string_from_reversed_list, count

print(reverse_and_count(""eu espero que de certo""))
```",2023-12-15T08:50:52+00:00
comp-think/2023-2024,Exercise 1: Reverse String and Count Vowels,qwindici,"```
def reverse_and_count(string):
    r_string = list(reversed(string))
    n_vowels = len([x for x in r_string if x.lower() in ""aeiou""])
    return """".join(r_string), n_vowels


reverse_and_count(""hello there"")  # ('ereht olleh', 4)
reverse_and_count(""gabbiano"") #(""onaibbag"", 4)
reverse_and_count(""AEIOU"")  # ('UOIEA', 5)
```",2023-12-17T18:39:59+00:00
comp-think/2023-2024,Exercise 1: Reverse String and Count Vowels,valetedd,"```
def reverse_and_count(string):
    reversed_string = string[::-1]
    vow_count = 0
    for char in string:
        if char in ""aeiou"":
            vow_count += 1
    return (reversed_string, vow_count)
```",2023-12-18T10:50:47+00:00
comp-think/2023-2024,"Lecture ""Backtracking algorithms"", exercise 2",frammenti,"Edit: added `no_exit` configuration
```python
from anytree import Node
from collections import deque

def test_solve_labyrinth(paths, entrance, exit, last_move):
    result = solve_labyrinth(paths, entrance, exit, last_move)
    return result is not None and exit == result.name and (
        # Check whether all steps are within the boundaries of the labyrinth
        all(ancestor.name in paths for ancestor in result.ancestors if ancestor is not last_move.root))


def solve_labyrinth(paths, entrance, exit, last_move):
    result = None

    if last_move.name == exit:
        result = last_move
    elif last_move.name not in last_move.root.name: # avoid loop paths
        last_move.children = crossroads(paths, entrance, last_move)
        possible_moves = deque(last_move.children)

        while result is None and len(possible_moves) > 0: # implicit leaf-lose
            current_move = possible_moves.popleft()
            # In each recursive step, the entrance is shifted forward to avoid unintentional backtracking
            result = solve_labyrinth(paths, last_move.name, exit, current_move)

    return result


def crossroads(paths, entrance, last_move):
    result = []
    x, y = last_move.name

    # First execution
    if last_move.parent is None:
        last_move.parent = Node(set())

    # Last_move coordinates added to visited set    
    last_move.root.name.add((x, y))

    # Progression of search is North-East-South-West
    for direction in [(x, y - 1), (x + 1, y), (x, y + 1), (x - 1, y)]:
        if direction in paths and direction != entrance:
            result.append(Node(direction))
            
    return result

paths = set([
        (0,1), (0,2), (0,3), (0,4), (0,5),
        (1,0), (1,1), (1,5),
        (2,1), (2,2), (2,3), (2,5),
        (3,0), (3,1), (3,3), (3,5),
        (4,0), (4,2), (4,4), (4,5),
        (5,0), (5,1), (5,2), (5,3), 
    ])

loop = set([
        (0,1), (0,2), (0,3), (0,4), (0,5),
        (1,0), (1,1), (1,5),
        (2,1), (2,2), (2,3), (2,5),
        (3,0), (3,1), (3,3), (3,5),
        (4,0), (4,2), (4,4), (4,5),
        (5,0), (5,1), (5,2), (5,3),
        (5,4),  
    ])

no_exit = set([
        (0,1), (0,2), (0,3), (0,4), (0,5),
        (1,0), (1,1), (1,5),
        (2,1), (2,2), (2,3), (2,5),
        (3,0), (3,1), (3,3), (3,5),
        (4,0), (4,2), (4,4), (4,5),
        (5,0), (5,1), (5,3),
    ])

# Root node name is initialized with entrance coordinates
print(test_solve_labyrinth(paths, (2, 1), (3, 3), Node((2, 1)))) # 12 steps
print(test_solve_labyrinth(loop, (2, 1), (3, 3), Node((2, 1)))) # 26 steps
print(test_solve_labyrinth(paths, (2, 1), (2, 1), Node((2, 1)))) # 1 step
print(test_solve_labyrinth(loop, (5, 2), (4, 2), Node((5, 2)))) # 27 steps
print(test_solve_labyrinth(no_exit, (2, 1), (4, 2), Node((2, 1)))) # No exit returns False, 21 steps
```",2023-12-17T07:59:47+00:00
comp-think/2023-2024,"Lecture ""Backtracking algorithms"", exercise 2",Liber-R,"![Screenshot 2023-12-17 150224](https://github.com/comp-think/2023-2024/assets/132198967/4c66a7a2-8d8c-4bc1-98f0-88545ec761ea)
![Screenshot 2023-12-17 150241](https://github.com/comp-think/2023-2024/assets/132198967/61a1a161-ac9f-43ac-a051-ecc4327cda88)
![Screenshot 2023-12-17 150256](https://github.com/comp-think/2023-2024/assets/132198967/6375ec4c-9f60-4c7f-b7fd-9994b0b6576e)
",2023-12-17T14:16:33+00:00
comp-think/2023-2024,"Lecture ""Backtracking algorithms"", exercise 2",valetedd,"```
from anytree import Node
from collections import deque


### Ex. 2 ###

def test_labyrinth(paths, entrance, exit, last_move, expected):
    result = solve_labyrinth(paths, entrance, exit, last_move)
    if expected == result.name[""next""]:
        return True
    else:
        return False 
   
def valid_directions(paths, entrance):
    result = list()
    x = entrance[0]
    y = entrance[1]
    if (x-1, y) in paths:
        result.append(Node({""previous"": entrance, ""next"" : (x - 1, y)}))
    if (x+1, y) in paths:
        result.append(Node({""previous"": entrance, ""next"" : (x + 1, y)}))
    if (x, y-1) in paths:
        result.append(Node({""previous"": entrance, ""next"" : (x, y - 1)}))
    if (x, y+1) in paths:
        result.append(Node({""previous"": entrance, ""next"" : (x, y + 1)}))
    return result

def step(node, paths):
    coords = node.name
    prev_pos = coords.get(""previous"")
    new_pos = coords.get(""next"")
    
    paths.discard(prev_pos)
    paths.add(new_pos)
    

def undo_movement(node, paths):
    coords = node.name
    prev_pos = coords.get(""next"")
    new_pos = coords.get(""previous"")
    
    paths.add(prev_pos)
    paths.discard(new_pos)
    
def solve_labyrinth(paths, entrance, exit, last_move):
    result = None
    if entrance == exit:
        return last_move
    else:
        last_move.children = valid_directions(paths, entrance)
        if len(last_move.children) == 0: # dead-end base case
            undo_movement(last_move, paths) # backtracking
        else: # recursive step
            possible_moves = deque(last_move.children)
            while result is None and len(possible_moves) > 0:
                current_move = possible_moves.pop()
                step(current_move, paths)
                curr_position = current_move.name.get(""next"")
                result = solve_labyrinth(paths, curr_position, exit, current_move)
            if result is None:
                undo_movement(last_move, paths) # backtracking
    return result

def create_board():       
    paths = set([
            (1,0),       (3,0), (4,0), (5,0),
        (0,1), (1,1),(2,1), (3,1),        (5,1),
        (0,2),       (2,2),        (4,2), (5,2),
        (0,3),       (2,3), (3,3),        (5,3),
        (0,4),                     (4,4),
        (0,5), (1,5),(2,5), (3,5), (4,5)
        ])
    entrance = (1, 0)
    exit = (5, 3)

    return paths, entrance, exit

paths, entrance, exit = create_board()

##Test cases

#print(test_labyrinth(paths, entrance, exit, Node(""start""), (5, 3)))
#print(test_labyrinth(paths, (4, 4), (4,2), Node(""start""), (4,2)))
#print(test_labyrinth(paths, (3, 3), (4,4), Node(""start""), (4,4)))
#print(test_labyrinth(paths, (0, 5), (1,0), Node(""start""), (1,0)))
```",2023-12-18T22:29:41+00:00
comp-think/2023-2024,"Lecture ""Backtracking algorithms"", exercise 1",frammenti,"```python
from anytree import Node
from collections import deque


def test_solve(pegs, holes, last_move, expected):
    result = solve(pegs, holes, last_move)
    if expected == result.name[""in""] and len(pegs) == 1:
        return True
    else:
        return False


def solve(pegs, holes, last_move):
    result = None

    # Dead-end configurations are treated as leaf-lose
    if pegs in last_move.root.name:
        undo_move(last_move, pegs, holes)
    elif len(pegs) == 1 and (5, 1) in pegs:
        result = last_move
    else:
        last_move.children = valid_moves(pegs, holes)

        if len(last_move.children) == 0:
            undo_move(last_move, pegs, holes)
        else:
            possible_moves = deque(last_move.children)

            while result is None and len(possible_moves) > 0:
                current_move = possible_moves.pop()
                apply_move(current_move, pegs, holes)
                result = solve(pegs, holes, current_move)

            if result is None:
                undo_move(last_move, pegs, holes)

    return result


def create_board():
    initial_hole = (5, 1)
    holes = set()
    holes.add(initial_hole)

    pegs = set([
        (1, 0), (4, 0),
        (0, 1), (1, 1), (2, 1), (3, 1), (4, 1),
        (1, 2), (4, 2),
        (1, 3), (4, 3),
        (0, 4), (1, 4), (2, 4), (3, 4), (4, 4), (5, 4),
        (1, 5), (4, 5)
    ])

    return pegs, holes


def valid_moves(pegs, holes):
    result = list()

    for x, y in holes:
        if (x-1, y) in pegs and (x-2, y) in pegs:
            result.append(Node({""move"": (x-2, y), ""in"": (x, y), ""remove"": (x-1, y)}))
        if (x+1, y) in pegs and (x+2, y) in pegs:
            result.append(Node({""move"": (x+2, y), ""in"": (x, y), ""remove"": (x+1, y)}))
        if (x, y-1) in pegs and (x, y-2) in pegs:
            result.append(Node({""move"": (x, y-2), ""in"": (x, y), ""remove"": (x, y-1)}))
        if (x, y+1) in pegs and (x, y+2) in pegs:
            result.append(Node({""move"": (x, y+2), ""in"": (x, y), ""remove"": (x, y+1)}))

    return result


def apply_move(node, pegs, holes):
    move = node.name
    old_pos = move.get(""move"")
    new_pos = move.get(""in"")
    eat_pos = move.get(""remove"")

    pegs.remove(old_pos)
    holes.add(old_pos)

    pegs.add(new_pos)
    holes.remove(new_pos)

    pegs.remove(eat_pos)
    holes.add(eat_pos)


def undo_move(node, pegs, holes):
    move = node.name
    old_pos = move.get(""move"")
    new_pos = move.get(""in"")
    eat_pos = move.get(""remove"")

    # Dead-end configuations are added as an immutable set to root node name
    node.root.name.add(frozenset(pegs))

    pegs.add(old_pos)
    holes.remove(old_pos)

    pegs.remove(new_pos)
    holes.add(new_pos)

    pegs.add(eat_pos)
    holes.remove(eat_pos)


pegs, holes = create_board()
# Root node name is directly set as an empty set
print(test_solve(pegs, holes, Node(set()), (5, 1)))
```
![image](https://github.com/comp-think/2023-2024/assets/146438454/010ba053-17e7-44e8-a5e5-953782450d6d)
",2023-12-15T18:42:30+00:00
comp-think/2023-2024,"Lecture ""Backtracking algorithms"", exercise 1",simocasaz,"```
from anytree import Node
from collections import deque


# Test case for the algorithm
def test_solve(pegs, holes, last_move, no_solution, expected):
    result = solve(pegs, holes, last_move, no_solution)
    if expected == result.name[""in""] and len(pegs) == 1:
        return True
    else:
        return False


# Code of the algorithm
def solve(pegs, holes, last_move, no_solution):
    result = None
    if last_move in no_solution:
        undo_move(last_move, pegs, holes)

    no_solution[last_move] = pegs

    if len(pegs) == 1 and (5, 1) in pegs:  # leaf-win base case
        result = last_move
    else:
        last_move.children = valid_moves(pegs, holes)

        if len(last_move.children) == 0:  # leaf-lose base case
            undo_move(last_move, pegs, holes)  # backtracking
        else:  # recursive step
            possible_moves = deque(last_move.children)

            while result is None and len(possible_moves) > 0:
                current_move = possible_moves.pop()
                apply_move(current_move, pegs, holes)
                result = solve(pegs, holes, current_move, no_solution)

            if result is None:
                undo_move(last_move, pegs, holes)  # backtracking

    return result


def create_board():
    initial_hole = (5, 1)
    holes = set()
    holes.add(initial_hole)

    pegs = set([
        (1, 0), (4, 0),
        (0, 1), (1, 1), (2, 1), (3, 1), (4, 1),
        (1, 2), (4, 2),
        (1, 3), (4, 3),
        (0, 4), (1, 4), (2, 4), (3, 4), (4, 4), (5, 4),
        (1, 5), (4, 5)
    ])

    return pegs, holes


def valid_moves(pegs, holes):
    result = list()

    for x, y in holes:
        if (x-1, y) in pegs and (x-2, y) in pegs:
            result.append(Node({""move"": (x-2, y), ""in"": (x, y), ""remove"": (x-1, y)}))
        if (x+1, y) in pegs and (x+2, y) in pegs:
            result.append(Node({""move"": (x+2, y), ""in"": (x, y), ""remove"": (x+1, y)}))
        if (x, y-1) in pegs and (x, y-2) in pegs:
            result.append(Node({""move"": (x, y-2), ""in"": (x, y), ""remove"": (x, y-1)}))
        if (x, y+1) in pegs and (x, y+2) in pegs:
            result.append(Node({""move"": (x, y+2), ""in"": (x, y), ""remove"": (x, y+1)}))

    return result


def apply_move(node, pegs, holes):
    move = node.name
    old_pos = move.get(""move"")
    new_pos = move.get(""in"")
    eat_pos = move.get(""remove"")

    pegs.remove(old_pos)
    holes.add(old_pos)

    pegs.add(new_pos)
    holes.remove(new_pos)

    pegs.remove(eat_pos)
    holes.add(eat_pos)


def undo_move(node, pegs, holes):
    move = node.name
    old_pos = move.get(""move"")
    new_pos = move.get(""in"")
    eat_pos = move.get(""remove"")

    pegs.add(old_pos)
    holes.remove(old_pos)

    pegs.remove(new_pos)
    holes.add(new_pos)

    pegs.add(eat_pos)
    holes.remove(eat_pos)


# pegs, holes = create_6x6_square_board()
pegs, holes = create_board()


print(test_solve(pegs, holes, Node(""start""), dict(), (5, 1)))
```
",2023-12-18T10:55:39+00:00
comp-think/2023-2024,"Lecture ""Organising information: trees"", exercise 2",frammenti,"```python
from anytree import Node
from tree_instructions import *

def test_breadth_first_visit_it(root_node, expected):
    return breadth_first_visit_it(root_node) == expected

def breadth_first_visit_it(root_node):
    tree_list = []
    tree_list.append(root_node)
    while len(root_node.children) > 0:
        for child in root_node.children:
            tree_list.append(child)
            for grandchild in child.children:
                grandchild.parent = root_node
            child.parent = None
    return tree_list

test_list = [book, chapter_1, chapter_2, text_8, paragraph_1, paragraph_2, paragraph_3, text_7, text_1, quotation_1, text_3, quotation_2, text_5, text_6, text_2, text_4]

print(test_breadth_first_visit_it(book, test_list))
```",2023-12-11T18:58:43+00:00
comp-think/2023-2024,"Lecture ""Organising information: trees"", exercise 2",Liber-R,"
![Screenshot 2023-12-13 163334](https://github.com/comp-think/2023-2024/assets/132198967/6d969fe3-8c08-4adc-bc86-835a98ed563c)


",2023-12-13T14:42:07+00:00
comp-think/2023-2024,"Lecture ""Organising information: trees"", exercise 2",qwindici,"**Functions:**
```
from collections import deque 

def breadth_first_visit_iteration(root_node):
   q = deque([root_node])
   result = [root_node]

   while q:
      current_node = q.popleft()
      q.extend(current_node.children)
      result.extend(current_node.children)
   
   return result


def test_breadth_first_visit_iteration(root_node, expected):
   if breadth_first_visit_iteration(root_node) == expected:
      return True
   else:
      return False
   
test_breadth_first_visit_iteration(book, [book, chapter_1, chapter_2, text_8, paragraph_1, paragraph_2, paragraph_3, text_7, text_1, quotation_1, text_3, quotation_2, text_5, text_6, text_2, text_4]) # True
test_breadth_first_visit_iteration(one, [one, two, three, four, five, six, seven, eight, nine, ten, eleven, twelve, thirteen, fourteen, fifteen]) # True
test_breadth_first_visit_iteration(one_node, [one_node]) # True

```

**Trees:** 
```
from anytree import Node, RenderTree

book = Node(""book"")
chapter_1 = Node(""chapter"", book)
chapter_2 = Node(""chapter"", book)
paragraph_1 = Node(""paragraph"", chapter_1)
text_1 = Node(
    ""Alice was beginning to get very tired of sitting by ""
    ""her sister on the bank, and of having nothing to do: ""
    ""once or twice she had peeped into the book her sister ""
    ""was reading, but it had no pictures or conversations ""
    ""in it, "",
    paragraph_1,
)
quotation_1 = Node(""quotation"", paragraph_1)
text_2 = Node(""“and what is the use of a book,”"", quotation_1)
text_3 = Node("" thought Alice, "", paragraph_1)
quotation_2 = Node(""quotation"", paragraph_1)
text_4 = Node(""“without pictures or conversations?”"", quotation_2)
paragraph_2 = Node(""paragraph"", chapter_1)
text_5 = Node(
    ""So she was considering in her own mind, (as well as ""
    ""she could, for the hot day made her feel very sleepy ""
    ""and stupid,) whether the pleasure of making a ""
    ""daisy-chain would be worth the trouble of getting up ""
    ""and picking the daisies, when suddenly a white rabbit ""
    ""with pink eyes ran close by her."",
    paragraph_2,
)
paragraph_3 = Node(""paragraph"", chapter_1)
text_6 = Node(""..."", paragraph_3)
text_7 = Node(""..."", chapter_2)
text_8 = Node(""..."", book)


one = Node(""1"")
# children of one
two = Node(""2"", one)
three = Node(""3"", one)
four = Node(""4"", one)
# children of 2
five = Node(""5"", two)
six = Node(""6"", two)
# children of 3
seven = Node(""7"", three)
eight = Node(""8"", three)
nine = Node(""9"", three)
# children of 4
ten = Node(""10"", four)
eleven = Node(""11"", four)
# children of 5
twelve = Node(""12"", five)
# children of 7
thirteen = Node(""13"", seven)
fourteen = Node(""14"", seven)
# children of 9
fifteen = Node(""15"", nine)

print(RenderTree(one))


one_node = Node('only node')
```
",2023-12-14T15:14:58+00:00
comp-think/2023-2024,"Lecture ""Organising information: trees"", exercise 2",rufferbaraldi,"```
from anytree import Node
from anytree import RenderTree
from collections import deque

def test_breadth_first_visit(root_node, expected):
    result = breadth_first_visit(root_node)
    if expected == result:
        return True
    else:
        return False
    
def breadth_first_visit(root_node):
    result = []
    queue = deque([root_node])

    while queue:
        current_node = queue.popleft()
        result.append(current_node)
        for child in current_node.children:
            queue.append(child)

    return result


# Tests
book = Node(""book"")
chapter_1 = Node(""chapter1"", book)
chapter_2 = Node(""chapter2"", book)
paragraph_1 = Node(""paragraph1"", chapter_1)
paragraph_2 = Node(""paragraph2"", chapter_1)
paragraph_3 = Node(""paragraph3"", chapter_1)
text_1 = Node(""text1"", paragraph_1)
text_2 = Node(""text2"", paragraph_1)
text_3 = Node(""text3"", paragraph_2)
text_4 = Node(""text4"", paragraph_3)
text_5 = Node(""text5"", chapter_2)
text_6 = Node(""text6"", book)


renderer = RenderTree(book)

print(test_breadth_first_visit(book, [book, chapter_1, chapter_2, text_6, paragraph_1, paragraph_2, paragraph_3, text_5, text_1, text_2, text_3, text_4]))
print(renderer)
```",2023-12-14T21:03:12+00:00
comp-think/2023-2024,"Lecture ""Organising information: trees"", exercise 1",vattelalberto,"I used the property _height_ for trees, which counts how many nodes are left from to reach a leaf node. Was there another way?
```python
from anytree import Node, RenderTree

def test_breadth_first_visit(root_node, expected):
    result = breadth_first_visit(root_node)
    if expected == result:
        return True
    else:
        return False

def breadth_first_visit(root_node):
    result_list = list()
    h = root_node.height
    for i in range(0, h+1):
        append_nodes(root_node, i, result_list)
    return result_list

def append_nodes(root_node, level, list):
    children = root_node.children
    if level == 0:
        list.append(root_node)
    for child in children:
        append_nodes(child, level-1, list)

book = Node(""book"")
chapter_1 = Node(""chapter"", book)
chapter_2 = Node(""chapter"", book)
chapter_3 = Node(""chapter"", book)
paragraph_1 = Node(""paragraph"", chapter_1)
paragraph_2 = Node(""paragraph"", chapter_1)
paragraph_3 = Node(""paragraph"", chapter_1)
paragraph_4 = Node(""paragraph"", chapter_2)
text_1 = Node(""text"", paragraph_1)
text_2 = Node(""text"", paragraph_2)
text_3 = Node(""text"", paragraph_3)
text_4 = Node(""text"", paragraph_4)
text_5 = Node(""text"", chapter_3)

print(test_breadth_first_visit(book, [book, chapter_1, chapter_2, chapter_3, paragraph_1, paragraph_2, paragraph_3, paragraph_4, text_5, text_1, text_2, text_3, text_4]))
```

",2023-12-11T13:20:51+00:00
comp-think/2023-2024,"Lecture ""Organising information: trees"", exercise 1",frammenti,"```python
from anytree import Node
from tree_instructions import *

def test_breadth_first_visit(root_node, expected):
    return breadth_first_visit(root_node) == expected

def breadth_first_visit(root_node):
    tree_list = []
    if root_node.parent ==  None:
        tree_list.append(root_node)
    if len(root_node.children) == 0:
        root_node.parent = None
        return tree_list
    else:
        for child in root_node.children:
            tree_list.append(child)
            for grandchild in child.children:
                grandchild.parent = root_node
            child.parent = None
            if root_node.parent ==  None:
                root_node.parent = child
        return tree_list + breadth_first_visit(root_node)

test_list = [book, chapter_1, chapter_2, text_8, paragraph_1, paragraph_2, paragraph_3, text_7, text_1, quotation_1, text_3, quotation_2, text_5, text_6, text_2, text_4]

print(test_breadth_first_visit(book, test_list))
```",2023-12-11T14:10:48+00:00
comp-think/2023-2024,"Lecture ""Organising information: trees"", exercise 1",qwindici,"Solution together with @valentinabertelli

```
from anytree import Node, RenderTree


def breadth_first_visit(root_node):
    result = [root_node] + extend_children(list(root_node.children))
    return result


def extend_children(children_list):
    new_children_list = []
    for node in children_list:
        new_children_list += list(node.children)
    if new_children_list:
        return children_list + extend_children(new_children_list)
    elif new_children_list == []:
        return children_list


def test_breadth_first_visit(root_node, expected):
    if breadth_first_visit(root_node) == expected:
        return True
    else:
        return False


# book tree
print(
    test_breadth_first_visit(
        book,
        [
            book,
            chapter_1,
            chapter_2,
            text_8,
            paragraph_1,
            paragraph_2,
            paragraph_3,
            text_7,
            text_1,
            quotation_1,
            text_3,
            quotation_2,
            text_5,
            text_6,
            text_2,
            text_4,
        ],
    )
)

# one node tree
one_tree = Node(""first node"")

# numbers tree
one = Node(""1"")
# children of one
two = Node(""2"", one)
three = Node(""3"", one)
four = Node(""4"", one)
# children of 2
five = Node(""5"", two)
six = Node(""6"", two)
# children of 3
seven = Node(""7"", three)
eight = Node(""8"", three)
nine = Node(""9"", three)
# children of 4
ten = Node(""10"", four)
eleven = Node(""11"", four)
# children of 5
twelve = Node(""12"", five)
# children of 7
thirteen = Node(""13"", seven)
fourteen = Node(""14"", seven)
# children of 9
fifteen = Node(""15"", nine)


# test one node tree
print(test_breadth_first_visit(one_tree, [one_tree]))
# test number tree
print(
    test_breadth_first_visit(
        one,
        [
            one,
            two,
            three,
            four,
            five,
            six,
            seven,
            eight,
            nine,
            ten,
            eleven,
            twelve,
            thirteen,
            fourteen,
            fifteen,
        ],
    )
)
```",2023-12-12T17:08:46+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 2",frammenti,"```python
def test_exponentiation_dp(n, e, solution_dict):
    expected_dict = {}
    unexpected_dict = {}
    for i in range(e, -1, -1):
        if (n, i) in solution_dict:
            for j in range(i - 1, -1, -1):
                if (n, j) not in solution_dict:
                    unexpected_dict[(n, j)] = n ** j
            break
        expected_dict[(n, i)] = n ** i
    expected = n ** e
    result = exponentiation_dp(n, e, solution_dict)
    test_1 = result == expected
    test_2 = expected_dict.items() <= solution_dict.items()
    test_3 = unexpected_dict.items().isdisjoint(solution_dict.items())
    return test_1 and test_2 and test_3

def exponentiation_dp(n, e, solution_dict):
    key = (n, e)
    if key not in solution_dict:
        if e == 0:
            solution_dict[key] = 1
        else:
            result = n * exponentiation_dp(n, e - 1, solution_dict)
            solution_dict[key] = result
    return solution_dict[key]

solution_dict = {}

print(test_exponentiation_dp(0,0,solution_dict))
print(test_exponentiation_dp(3,0,solution_dict))
print(test_exponentiation_dp(0,3,solution_dict))
print(test_exponentiation_dp(3,2,solution_dict))
print(test_exponentiation_dp(3,4,solution_dict))

print(solution_dict)
# {(0, 0): 1, (2, 0): 1, (3, 0): 1, (0, 1): 0, (0, 2): 0, (0, 3): 0, (3, 1): 3, (3, 2): 9, (3, 3): 27, (3, 4): 81}
```",2023-12-04T09:11:56+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 2",valentinabertelli,"```
def test_exponentiation(base_number, exponent, solution_dict, expected):
    result = exponentiation(base_number, exponent, solution_dict) 
    if expected == result:
        return True
    else:
        return False

def exponentiation(base_number, exponent, solution_dict):
    if (base_number, exponent) not in solution_dict:
        if exponent == 0:
            solution_dict[(base_number, exponent)] = 1
        elif exponent == 1:
            solution_dict[(base_number, exponent)] = base_number
        else:
            if base_number == 0:
                solution_dict[(base_number, exponent)] = 0
            else:
                solution_dict[(base_number, exponent)] = base_number * exponentiation(base_number, exponent - 1, solution_dict)
    return solution_dict.get((base_number, exponent))
    
print(test_exponentiation(0, 2, dict(), 0)) #True
print(test_exponentiation(3, 4, dict(), 81)) #True
print(test_exponentiation(5, 0, dict(), 1)) #True
print(test_exponentiation(7, 1, dict(), 7)) #True

```",2023-12-04T14:26:26+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 2",qwindici,"```
def exponentiation(n, e, d):
    if e not in d:
        if e == 0:
            d[e] = 1
        elif e == 1:
            d[e] = n
        else:
            d[e] = n * exponentiation(n, e - 1, d)
    return d[e]


def test_exponentation(n, e, d, expected):
    if exponentiation(n, e, d) == expected:
        return True
    else:
        return False


print(test_exponentation(5, 1, {}, 5))
print(test_exponentation(5, 2, {}, 25))
print(test_exponentation(2, 8, {}, 256))
print(test_exponentation(2, 0, {}, 1))

```",2023-12-04T16:54:41+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 2",vattelalberto,"```python
def test_exponentiation(base_number, exponent, d, expected):
    result = exponentiation(base_number, exponent, d)
    if result == expected:
        return True
    else:
        return False

def exponentiation(base_number, exponent, d):
    if exponent not in d:
        if exponent == 0:
            d[exponent] = 1
        else:
            d[exponent] = base_number * exponentiation(base_number, exponent - 1, d)
    return d[exponent]

print(test_exponentiation(3, 4, {}, 81))
print(test_exponentiation(17, 1, {}, 17))
print(test_exponentiation(2, 0, {}, 1))
```",2023-12-06T11:58:51+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 2",Liber-R,"![Screenshot 2023-12-09 133555](https://github.com/comp-think/2023-2024/assets/132198967/0ca89252-a426-4086-88c1-4c3f74c8c48e)
",2023-12-09T12:36:21+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 2",rufferbaraldi,"```
def test_factorial(num, dict, expected):
    result = factorial(num, dict)
    if expected == result:
        return True
    else:
        return False
new_dict = {}
def factorial(num, dict):
    if num not in dict:
        if num == 1:
            dict[num] = 1
        else:
            dict[num]= num * factorial(num-1, dict)
    return dict.get(num)

print(test_factorial(10, new_dict, 3628800))
print(test_factorial(6, new_dict, 720))
print(test_factorial(3, new_dict, 6))
```",2023-12-09T21:58:51+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 2",CarlaMenegat,"![Captura de Tela 2023-12-10 às 16 37 51](https://github.com/comp-think/2023-2024/assets/146187896/05f1906b-dc59-4104-928b-e44ca5bb0dba)
",2023-12-10T15:38:30+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 2",Chiaramartina,"<img width=""875"" alt=""Schermata 2023-12-10 alle 17 20 40"" src=""https://github.com/comp-think/2023-2024/assets/106493111/30f4271a-8534-4ef7-9c66-7189614fdc05"">
",2023-12-10T16:21:21+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 2",essepuntato,"Thanks for your take. Just a few comments:
- @qwindici @vattelalberto @CarlaMenegat @Chiaramartina, there is a similar problem to that I've seen in the previous exercise.",2023-12-10T17:37:24+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 2",matildepassafaro,"```
# test case for the function
def test_exponentiation(base_number, exponent, d, expected):
    result = exponentiation(base_number, exponent, d)
    if expected == result:
        return True
    else:
        return False

# code for the function
def exponentiation(base_number, exponent, d):
    # checking if solutions exist
    my_key = (base_number, exponent)
    if my_key not in d:
        # base case 1
        if exponent == 1:
            d[my_key] = base_number
        # base case 2
        elif exponent == 0:
            d[my_key] = 1
        # recursive step
        else:
            d[my_key] = base_number * exponentiation(base_number, exponent - 1, d)
    
    return d.get(my_key)

# tests
print(test_exponentiation(3, 4, dict(), 81))
print(test_exponentiation(5, 1, dict(), 5))
print(test_exponentiation(11, 0, dict(), 1))
print(test_exponentiation(2, 5, dict(), 32))
print(test_exponentiation(2, 4, dict(), 16))
```",2023-12-10T18:46:19+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 2",Sergpoipoip,"```
def test_fact(n, solution_dict, expected):
    return fact(n, solution_dict) == expected

def fact(n, solution_dict):
    if n not in solution_dict:
        if n == 0:
            solution_dict[n] = 1
        else:
            solution_dict[n] = fact(n-1, solution_dict) * n
    return solution_dict.get(n)

solution_dict = {}
print(test_fact(0, solution_dict, 1))
print(test_fact(5, solution_dict, 120))
print(test_fact(20, solution_dict, 2432902008176640000))
```",2023-12-11T12:30:24+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 2",valetedd,"```
def test_exponentiation_dp(n, m, d, expected):
    result = exponentiation_dp(n, m, d)
    if expected == result:
        return True
    else:
        return False

def exponentiation_dp(n, e, d):
    if n ** e not in d:
        if e == 0:
            d[n ** e] = 1
        elif e > 0:
            d[n ** e] = n * exponentiation_dp(n, e - 1, d)
        else:
            d[n ** e] = 1/n * exponentiation_dp(n, e + 1, d)  

    return d.get(n ** e)


#tests
print(test_exponentiation_dp(1, 1, empty_dic, 1))
print(test_exponentiation_dp(2, 3, empty_dic, 8))
print(test_exponentiation_dp(-3, 4, empty_dic, 81))
print(test_exponentiation_dp(9, -1, empty_dic, 1/9))
print(test_exponentiation_dp(3, -3, empty_dic, 1/27))
print(test_exponentiation_dp(-3, -2, empty_dic,1/9))
print(test_exponentiation_dp(2, -4, empty_dic, 1/16))
print(test_exponentiation_dp(0, 4, empty_dic, 0))

```",2023-12-11T22:03:51+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 1",frammenti,"Improved version with only one for cycle in the dictionary
```python
def test_multiplication_dp2(n1, n2, solution_dict):
    expected = n1 * n2
    result = multiplication_dp2(n1, n2, solution_dict)
    return result == expected

def multiplication_dp2(n1, n2, solution_dict):
    if n1 < n2:
        n1, n2 = n2, n1
    # Computation of shortest route to target
    yn = n1 + n2 # generation
    xn = n1 - n2 # position in generation
    s = n2 # steps
    t1, t2 = n1, 0 # target coordinates
    for (d1, d2) in solution_dict:
        if d1 < d2:
            d1, d2 = d2, d1
        yd = d1 + d2
        xd = d1 - d2
        if 0 <= abs(xn - xd) <= 2:
            sd = abs(yn - yd)
        else:
            sd = abs(xn - xd)
        # If it takes fewer steps to get to dictionary item considered, target is changed
        if sd < s:
            s = sd
            t1, t2 = d1, d2
    # Steps split for n1 and n2
    s1 = t1 - n1
    s2 = t2 - n2
    # Recursive step
    return multiplication(n1, n2, s1, s2, solution_dict)

def multiplication(n1, n2, s1, s2, solution_dict):
    key = (n1, n2)
    rkey = (n2, n1)
    if key not in solution_dict and rkey not in solution_dict:
        if n2 == 0:
            solution_dict[key] = 0
        elif s1 < 0:
            solution_dict[key] = n2 + multiplication(n1 - 1, n2, s1 + 1, s2, solution_dict)
        elif s2 < 0:
            solution_dict[key] = n1 + multiplication(n1, n2 - 1, s1, s2 + 1, solution_dict)
        elif s1 > 0:
            solution_dict[key] = multiplication(n1 + 1, n2, s1 - 1, s2, solution_dict) - n2
        elif s2 > 0:
            solution_dict[key] = multiplication(n1, n2 + 1, s1, s2 - 1, solution_dict) - n1
    elif rkey in solution_dict:
        solution_dict[key] = solution_dict.pop(rkey)
    return solution_dict[key]

solution_dict1 = {(7, 5): 35}
solution_dict2 = {(8, 5): 40}
solution_dict3 = {(7, 5): 35, (8, 5): 40}
solution_dict4 = {(13, 4): 52}
solution_dict5 = {(13, 2): 26}
solution_dict6 = {(3, 4): 12}
solution_dict7 = {(2, 2): 4}

print(test_multiplication_dp2(7, 7, solution_dict1))
print(test_multiplication_dp2(9, 7, solution_dict1))
print(test_multiplication_dp2(9, 7, solution_dict2))
print(test_multiplication_dp2(10, 7, solution_dict3))
print(test_multiplication_dp2(10, 7, solution_dict4))
print(test_multiplication_dp2(10, 7, solution_dict5))
print(test_multiplication_dp2(5, 5, solution_dict6))
print(test_multiplication_dp2(5, 5, solution_dict7))

print(solution_dict1)
# {(7, 5): 35, (7, 6): 42, (7, 7): 49, (8, 7): 56, (9, 7): 63}
print(solution_dict2)
# {(8, 5): 40, (8, 6): 48, (8, 7): 56, (9, 7): 63}
print(solution_dict3)
# {(7, 5): 35, (8, 5): 40, (8, 6): 48, (8, 7): 56, (9, 7): 63, (10, 7): 70}
print(solution_dict4)
# {(13, 4): 52, (12, 4): 48, (11, 4): 44, (10, 4): 40, (10, 5): 50, (10, 6): 60, (10, 7): 70}
print(solution_dict5)
# {(13, 2): 26, (10, 0): 0, (10, 1): 10, (10, 2): 20, (10, 3): 30, (10, 4): 40, (10, 5): 50, (10, 6): 60, (10, 7): 70}
print(solution_dict6)
# {(4, 3): 12, (4, 4): 16, (4, 5): 20, (5, 5): 25}
print(solution_dict7)
# {(2, 2): 4, (5, 0): 0, (5, 1): 5, (5, 2): 10, (5, 3): 15, (5, 4): 20, (5, 5): 25}
```
Old version
```python
def test_multiplication_dp(n1, n2, solution_dict):
    expected = n1 * n2
    result = multiplication_dp(n1, n2, solution_dict)
    return result == expected

def multiplication_dp(n1, n2, solution_dict):
    n1, n2 = factor_swap(n1, n2, solution_dict)
    key = (n1, n2)
    rkey = (n2, n1)
    if key not in solution_dict and rkey not in solution_dict:
        if n2 == 0:
            solution_dict[key] = 0
        else:
            result = n1 + multiplication_dp(n1, n2 - 1, solution_dict)
            solution_dict[key] = result
    elif rkey in solution_dict:
        result = solution_dict.pop(rkey)
        solution_dict[key] = result
    return solution_dict[key]

def factor_swap(n1, n2, solution_dict):
    if n1 != n2:
        for ni in range(n1, -1, -1):
            if (ni, n2) in solution_dict or (n2, ni) in solution_dict:
                delta1 = n1 - ni
                break
        else:
            delta1 = n1
        for ni in range(n2, -1, -1):
            if (n1, ni) in solution_dict or (ni, n1) in solution_dict:
                delta2 = n2 - ni
                break
        else:
            delta2 = n2
        if delta1 < delta2:
            n1, n2 = n2, n1
    return n1, n2

solution_dict1 = {(7, 5): 35}
solution_dict2 = {(8, 5): 40}
solution_dict3 = {(7, 5): 35, (8, 5): 40}

print(test_multiplication_dp(7, 7, solution_dict1))
print(test_multiplication_dp(9, 7, solution_dict1))
print(test_multiplication_dp(9, 7, solution_dict2))
print(test_multiplication_dp(10, 7, solution_dict3))

print(solution_dict1)
# {(7, 5): 35, (7, 6): 42, (7, 7): 49, (7, 8): 56, (7, 9): 63}
print(solution_dict2)
# {(5, 8): 40, (5, 9): 45, (9, 6): 54, (9, 7): 63}
print(solution_dict3)
# {(7, 5): 35, (8, 5): 40, (8, 6): 48, (8, 7): 56, (7, 9): 63, (7, 10): 70}
```",2023-12-04T09:10:23+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 1",katyakrsn,"```
def test_multiplication(int_1, int_2, solution_dict, expected):
    result = multiplication(int_1, int_2, solution_dict)
    if expected == result:
        return True
    else:
        return False


def multiplication(int_1, int_2, solution_dict):
    if (int_1, int_2) not in solution_dict:
        if int_2 == 0:  # base case 1
            solution_dict[int_1, int_2] = 0
        elif int_2 == 1:  # base case 2
            solution_dict[int_1, int_2] = int_1
        else:
            solution_dict[int_1, int_2] = int_1 + multiplication(int_1, int_2 - 1, solution_dict)
    return solution_dict.get((int_1, int_2), 0)


print(test_multiplication(3, 4, {}, 12))  # test case: 3 * 4 = 12
print(test_multiplication(5, 0, {}, 0))  # test case: 5 * 0 = 0
print(test_multiplication(0, 9, {}, 0))  # test case: 0 * 9 = 0

```",2023-12-04T12:00:15+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 1",valentinabertelli,"```
def test_multiplication(int_1, int_2, solution_dict, expected):
    result = multiplication(int_1, int_2, solution_dict)
    if expected == result:
        return True
    else:
        return False

def multiplication(int_1, int_2, solution_dict):
    if int_2 not in solution_dict:
        if int_2 == 0:
            solution_dict[int_2] = 0
        else:
            solution_dict[int_2] = int_1 + multiplication(int_1, int_2 - 1, solution_dict)
    return solution_dict.get(int_2)

print (test_multiplication(3, 4, dict(), 12)) #True
print (test_multiplication(5, 10, dict(), 50)) #True
print (test_multiplication(8, 2, dict(), 16)) #True
print (test_multiplication(3, 0, dict(), 0)) #True
```",2023-12-04T14:09:26+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 1",qwindici,"
**New solution using the same dictionary in every test**
```
def multiplication(int_1, int_2, solution_dict):
    dict_key = frozenset([int_1, int_2])
    if dict_key not in solution_dict:
        if int_2 == 0:
            solution_dict[dict_key] = 0
        else:
            solution_dict[dict_key] = int_1 + multiplication(
                int_1, int_2 - 1, solution_dict
            )
    return solution_dict.get(dict_key)



def test_multiplication(int_1, int_2, solution_dict, expected):
    if multiplication(int_1, int_2, solution_dict) == expected:
        return True
    else:
        return False


my_dict = {}
print(test_multiplication(3, 10, my_dict, 30))
print(test_multiplication(0, 2, my_dict, 0))
print(test_multiplication(5, 7, my_dict, 35))
print(test_multiplication(15, 4, my_dict, 60))
print(test_multiplication(2, 7, my_dict, 14))
print(my_dict)
```


**Same idea using tuples**

```
def multiplication(int_1, int_2, solution_dict):
    dict_key = (int_1, int_2)
    if dict_key not in solution_dict:
        if int_2 == 0:
            solution_dict[dict_key] = 0
        else:
            solution_dict[dict_key] = int_1 + multiplication(
                int_1, int_2 - 1, solution_dict
            )
    return solution_dict.get(dict_key)


def test_multiplication(int_1, int_2, solution_dict, expected):
    if multiplication(int_1, int_2, solution_dict) == expected:
        return True
    else:
        return False


my_dict = {}
print(test_multiplication(3, 10, my_dict, 30))
print(test_multiplication(0, 2, my_dict, 0))
print(test_multiplication(5, 7, my_dict, 35))
print(test_multiplication(15, 4, my_dict, 60))
print(test_multiplication(2, 7, my_dict, 14))
print(my_dict)
```

**Old version:** 

```
def multiplication(int_1, int_2, solution_dict):
    if int_2 not in solution_dict:
        if int_2 == 0:
            solution_dict[0] = 0
        else:
            solution_dict[int_2] = int_1 + multiplication(
                int_1, int_2 - 1, solution_dict
            )
    return solution_dict.get(int_2)


def test_multiplication(int_1, int_2, solution_dict, expected):
    if multiplication(int_1, int_2, solution_dict) == expected:
        return True
    else:
        return False


print(test_multiplication(3, 10, {}, 30))
print(test_multiplication(0, 2, {}, 0))
print(test_multiplication(5, 7, {}, 35))
print(test_multiplication(15, 4, {}, 60))
```",2023-12-04T16:26:55+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 1",vattelalberto,"```python
def test_multiplication(int_1, int_2, solution_dict, expected):
    result = multiplication(int_1, int_2, solution_dict)
    if expected == result:
        return True
    else:
        return False

def multiplication(int_1, int_2, solution_dict):
    if int_2 not in solution_dict:
        if int_2 == 0:
            solution_dict[int_2] = 0
        else:
            solution_dict[int_2] = int_1 + multiplication(int_1, int_2 - 1, solution_dict)
    
    return solution_dict[int_2]

print(test_multiplication(0, 0, dict(), 0))
print(test_multiplication(1, 0, dict(), 0))
print(test_multiplication(5, 7, dict(), 35))
```",2023-12-06T11:40:24+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 1",Liber-R,"![Screenshot 2023-12-09 132945](https://github.com/comp-think/2023-2024/assets/132198967/9efd35dd-d532-444d-aa14-5143c988944e)
",2023-12-09T12:30:53+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 1",simocasaz,"```
def test_multiplication(int_1, int_2, solution_dict, expected):
    result = multiplication(int_1, int_2, solution_dict)
    if result == expected:
        return True
    else:
        return False

            
def multiplication(int_1, int_2, solution_dict):
    if int_2 not in solution_dict:
        if int_2 == 0:
            solution_dict[int_2] = 0
        else:
            solution_dict[int_2] = int_1 + multiplication(int_1, int_2 - 1, solution_dict)
    
    return solution_dict.get(int_2)

print(test_multiplication(6, 5, dict(), 30))
print(test_multiplication(6, 8, dict(), 48))
print(test_multiplication(8, 0, dict(), 0))
print(test_multiplication(0, 0, dict(), 0))
print(test_multiplication(34, 523, dict(), 17782))
print(test_multiplication(5, 32, dict(), 160))
```",2023-12-09T18:08:27+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 1",rufferbaraldi,"```
def test_multiplication(int_1, int_2, solution_dict, expected):
    result = multiplication(int_1, int_2, solution_dict)
    if expected == result:
        return True
    else:
        return False

def multiplication(int_1, int_2, solution_dict):
    if int_2 not in solution_dict:
        if int_2 == 0:
            solution_dict[int_2] = 0
        else: 
            solution_dict[int_2] = int_1 + multiplication(int_1, int_2 - 1, solution_dict)
    return solution_dict.get(int_2)

print(test_multiplication(4, 3, dict(), 12))
print(test_multiplication(5, 2, dict(), 10)) 
print (test_multiplication(7, 2, dict(), 14))
print (test_multiplication(2, 0, dict(), 0))
```",2023-12-09T21:40:42+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 1",CarlaMenegat,"![Captura de Tela 2023-12-10 às 16 23 32](https://github.com/comp-think/2023-2024/assets/146187896/ee89d22f-c2c5-4aec-8877-4078cb1c1a5a)
",2023-12-10T15:24:12+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 1",Chiaramartina,"<img width=""798"" alt=""Schermata 2023-12-10 alle 17 14 57"" src=""https://github.com/comp-think/2023-2024/assets/106493111/7bd5ac81-104b-4c41-b24d-41c77065c9f3"">
",2023-12-10T16:15:32+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 1",essepuntato,"Thanks for your take. Just a few comments:
- @qwindici @vattelalberto @CarlaMenegat, try to run an additional, last test, i.e. `print(test_multiplication(2, 7, my_dict, 14))` by passing a dictionary that will be modified by all the previous tests.
- @simocasaz, try to run an additional, last test, i.e. `print(test_multiplication(2, 32, my_dict, 64))` by passing a dictionary that will be modified by all the previous tests.
- @rufferbaraldi, try to run the tests by always passing the same dictionary (that will be modified in each test.
- @Chiaramartina, try to run an additional, last test, i.e. `print(test_multiplication(2, 8, my_dict, 16))` by passing a dictionary that will be modified by all the previous tests.",2023-12-10T17:30:09+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 1",MariaFrancesca6,"```py
def test_multiplication(int_1,int_2,solution_dict,expected):
    result = multiplication(int_1, int_2, solution_dict)
    if result == expected:
        return True
    else:
        False   
    
def multiplication(int_1, int_2, solution_dict):
    if (int_1,int_2) not in solution_dict:
        if int_2 == 0:
            solution_dict[int_2] = 0
        else:
            solution_dict[int_2] = int_1 + multiplication(int_1, int_2 - 1, solution_dict)  
    
    return solution_dict.get(int_2)
    
print(test_multiplication(5,4,{},20))
print(test_multiplication(3,0,{},0))
```",2023-12-10T18:31:00+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 1",matildepassafaro,"```
# test case for the function
def test_multiplication(int_1, int_2, solution_dict, expected):
    result = multiplication(int_1, int_2, solution_dict)
    if expected == result:
        return True
    else:
        return False

# code for the function
def multiplication(int_1, int_2, solution_dict):
    # checking if solution exists
    my_key = (int_1, int_2)
    if my_key not in solution_dict:
        # base case
        if int_1 == 0 or int_2 == 0:
            solution_dict[my_key] = 0
        # recursive step
        else:
            solution_dict[my_key] = int_1 + multiplication(int_1, int_2 - 1, solution_dict)

    return solution_dict.get(my_key)

# tests
print(test_multiplication(3, 4, dict(), 12))
print(test_multiplication(7, 8, dict(), 56))
print(test_multiplication(0, 0, dict(), 0))
print(test_multiplication(0, 3, dict(), 0))
```",2023-12-10T18:42:58+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 1",Sergpoipoip,"```
def test_multiplication(int_1, int_2, solution_dict, expected):
    return multiplication(int_1, int_2, solution_dict) == expected

def multiplication(int_1, int_2, solution_dict):
    if int_1 < int_2:
        int_1, int_2 = int_2, int_1
    if (int_1, int_2) not in solution_dict:
        if int_2 == 0:
            solution_dict[int_1, int_2] = 0
        else:
            solution_dict[int_1, int_2] = multiplication(int_1, int_2 - 1, solution_dict) + int_1
    return solution_dict.get((int_1, int_2))

solution_dict = {}
print(test_multiplication(3, 10, solution_dict, 30))
print(test_multiplication(0, 0, solution_dict, 0))
print(test_multiplication(11, 1, solution_dict, 11))
```",2023-12-11T10:15:41+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 1",vattelalberto,"Revised version of my algorithm, now that I actually understood the purpose of using a dictionary
```python
def test_multiplication(int_1, int_2, solution_dict, expected):
    result = multiplication(int_1, int_2, solution_dict)
    if expected == result:
        return True
    else:
        return False

def multiplication(int_1, int_2, solution_dict):
    #to avoid redundant entries in the dictionary the first element is always the greater
    if int_1 < int_2:
         return multiplication(int_2, int_1, solution_dict)
    if (int_1, int_2) not in solution_dict:
        #check for basic solution when multiplied by 0
        if int_2 == 0:
            solution_dict[(int_1, int_2)] = 0
        #check for basic solution when multiplied by 1
        elif int_2 == 1:
            solution_dict[(int_1, int_2)] = int_1
        else:
            solution_dict[(int_1, int_2)] = int_1 + multiplication(int_1, int_2 - 1, solution_dict)
    
    return solution_dict[(int_1, int_2)]

my_dict = dict()

print(test_multiplication(0, 0, my_dict, 0))
print(test_multiplication(1, 0, my_dict, 0))
print(test_multiplication(5, 7, my_dict, 35))
print(test_multiplication(2, 7, my_dict, 14))
print(test_multiplication(7, 2, my_dict, 14))
```",2023-12-11T12:25:15+00:00
comp-think/2023-2024,"Lecture ""Dynamic programming algorithms"", exercise 1",valetedd,"```
def test_multiplication_dp(n, m, d, expected):
    result = multiplication_dp(n, m, d)
    if expected == result:
        return True
    else:
        return False
# Code of the function
def multiplication_dp(n, m, d):
# Checking if a solution exists
    if n * m not in d:
        if m == 0 or n == 0: # base case 
            d[n * m] = 0 
        else: # recursive step
        # the dictionary will be passed as input of the recursive
        # calls of the function
            d[n * m] = n + multiplication_dp(n, m - 1, d)
    return d.get(n * m)

empty_dic = {}

#tests
print(test_multiplication_dp(3, 5, empty_dic, 15))
print(test_multiplication_dp(-1, 7, empty_dic, -7))
print(test_multiplication_dp(20, 50, empty_dic, 1000))
print(test_multiplication_dp(-17, -5, empty_dic, 85))
print(test_multiplication_dp(0, 0, empty_dic, 0))
print(test_multiplication_dp(1, 1, empty_dic, 1))
```",2023-12-11T22:05:49+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 3",krzywonos,"More efficient alternative using list comprehension

```
def test_quicksort(input_list, expected):
    result = quicksort(input_list);
    if result == expected:
        print(True);
    else:
        print(False);

def quicksort(input_list):
    if len(input_list) <= 1:
        return input_list;
    pivot = input_list[len(input_list)//2]
    left = [x for x in input_list if x < pivot]
    middle = [x for x in input_list if x == pivot]
    right = [x for x in input_list if x > pivot]
    return quicksort(left) + middle + quicksort(right) 

test_quicksort([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""], [""American Gods"", ""Coraline"", ""Good Omens"", ""Neverwhere"", ""The Graveyard Book""]);
```

",2023-11-22T10:36:29+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 3",valetedd,"This algorithm is horribly inefficient, but seems to work for now. I'll keep testing.
```
#Ex 3 D&C algorithms: Quicksort algorithm
def partition(input_list, start, end, pivot_position):
    if not (start <= pivot_position <= end) or len(input_list) == 0:
        return None
    pivot_element = input_list[pivot_position]
    
    for i in input_list[start : end + 1]:
        curr_index = input_list.index(i)
        if  i > pivot_element and curr_index < pivot_position:
            input_list.remove(i)
            input_list.insert(pivot_position, i)
            pivot_position -= 1
        elif i < pivot_element and curr_index > pivot_position:
            input_list.remove(i)
            input_list.insert(pivot_position, i)
            pivot_position += 1
        else: 
            pass
    return pivot_position

def test_quicksort(input_list, start, end, expected):
    if quicksort(input_list, start, end) == expected:
        return True
    else:
        return False
    
def quicksort(input_list, start, end):
    piv_pos = partition(input_list, start, end, (end + start) // 2)
    if 0 < len(range(start, end + 1)) < 3 or piv_pos == None:
        return input_list 
    else:
        quicksort(input_list, start, piv_pos - 1)
        quicksort(input_list, piv_pos + 1, end)
        return input_list

print(test_quicksort([2,-2, 9, 7, 5, 1, 11], 0, 6, [-2, 1, 2, 5, 7, 9, 11]))
print(test_quicksort([""bobcat"", ""cat"",  ""lion"", ""deer"",""beetle"" , ""albatros""], 0, 5, ['albatros', 'beetle', 'bobcat', 'cat', 'deer', 'lion']))
print(test_quicksort(['bobcat', 'beetle', 'cat', 'deer', 'lion', 'albatros'], 0, 5, ['albatros', 'beetle', 'bobcat', 'cat', 'deer', 'lion']))
print(test_quicksort([""bobcat"", ""cat"",  ""lion"", ""deer"",""beetle"" , ""albatros""], 0, 3, ['bobcat', 'cat', 'deer', 'lion', 'beetle', 'albatros'])) 
print(test_quicksort([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""], 0, 3, ['Coraline', 'Good Omens', 'Neverwhere', 'The Graveyard Book', 'American Gods']))
print(test_quicksort([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""], 0, 4, ['American Gods', 'Coraline', 'Good Omens', 'Neverwhere', 'The Graveyard Book']))
print(test_quicksort(['Coraline', 'Coraline', 'The Graveyard Book', 'American Gods', 'Good Omens', 'Neverwhere'], 0, 4, ['American Gods', 'Coraline', 'Coraline', 'Good Omens', 'The Graveyard Book', 'Neverwhere']))
print(test_quicksort(['Coraline', 'Coraline', 'The Graveyard Book', 'American Gods', 'Good Omens', 'Neverwhere'], 0, 5, ['American Gods', 'Coraline', 'Coraline', 'Good Omens', 'Neverwhere', 'The Graveyard Book']))
```
Improved version:
```
def quicksort(input_list, start, end):
    piv_pos = partition(input_list, start, end, (end + start) // 2)
   if 0 < len(range(start, end + 1)) < 3:
        return input_list
    else:
        if (piv_pos - 1) > start:
            quicksort(input_list, start, piv_pos - 1)
        if (piv_pos + 1) < end:
            quicksort(input_list, piv_pos + 1, end)
        return input_list
```",2023-11-24T22:45:20+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 3",Liber-R,"![Screenshot 2023-11-27 084845](https://github.com/comp-think/2023-2024/assets/132198967/31100938-2998-4a8b-95e7-394ce1d2edc5)
![Screenshot 2023-11-27 084911](https://github.com/comp-think/2023-2024/assets/132198967/05200f03-c5be-43df-b745-560de077130c)
![Screenshot 2023-11-27 085151](https://github.com/comp-think/2023-2024/assets/132198967/03d46b02-7d05-49f2-9aea-0b66d201ec23)


",2023-11-26T18:35:17+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 3",frammenti,"```python
import random

def test_quicksort(input_list, start, end):
    # Input-list order is randomized to repeat the test
    random.shuffle(input_list)
    expected = input_list[:start]+sorted(input_list[start:end+1])+input_list[end+1:]
    result = quicksort(input_list, start, end)
    if expected == result:
        return True
    else:
        return False

def quicksort(input_list, start, end):
    # Partition is iterated until base case is reached: if the sliced list has length of 1, it is already ordered
    if start < end:
        # Pivot is selected randomly as suggested by ""Idea"" tutorial
        pivot_position = random.randint(start, end)
        new_position = partition(input_list, start, end, pivot_position)
        quicksort(input_list, start, new_position-1) #quicksort is end inclusive as partition is end inclusive
        quicksort(input_list, new_position+1, end)
        return input_list
    else:
        # If input_list is empty or has only one element
        return input_list

def partition(input_list, start, end, pivot_position):
    # Input conditions are no longer necessary because inputs are defined by quicksort function
    i = start - 1
    pivot = input_list.pop(pivot_position)
    for j in range(start,end):
        if input_list[j] < pivot:
            i += 1
            input_list[i], input_list[j] = input_list[j], input_list[i]
    new_position = i + 1
    input_list.insert(new_position, pivot)
    return new_position

num_list = [7, 2, 1, 8, 6, 3, 5, 4]
book_list = [""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""]
binary_list = [0, 0, 1, 1, 0, 1, 0, 0, 1]

# 5 tests full range
print(test_quicksort(list(num_list), 0, 7))
print(test_quicksort(list(num_list), 0, 7))
print(test_quicksort(list(num_list), 0, 7))
print(test_quicksort(list(num_list), 0, 7))
print(test_quicksort(list(num_list), 0, 7))
# Tests with different range
print(test_quicksort(list(num_list), 2, 5))
print(test_quicksort(list(num_list), 2, 5))
print(test_quicksort(list(num_list), 2, 5))
print(test_quicksort(list(num_list), 2, 5))
print(test_quicksort(list(num_list), 2, 5))
# Tests with range of 2, first and last positions
print(test_quicksort(list(num_list), 0, 1))
print(test_quicksort(list(num_list), 0, 1))
print(test_quicksort(list(num_list), 0, 1))
print(test_quicksort(list(num_list), 0, 1))
print(test_quicksort(list(num_list), 0, 1))
print(test_quicksort(list(num_list), 6, 7))
print(test_quicksort(list(num_list), 6, 7))
print(test_quicksort(list(num_list), 6, 7))
print(test_quicksort(list(num_list), 6, 7))
print(test_quicksort(list(num_list), 6, 7))
# Tests with other kinds of list
print(test_quicksort(list(book_list), 1, 4)) # First example
print(test_quicksort(list(binary_list), 1, 7)) # List with repetitions
print(test_quicksort([1], 0, 0)) # One-item list
print(test_quicksort([], 0, 0)) # Empty list
```",2023-11-28T10:08:15+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 3",qwindici,"```
import random

def partition(input_list, start, end, pivot_position):
    i = start - 1
    j = start
    pivot = input_list[pivot_position]
    while j <= end:
        if input_list[j] > pivot:
            j += 1
        elif input_list[j] < pivot:
            i += 1
            # swap j and i
            input_list[j], input_list[i] = input_list[i], input_list[j]
            j += 1
        else:
            j += 1
        input_list.remove(pivot)
        input_list.insert(i + 1, pivot)
        return i + 1


def quicksort(input_list, start, end):
    if not input_list:
        return []
    if start >= end:
        return
    else:
        pivot_position = random.randint(start, end)
        sorted_pivot_position = partition(input_list, start, end, pivot_position)
        # left
        quicksort(input_list, start, sorted_pivot_position)
        # right
        quicksort(input_list, sorted_pivot_position + 1, end)
    return input_list


def test_quick_sort(input_list, start, end, expected):
    if quicksort(input_list, start, end) == expected:
        return True
    else:
        return False


# tests
# numbers
print(test_quick_sort([90, 7, 9, 2, 4, 1], 0, 5, expected=[1, 2, 4, 7, 9, 90]))
print(
    test_quick_sort(
        [94, 67, 11, 32, 70, 72, 88], 0, 6, expected=[11, 32, 67, 70, 72, 88, 94]
    )
)
print(test_quick_sort([3, 5, 2, 8, 1, 1, 4], 1, 5, expected=[3, 1, 1, 2, 5, 8, 4]))
print(test_quick_sort([3, 5, 2, 1, 1, 4, 8], 2, 6, expected=[3, 5, 1, 1, 2, 4, 8]))

# letters
print(
    test_quick_sort(
        [""b"", ""z"", ""s"", ""l"", ""m"", ""a""], 0, 5, expected=[""a"", ""b"", ""l"", ""m"", ""s"", ""z""]
    )
)

# empty list
print(test_quick_sort([], 0, 5, expected=[]))

```",2023-11-28T17:36:04+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 3",rufferbaraldi,"```
def test_quicksort(input_list, start, end, expected):
    result = quicksort(input_list, start, end)
    if result == expected:
        return True
    else:
        return False
        
def quicksort(input_list, start, end):
    if start < end:
        p = partition(input_list, start, end, end)
        quicksort(input_list, start, p-1)
        quicksort(input_list, p+1, end)
    return input_list

def partition(input_list, start, end, pivot_position):
    i = start-1
    pivot_position = end
    for j in range(start,end):
        if input_list[j] < input_list[pivot_position]:
            i = i + 1
            (input_list[j], input_list[i]) = (input_list[i], input_list[j])
    (input_list[i+1], input_list[pivot_position]) = (input_list[pivot_position], input_list[i+1])
    return i+1

print(test_quicksort([""The Graveyard Book"", ""American Gods"", ""Good Omens"", ""Coraline"", ""Neverwhere""], 1, 4, [""The Graveyard Book"", ""American Gods"", ""Coraline"", ""Good Omens"", ""Neverwhere""]))
print(test_quicksort([2, 8, 9, 3, 5, 1, 7], 0, 6, [1, 2, 3, 5, 7, 8, 9]))
print(test_quicksort([2, 2, 9, 3, 5, 1, 5], 0, 6, [1, 2, 2, 3, 5, 5, 9]))
```",2023-12-04T10:25:34+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 3",Sergpoipoip,"```
def test_quicksort(input_list, start, end, expected):
    return quicksort(input_list, start, end) == expected


def partition(input_list, start, end, pivot_position):
    el = input_list[pivot_position]
    for i in input_list[start:end+1]:
        if i < el:
            input_list.remove(i)
            input_list.insert(start, i)
        elif i > el:
            input_list.remove(i)
            input_list.insert(end, i)
    return input_list.index(el)


def quicksort(input_list, start, end):
    if end < start:
        return
    pivot_position = partition(input_list, start, end, start)
    quicksort(input_list, start, pivot_position-1)
    quicksort(input_list, pivot_position+1, end)
    return input_list
    


my_list = [""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""]
my_list_1 = [0, 23, 11, -3, 20, 18, -1, 34]
my_list_2 = ['A', 'Z', 'X', 'P', 'B', 'F', 'Q']
print(test_quicksort(my_list, 1, 4, [""The Graveyard Book"", ""American Gods"", ""Coraline"", ""Good Omens"", ""Neverwhere""]))
print(test_quicksort(my_list_1, 0, 6, [-3, -1, 0, 11, 18, 20, 23, 34]))
print(test_quicksort(my_list_2, 0, 6, ['A', 'B', 'F', 'P', 'Q', 'X', 'Z']))
```",2023-12-07T18:47:54+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 3",simocasaz,"```
def test_quicksort(input_list, start, end, expected):
    result = quicksort(input_list, start, end)
    if result == expected:
        return True
    else:
        return False
    
def swap(pos_1, pos_2, input_list):
    prov = input_list[pos_1]
    input_list[pos_1] = input_list[pos_2]
    input_list[pos_2] = prov
    
def partition(input_list, start, end, pivot_position):
    i = start - 1
    swap (pivot_position, end, input_list)
    for j in range(start, end):
        if input_list[j] < input_list[end]:
            i += 1
            swap(i, j, input_list)
    new_pivot_position = i + 1
    input_list.insert(new_pivot_position, input_list[end])
    del input_list[end + 1]
    return new_pivot_position

def quicksort(input_list, start, end):
    if start >= end:
        return input_list
    else:
        pivot = partition(input_list, start, end, (start + end) // 2)
        quicksort(input_list, start, pivot - 1)
        quicksort(input_list, pivot + 1, end)
        return input_list
        


print(test_quicksort([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""], 0, 4, [""American Gods"", ""Coraline"", ""Good Omens"", ""Neverwhere"", ""The Graveyard Book""]))
print(test_quicksort([""I soliti ignoti""], 0, 0, [""I soliti ignoti""]))
print(test_quicksort([""Inglourious Basterds"", ""Jackie Brown"", ""The Hateful Eight"", ""Reservoir Dogs"", ""Once Upon a Time in Hollywood"", ""Kill: Bill Vol. 2"", ""Kill Bill: Vol. 1"", ""Pulp Fiction""], 0, 7, [""Inglourious Basterds"", ""Jackie Brown"", ""Kill Bill: Vol. 1"", ""Kill: Bill Vol. 2"", ""Once Upon a Time in Hollywood"", ""Pulp Fiction"", ""Reservoir Dogs"", ""The Hateful Eight""]))
print(test_quicksort([4, 10, 3, 7, 8, 9, 1], 0, 6, [1, 3, 4, 7, 8, 9, 10]))
print(test_quicksort([10, 5, 7, 4, 2, 9], 0, 5, [2, 4, 5, 7, 9, 10]))

```",2023-12-09T17:06:09+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 2",krzywonos,"```
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position);
    if result == expected:
        print(True);
    else:
        print(False);

def partition(input_list, start, end, pivot_position):
    i = start - 1;
    for j in range(start, end):
        if input_list[j] <= input_list[pivot_position]:
            i = i + 1;
            (input_list[i], input_list[j]) = (input_list[j], input_list[i]);
    (input_list[i + 1], input_list[end]) = (input_list[end], input_list[i + 1]);
    return i + 1;

test_partition([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""], 1, 4, 1, 2);
test_partition([5, 3, 9, 21, 2, 3, 3], 1, 5, 3, 5);
```",2023-11-22T09:59:47+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 2",valetedd,"```
#Ex 2 D&C algorithms: Partition algorithm
def test_partition(input_list, start, end, pivot_position, expected):
    if partition(input_list, start, end, pivot_position) == expected:
        return True
    else:
        return False
    
def partition(input_list, start, end, pivot_position):
    if not (start <= pivot_position <= end) or len(input_list) == 0:
        return None
    pivot_element = input_list[pivot_position]
    
    for i in input_list[start : end + 1]:
        curr_index = input_list.index(i)
        if  i > pivot_element and curr_index < pivot_position:
            input_list.remove(i)
            input_list.insert(pivot_position, i)
            pivot_position -= 1
        elif i < pivot_element and curr_index > pivot_position:
            input_list.remove(i)
            input_list.insert(pivot_position, i)
            pivot_position += 1
        else: 
            pass
    return pivot_position
    

print(test_partition(['Coraline', 'Neverwhere', 'American Gods', 'The Graveyard Book'], 0, 3, 2, 0))
print(test_partition(['Coraline', 'Neverwhere', 'American Gods', ""Coraline"", 'The Graveyard Book'], 0, 4, 2, 0))
print(test_partition([2,-2, 9, 7, 5, 1, 11], 2, 6, 3, 4))
print(test_partition([""bobcat"", ""cat"",  ""lion"", ""deer"",""beetle"" , ""albatros""], 1, 5, 3, 4))
print(test_partition([0, 1], 0, 1, 1, 1))
print(test_partition([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""], 0, 3, 2, 2))
```",2023-11-24T22:46:39+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 2",ThIheb,"```
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if result == expected:
        return True
    else:
        return False
def partition(input_list, start, end, pivot_position):
    pivot_val = input_list[pivot_position]
    i = start -1 
    for j in range(start, end+1):
        if input_list[j] < input_list[pivot_position]:
            i += 1
            if i == pivot_position:
                pivot_position = j
            swap(input_list, i, j)
    k = i +1
    swap(input_list, pivot_position, k)
    return k
def swap(input_list, o, n):
    temporary_value = input_list[o]
    input_list[o] = input_list[n]
    input_list[n] = temporary_value
print(test_partition(['Coraline', 'Neverwhere', 'American Gods', 'The Graveyard Book'], 0, 3, 2, 0))
print(test_partition([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""], 1, 4, 1, 2))
```",2023-11-25T16:05:25+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 2",Liber-R,"![Screenshot 2023-11-26 192729](https://github.com/comp-think/2023-2024/assets/132198967/6dbfa4bf-7505-459d-bf75-c35f5b6ecef3)
",2023-11-26T18:27:46+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 2",qwindici,"```
def partition(input_list, start, end, pivot_position):
    try:
        i = start - 1
        j = start
        pivot = input_list[pivot_position]
        while j <= end:
            if input_list[j] > pivot:
                j += 1
            elif input_list[j] < pivot:
                i += 1
                # swap j and i
                input_list[j], input_list[i] = input_list[i], input_list[j]
                j += 1
            else:
                j += 1
        input_list.remove(pivot)
        input_list.insert(i + 1, pivot)
        return i + 1
    except IndexError:
        return ""Invalid pivot""


def test_partition(input_list, start, end, pivot_position, expected):
    if partition(input_list, start, end, pivot_position) == expected:
        return True
    else:
        return False


# integer list
print(
    test_partition(
        input_list=[7, 2, 1, 8, 6, 3, 5, 4],
        start=2,
        end=7,
        pivot_position=5,
        expected=3,
    )
)
# string list
print(
    test_partition(
        input_list=[""Zebra"", ""Cow"", ""Sheep"", ""Cat"", ""Dog""],
        start=1,
        end=4,
        pivot_position=1,
        expected=2,
    )
)
# first element as pivot
print(
    test_partition(
        input_list=[7, 2, 1, 8, 6, 3, 5, 4],
        start=0,
        end=7,
        pivot_position=0,
        expected=6,
    )
)
# last element as pivot
print(
    test_partition(
        input_list=[7, 2, 1, 8, 6, 3, 5, 4],
        start=0,
        end=7,
        pivot_position=7,
        expected=3,
    )
)
# empty list
print(
    test_partition(
        input_list=[],
        start=0,
        end=7,
        pivot_position=7,
        expected=""Invalid pivot"",
    )
)

# invalid pivot
print(
    test_partition(
        input_list=[1, 2, 3],
        start=1,
        end=7,
        pivot_position=5,
        expected=""Invalid pivot"",
    )
)

```",2023-11-26T18:44:33+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 2",frammenti,"```python
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    # If partition is not possibile test is concluded after match between expected and result
    if expected == result == None:
        return True
    # Test checks not only for the new position of the pivot but also for compliancy to program specification:
    # the modified list should have items smaller than the pivot to its left and bigger to its right
    elif expected == result:
        left_side = input_list[start:expected]
        right_side = input_list[expected+1:end+1]
        pivot = input_list[expected]
        if (left_side == [] or [item <= pivot for item in left_side] and
            right_side == [] or [item >= pivot for item in right_side]):
            return True
        else:
            return False
    else:
        return False

def partition(input_list, start, end, pivot_position):
    if start <= pivot_position <= end and len(input_list) > 0:
        i = start - 1
        pivot = input_list.pop(pivot_position)
        # Range is inclusive of end item because pivot item (included in range)
        # was removed from the list
        for j in range(start,end):
            if input_list[j] < pivot:
                i += 1
                input_list[i], input_list[j] = input_list[j], input_list[i]
        new_position = i + 1
        input_list.insert(new_position, pivot)
        return new_position

num_list = [7, 2, 1, 8, 6, 3, 5, 4]
book_list = [""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""]
ordered_list = [1, 2, 3, 4, 5, 6, 7]
binary_list = [0, 0, 1, 1, 0, 1, 0, 0, 1]

# Tests are run on copies of input lists to make their reuse possible
print(test_partition(list(book_list), 1, 4, 1, 2)) # Pivot in start position
print(test_partition(list(num_list), 0, 7, 7, 3)) # Pivot in last position
print(test_partition(list(book_list), 0, 3, 0, 3)) # Pivot in zero position
print(test_partition(list(binary_list), 1, 7, 3, 5)) # List with repetitions
print(test_partition(list(ordered_list), 2, 5, 4, 4)) # Ordered list
print(test_partition(list(ordered_list[::-1]), 2, 5, 4, 3)) # Reversed order list
print(test_partition([1], 0, 0, 0, 0)) # One-item list
print(test_partition([], 0, 0, 0, None)) # Empty list
print(test_partition(list(book_list), 1, 4, 0, None)) # Pivot out of range

```
The pop-insert method may modify the order of items bigger than the pivot strictly on the right side, but is it a problem? Although not ideal, the function is still compliant with program specifications. I think the pop-insert method best implements the procedure shown by the nice gentleman in the video.

Edit: removed the negative range thing because in hindsight it was absurd",2023-11-27T21:26:14+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 2",rufferbaraldi,"```
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position);
    if result == expected:
        return True
    else:
        return False

def partition(input_list, start, end, pivot_position):
    i = start -1
    for j in range(start,end+1):
        if input_list[j] < input_list[pivot_position]:
            i = i + 1
            (input_list[i], input_list[j]) = (input_list[j], input_list[i])
    (input_list[i + 1], input_list[pivot_position]) = ([pivot_position], input_list[i + 1])
    return i + 1
   

print(test_partition([""The Graveyard Book"", ""American Gods"", ""Coraline"", ""Neverwhere"", ""Good Omens""], 1, 4, 1, 1))
print(test_partition([2, 8, 9, 3, 5, 1, 7], 1, 6, 3, 2))
print(test_partition([""Good Omens"", ""Neverwhere"", ""American Gods"", ""Coraline"", ""The Graveyard Book""], 0, 4, 2, 0))
print(test_partition([""Bologna"", ""Milano"", ""Napoli"", ""Roma"", ""Firenze"", ""Venezia""], 0, 5, 3, 4))
```",2023-11-29T20:05:47+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 2",valentinabertelli,"```
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if result == expected:
        return True
    else:
        return False

def partition(input_list, start, end, pivot_position):
    pivot_value = input_list[pivot_position]
    i = start - 1
    for item in input_list[start:end + 1]:
        if item < pivot_value:
            i = i + 1
            j = input_list.index(item)
            input_list[i], input_list[j] = input_list[j], input_list[i]
    input_list.remove(pivot_value)
    input_list.insert(i + 1, pivot_value)        
    return input_list.index(pivot_value)

print(test_partition(([""The Graveyard Book"",""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""]), 0, 3, 1, 0)) #True
print(test_partition(([""The Graveyard Book"",""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""]), 1, 3, 2, 3)) #True
print(test_partition(([""The Graveyard Book"",""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""]), 0, 4, 4, 0)) #True
print(test_partition(([""The Graveyard Book"",""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""]), 0, 4, 1, 3)) #False
```",2023-12-03T12:15:23+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 2",vattelalberto,"```python
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if result == expected:
        return True
    else:
        return False

def partition(input_list, start, end, pivot_position):
    if pivot_position < start or pivot_position > end:
        return None
    pivot = input_list.pop(pivot_position)
    i = start - 1
    for j in range(start, end):
        j_item = input_list[j]
        i_item = input_list[i]
        if j_item < pivot:
            i += 1
            input_list[i], input_list[j] = input_list[j], input_list[i]
    new_pivot_position = i + 1
    input_list.insert(new_pivot_position, pivot)
    return new_pivot_position

print(test_partition([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""], 1, 4, 1, 2))
print(test_partition([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""], 1, 4, 0, None))
print(test_partition([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""], 0, 4, 0, 4))
```",2023-12-05T14:23:41+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 2",Sergpoipoip,"```
def test_partition(input_list, start, end, pivot_position, expected):
    return partition(input_list, start, end, pivot_position) == expected


def partition(input_list, start, end, pivot_position):
    el = input_list[pivot_position]
    for i in input_list[start:end+1]:
        if i < el:
            input_list.remove(i)
            input_list.insert(start, i)
        elif i > el:
            input_list.remove(i)
            input_list.insert(end, i)
    return input_list.index(el)


my_list = [""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""]
my_list_1 = [0, 23, 11, -3, 20, 18, -1, 34]
my_list_2 = ['A', 'Z', 'X', 'P', 'B', 'F', 'Q']
print(test_partition(my_list, 1, 4, 1, 2))
print(test_partition(my_list_1, 0, 6, 4, 5))
print(test_partition(my_list_2, 0, 6, 3, 3))
```",2023-12-07T18:11:56+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 2",enricabruno,"``` py
# test function
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if result == expected:
        return True
    else:
        return False

# function 
def partition(input_list, start, end, pivot_position):
    if start <= pivot_position <= end and len(input_list) > 0:  
# where to put element to swap
        j = start - 1
# pivot as the last element of the list
        pivot_position = input_list.pop(pivot_position)
# consider all the element before pivot
        for i in range(start, end):
            if input_list[i] < pivot_position:
                j += 1
                input_list[i], input_list[j] = input_list[j], input_list[i]
        new_position = j + 1
        input_list.insert(new_position, pivot_position)
        return new_position

# two test 
print(test_partition([7, 2, 1, 8, 6, 3, 5, 4], 0, 7, 7, 3)) #True
print(test_partition([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""], 0, 4, 4, 0)) #True
```",2023-12-09T10:45:27+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 2",simocasaz,"```
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if result == expected:
        return True
    else:
        return False

def swap(pos_1, pos_2, input_list):
    prov = input_list[pos_1]
    input_list[pos_1] = input_list[pos_2]
    input_list[pos_2] = prov
    
    
def partition(input_list, start, end, pivot_position):
    i = start - 1
    swap (pivot_position, end, input_list)
    for j in range(start, end):
        if input_list[j] < input_list[end]:
            i += 1
            swap(i, j, input_list)
    new_pivot_position = i + 1
    input_list.insert(new_pivot_position, input_list[end])
    del input_list[end + 1]
    return new_pivot_position
    
    
print(test_partition([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""], 1, 4, 1, 2))
print(test_partition([""I soliti ignoti""], 0, 0, 0, 0))
print(test_partition([""Inglourious Basterds"", ""Jackie Brown"", ""The Hateful Eight"", ""Reservoir Dogs"", ""Once Upon a Time in Hollywood"", ""Kill: Bill Vol. 2"", ""Kill Bill: Vol. 1"", ""Pulp Fiction""], 2, 6, 3, 5))
print(test_partition([4, 10, 3, 7, 8, 9, 1], 2, 3, 3, 3))
print(test_partition([10, 5, 7, 4, 2, 9], 0, 5, 0, 5))
```",2023-12-09T17:04:13+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 1",krzywonos,"```
def test_binary_search(item, ordered_list, start, end, expected):
    result = binary_search(item, ordered_list, start, end);
    if result == expected:
        print(True);
    else:
        print(False);

def binary_search(item, ordered_list, start, end):
    if start <= end:
        middle = (start + end) // 2;
        if ordered_list[middle] == item:
            return middle;
        elif ordered_list[middle] > item:
            return binary_search(item, ordered_list, start, middle - 1);
        else:
            return binary_search(item, ordered_list, middle + 1, end);
    else:
        return None;

test_binary_search(4, [1, 2, 3, 4, 5], 0, 4, 3);
test_binary_search(""cinnamon"", [""apple"", ""butter"", ""cinnamon"", ""dough""], 0, 3, 2);
test_binary_search(9, [2, 3, 5, 7, 11, 13, 17, 19], 0, 7, None);
```",2023-11-22T09:47:39+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 1",katyakrsn,"```
def binary_search(item, ordered_list, start, end, expected_result):
    result = binary_search(item, ordered_list, start, end)
    if result == expected_result:
        return True
    else:
        return False


def binary_search(item, ordered_list, start, end):
    if start <= end:
        mid = (start + end) // 2
    if ordered_list[mid] == item:
        return mid
    elif ordered_list[mid] < item:
        return binary_search(item, ordered_list, mid + 1, end)
    else:
        ordered_list[mid] > item
        return binary_search(item, ordered_list, mid - 1, end)


test_1 = binary_search(6, [2, 4, 6, 8], 1, 4)
print(test_1)  # output is 2

test_2 = binary_search(11, [1, 3, 5, 7, 9, 11, 13, 15], 0, 7)
print(test_2)  # output is 5
```",2023-11-22T11:53:29+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 1",valetedd,"```
#Ex 1 D&C algorithms
def test_binary_search(item, ordered_list, start, end, expected):
    if binary_search(item, ordered_list, start, end) == expected:
        return True
    else:
        return False
    
def binary_search(item, ordered_list, start, end):
    if len(ordered_list) == 0:
        return None
    mid_pos = (start + end) // 2
    mid_element = ordered_list[mid_pos]
    if mid_element == item:
        return mid_pos
    elif start == end:        
        return None
    if item > mid_element:
        return binary_search(item, ordered_list, mid_pos + 1, end)
    elif item < mid_element:
        return binary_search(item, ordered_list, start, mid_pos - 1)
        



print(test_binary_search(2, [-2, 1, 2, 5, 7, 9, 11], 0, 6, 2))
print(test_binary_search(""cat"", [""albatros"", ""bobcat"", ""beetle"", ""cat"", ""deer"", ""lion"", ""mountain lion"", ""swallow"", ""zebra""], 0, 8, 3))
print(test_binary_search((0, 0), [(0, 0), (1, 0), (2, 5), (7, 9)], 0, 3, 0))
print(test_binary_search(""dog"", [""albatros"", ""bobcat"", ""beetle"", ""cat"", ""deer"", ""lion"", ""zebra""], 0, 6, None))
print(test_binary_search(8, [1, 2, 2, 3, 4, 5, 6, 7, 9], 0, 8, None))
print(test_binary_search(9, [1, 2, 7, 7, 8, 9, 9], 0, 6, 5))
print(test_binary_search(1, [], 0, 1, None))
```",2023-11-22T18:10:30+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 1",frammenti,"```python
def test_binary_search(item, ordered_list, start, end, expected):
    result = binary_search(item, ordered_list, start, end)
    if expected == result:
        return True
    else:
        return False

def binary_search(item, ordered_list, start, end):
    # start + ((end - start) // 2) = (2 * start + end - start) // 2
    mid = (start + end) // 2
    # Protect the function from divergence if item is out of range
    # and from IndexError if list is empty
    if start <= end and len(ordered_list) > 0:
        mid_item = ordered_list[mid]
        if mid_item == item:
            return mid
        elif mid_item < item:
            return binary_search(item, ordered_list, mid+1, end)
        else:
            return binary_search(item, ordered_list, start, mid-1)

num_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
letter_list = [""a"", ""b"", ""c"", ""e"", ""f"", ""g"", ""h""]

print(test_binary_search(5, num_list, 2, 9, 5)) # A point in case
print(test_binary_search(0, num_list, 0, 10, 0)) # Item in start position
print(test_binary_search(10, num_list, 5, 10, 10)) # Item in end position
print(test_binary_search(11, num_list, 5, 10, None)) # Item out of list
print(test_binary_search(4, num_list, 5, 10, None)) # Item out of range
print(test_binary_search("""", [], 0, 0, None)) # Empty list
print(test_binary_search(""d"", letter_list, 0, 6, None)) # Item skipped in list
```
Edit: removed the negative range thing because in hindsight it was absurd",2023-11-25T12:10:21+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 1",ThIheb,"```
def test_binary_search(item, ordered_list, start, end, expected):
    result = binary_search(item, ordered_list, start, end)
    if result == expected:
        return True
    else: 
        return False
def binary_search(item, ordered_list, start, end):
    if start <= end and len(ordered_list) > 0:
        mid = (start + end) // 2
        if item == ordered_list[mid]:
            return mid
        elif ordered_list[mid] < item:
            return binary_search(item, ordered_list, mid +1, end)
        else:
            return binary_search(item, ordered_list, start, mid -1)

print(test_binary_search(3, [1, 2, 3, 4, 5], 3, 5, None))
print(test_binary_search(""pen"", [""pen"", ""paper"", ""book"", ""diary""], 0, 1, 0))
print(test_binary_search(1, [], 0, 1, None))

```",2023-11-25T13:49:33+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 1",qwindici,"```
def binary_search(item, ordered_list, start, end):
    # obtain the cut list, its length and its middle
    cut_list = ordered_list[start:end]
    length = len(cut_list)
    mid = length // 2
    # check if there are other items to compare
    if length > 0:
        # check if the mid is the searched item
        if cut_list[mid] == item:
            return start + mid
        elif cut_list[mid] < item:
            # search the second part if the list
            return binary_search(item, ordered_list, start + mid, len(ordered_list))
        else:
            # search the first part of the list
            return binary_search(item, ordered_list, start, start + mid)
    # item not found
    else:
        return


def test_binary_search(item, ordered_list, start, end, expected):
    if binary_search(item, ordered_list, start, end) == expected:
        return True
    else:
        return False


print(test_binary_search(3, [1, 2, 3, 4, 5, 6, 7, 8, 9], 0, 9, expected=2))
# first element of the list
print(test_binary_search(1, [1, 2, 3, 4, 5, 6, 7, 8, 9], 0, 9, expected=0))
# last element of the list
print(test_binary_search(9, [1, 2, 3, 4, 5, 6, 7, 8, 9], 0, 9, expected=8))
# list of strings
print(test_binary_search(""come"", [""ciao"", ""come"", ""stai"", ""?""], 0, 4, expected=1))
# element not in the list
print(test_binary_search(4, [20, 30, 40, 50], 0, 4, expected=None))
# empty list
print(test_binary_search(9, [], 0, 0, expected=None))
```",2023-11-26T16:15:48+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 1",Liber-R,"![Screenshot 2023-11-26 192543](https://github.com/comp-think/2023-2024/assets/132198967/8462ee56-35ac-439a-a717-c7b0230aa298)
",2023-11-26T18:25:55+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 1",valentinabertelli,"```
def test_binary_search(item, ordered_list, start, end, expected):
    result = binary_search(item, ordered_list, start, end)
    if result == expected:
        return True
    else:
        return False

def binary_search(item, ordered_list, start, end):
    if item in ordered_list:
        mid_position = end // 2
        mid_item = ordered_list[mid_position]
        if mid_item == item:
            return mid_position
        elif mid_item < item:
            end = len(ordered_list)
            rigth_list = ordered_list[mid_position:end]
            return mid_position + binary_search (item, rigth_list, mid_position, end)
        else:
            start = 0
            left_list = ordered_list[start:mid_position]
            return binary_search (item, left_list, start, mid_position)
    else:
        return None    
    
print(test_binary_search(""h"", ([""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h""]), 0 , 7, 7))
print(test_binary_search(""d"", ([""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h""]), 0 , 7, 3))
print(test_binary_search(""a"", ([""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h""]), 0 , 7, 0))
print(test_binary_search(""c"", ([""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h""]), 0 , 7, 2))
```",2023-11-28T11:50:58+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 1",rufferbaraldi,"```
def test_binary_search(item, ordered_list, start, end, expected):
    result = binary_search(item, ordered_list, start, end)
    if expected == result:
        return True
    else:
        return False

def binary_search(item, ordered_list, start, end):
    if item not in ordered_list or start >= end:
        return None
    else:
        mid = (end + start)//2
        mid_item = ordered_list[mid]
        if item == mid_item:
            return mid
        elif mid_item < item:
            return binary_search(item, ordered_list, mid + 1, end)
        elif mid_item > item:
            return binary_search(item, ordered_list, start, mid - 1)

print(test_binary_search(4, [1, 2, 3, 4, 5], 0, 4, 3))
print(test_binary_search(5, [1, 2, 3, 4, 5, 6, 7, 8], 2, 6, 4))
print(test_binary_search(""pinga"", [""agua"", ""cachaca"", ""cafe"", ""cerveja"", ""leite"", ""pinga"", ""suco"", ""vinho""], 0, 7, 5))
print(test_binary_search(""e"", ([""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h""]), 2 , 5, 4))
```",2023-11-28T21:39:52+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 1",simocasaz,"```
def test_binary_search(item, ordered_list, start, end, expected):
    result = binary_search (item, ordered_list, start, end)
    if result == expected:
        return True
    else:
        return False

def binary_search(item, ordered_list, start, end):
    if len(ordered_list) == 0:
        return None
    if start == end:
        if item == ordered_list[start]:
            return start
        else:
            return None
    else:
        med = start + (end - start) // 2
        if item == ordered_list[med]:
            return med
        elif item < ordered_list[med]:
            end = med - 1
            return binary_search(item, ordered_list, start, end)
        else:
            start = med + 1
            return binary_search(item, ordered_list, start, end)


print(test_binary_search(3, [1, 2, 3, 4, 5, 6, 7], 0, 6, 2))
print(test_binary_search(5, [3, 4, 5, 6, 7], 0, 4, 2))
print(test_binary_search(""Marco"", [""Andrea"", ""Carola"", ""Francesco"", ""Luigia"", ""Marco"", ""Paola""], 0, 5, 4))
print(test_binary_search(""Torino"", [""Alessandria"", ""Biella"", ""Cossato"", ""Saluzzo""], 0, 3, None))
print(test_binary_search(11, [11, 12], 0, 1, 0))
print(test_binary_search(""Giovanni"", [""Giovanni""], 0, 0, 0))
print(test_binary_search(""Giovanni"", [], 0, 0, None))
```",2023-12-01T10:11:21+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 1",vattelalberto,"```python
def test_binary_search(item, ordered_list, start, end, expected):
    result = binary_search(item, ordered_list, start, end)
    if result == expected:
        return True
    else:
        return False

def binary_search(item, ordered_list, start, end):
    list_len = len(ordered_list)
    if start <= end and list_len > end:
        mid = (start + end) // 2
        if ordered_list[mid] == item:
            return mid
        elif ordered_list[mid] < item:
            return binary_search(item, ordered_list, mid + 1, end)
        else:
            return binary_search(item, ordered_list, start, mid - 1)
    else:
        return None

print(test_binary_search(""a"", [""a"", ""b"", ""c"", ""d"", ""e""], 0, 4, 0))
print(test_binary_search(""c"", [""a"", ""b"", ""c"", ""d"", ""e""], 0, 4, 2))
print(test_binary_search(""d"", [""a"", ""b"", ""c"", ""d"", ""e""], 0, 4, 3))
print(test_binary_search(""a"", [], 0, 4, None))
print(test_binary_search(""a"", [""a"", ""b"", ""c"", ""d"", ""e""], 4, 1, None))
print(test_binary_search(""z"", [""a"", ""b"", ""c"", ""d"", ""e""], 0, 4, None))
print(test_binary_search(""a"", [""a"", ""b"", ""c"", ""d"", ""e""], 0, 5, None))
```",2023-12-05T12:41:18+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 1",enricabruno,"``` py
# test function
def test_binary_search(item, ordered_list, start, end, expected):
    result = binary_search(item, ordered_list, start, end)
    if result == expected:
        return True
    else:
        return False

# recursive function 
def binary_search(item, ordered_list, start, end):
# base case: the list is empty or contain just one element
    if len(ordered_list) > 0 and start <= end:
# recursive case
        middle = (start + end) // 2
        middle_item = ordered_list[middle]
# basic case
        if middle_item == item:
            return middle
#recursive case
        elif middle_item < item:
            return binary_search(item, ordered_list, middle+1, end)
        elif middle_item > item:   
            return binary_search(item, ordered_list, start, middle-1)

# print test
print(test_binary_search(3, [1, 2, 3, 4, 5], 0, 4, 2)) #True
print(test_binary_search(""Orlando furioso"", [""La taverna dei destini incrociati"", ""Il castello dei destini incrociati"", ""Le città invisibili"", ""Se una notte d'inverno un viaggiatore""], 0, 3, None)) #True
print(test_binary_search(""Le città invisibili"", [""La taverna dei destini incrociati"", ""Il castello dei destini incrociati"", ""Le città invisibili"", ""Se una notte d'inverno un viaggiatore""], 0, 3, 2)) #True
```",2023-12-06T09:00:22+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 1",Sergpoipoip,"```
def test_binary_search(item, ordered_list, start, end, expected):
    return binary_search(item, ordered_list, start, end) == expected

def binary_search(item, ordered_list, start, end):
    if start <= end:
        middle = (start+end)//2
        if item == ordered_list[middle]:
            return middle
        elif item > ordered_list[middle]:
            return binary_search(item, ordered_list, middle+1, end)
        else:
            return binary_search(item, ordered_list, start, middle-1)
    else:
        return

print(test_binary_search(3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0, 9, 2))
print(test_binary_search('Anna', ['Anna', 'Bill', 'Edward', 'George', 'Jane', 'Mary', 'Paul'], 0, 6, 0))
print(test_binary_search(3, [1, 4, 5, 6, 7, 8, 10, 24], 0, 7, None))
```",2023-12-06T11:42:45+00:00
comp-think/2023-2024,"Lecture ""Divide and conquer algorithms"", exercise 1",MariaFrancesca6,"```py
def test_binary_search(item, ordered_list, start, end, expected):
    result = binary_search(item, ordered_list, start, end)
    if result == expected:
        return True
    else:
        return False

def binary_search(item, ordered_list, start, end):
    if len(ordered_list) > 0 and start <= end:
        pos_central_item = (start + end) // 2 
        central_item = ordered_list[pos_central_item]
        if central_item == item:
            return pos_central_item
        elif central_item < item:
            return binary_search(item, ordered_list, pos_central_item + 1, end)
        else: 
            central_item > item
            return binary_search(item, ordered_list, start, pos_central_item - 1)
    else: 
        return None

    

print(test_binary_search(3,[0,1,2,3,4,5,6],0,6,3))
print(test_binary_search(""e"", [""a"",""e"",""i""],0,2,1))
print(test_binary_search(0,[],4,1,None))
```",2023-12-10T18:29:13+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",frammenti,"```python
# Test of the nth Fibonacci number
def test_fib(n):
    result = fib(n)
    if n < 0:
        expected = 0
    else:
        expected = fib_sequence[n]  
    if expected == result:
        return True
    else:
        return expected, result

# Test of Fibonacci sequence from start to stop number inclusive
def test_fib_seq(start_n,stop_n):
    if start_n <= stop_n:
        range_n = range(start_n,stop_n+1)
    else:
        range_n = range(start_n,stop_n-1,-1) # backwards range
    #test covers also ranges between negative and positive numbers
    expected = [0 if n < 0 else fib_sequence[n] for n in range_n]
    result = [fib(n) for n in range_n]
    if expected == result:
        return True
    else:
        return expected, result

def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        fib_number = fib(n-1) + fib(n-2)
    return fib_number

# Fibonacci sequence down to the 40th number thanks to the On-Line Encyclopedia of Integer Sequences
fib_sequence = [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155]

# All tests return True with the following matching results:
print(test_fib(15)) # 610
print(test_fib(1)) # 1
print(test_fib(0)) # 0
print(test_fib(-3)) # 0
print(test_fib_seq(-1,10)) # [0, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
print(test_fib_seq(10,-1)) # [55, 34, 21, 13, 8, 5, 3, 2, 1, 1, 0, 0]
print(test_fib_seq(-9,-4)) # [0, 0, 0, 0, 0, 0]
print(test_fib_seq(-4,-9)) # [0, 0, 0, 0, 0, 0]
```",2023-11-20T08:35:21+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",Liber-R,"![Screenshot 2023-11-20 102331](https://github.com/comp-think/2023-2024/assets/132198967/72ca06b8-e6ab-4c63-954c-819364e073f5)
",2023-11-20T09:24:26+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",Asemica-me,"```
#Test
def test_fib(n, expected):
    if fib(n) == expected:
        return True
    else:
        return False

#Algorithm
def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)

print(test_fib(1, 1))
print(test_fib(2, 1))
print(test_fib(3, 2))
print(test_fib(4, 3))
print(test_fib(5, 5))
print(test_fib(6, 8))
```",2023-11-20T13:37:51+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",Chiaramartina,"<img width=""540"" alt=""Schermata 2023-11-20 alle 15 13 14"" src=""https://github.com/comp-think/2023-2024/assets/106493111/c15ea9bc-9eb1-446d-a582-5da8d62d6e33"">
",2023-11-20T14:13:52+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",ThIheb,"```
def test_fib(n, expected):
    result = fib(n)
    if result == expected:
        return True
    else:
        return False

def fib(n):
    if n < 0:
        return 0
    elif n == 1:
        return 1
    else:
        result = fib(n-1) + fib(n-2)
    return result

print(test_fib(1,1))        
print(test_fib(19,4181))
print(test_fib(0,0))
print(test_fib(1,1))
print(test_fib(40,102334155))
```",2023-11-20T14:33:32+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",enricabruno,"``` py
# test function
def test_fib(n, expected):
    result = fib(n)
    if result == expected:
        return True
    else:
        return False

# function
def fib(n):
    if n <= 0:
        return 0
        
    elif n == 1:
        return 1
    
    else:
        return fib (n-1) + fib (n-2)


# three tests run
print(test_fib(1, 3)) # False
print(test_fib(0, 0)) # True
print(test_fib(-40, 0)) # True

# Fibonacci sequence with the first five numbers 

fib1 = fib(1) # 1 
fib2 = fib(2) # 1
fib3 = fib(3) # 2
fib4 = fib(4) # 3
fib5 = fib(5) # 5
print(fib1, fib2, fib3, fib4, fib5)
```",2023-11-20T14:37:23+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",valetedd,"```
# Ex 2 Recursion

def test_fib(n, expected):
    if fib(n) == expected:
        return True
    else: 
        return False

def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)
    
# tests
print(test_fib(1, 1))
print(test_fib(0, 0))
print(test_fib(2, 1))
print(test_fib(3, 2))
print(test_fib(4, 3))
print(test_fib(419, 1645645409178311156114050175340179094658577397657624573049761120640548215334513341070281))
```",2023-11-20T14:38:24+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",katyakrsn,"```
def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)


test_1 = fib(3)
print(test_1)

test_2 = fib(-6)
print(test_2)

test_3 = fib(8)
print(test_3)
```",2023-11-20T14:40:21+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",krzywonos,"```
def test_fib(n, expected):
    result = fib(n)
    if expected == result:
        return True
    else:
        return expected, result

def fib(n):
    if n < 1:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n - 1) + fib (n -2)
        
print(test_fib(0, 0))
print(test_fib(1, 1))
print(test_fib(8, 21))
print(test_fib(49, 7778742049))
```",2023-11-20T15:55:20+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",qwindici,"```
def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)


def test_fib(n, expected):
    if fib(n) == expected:
        return True
    else:
        return False


print(test_fib(1, 1))
print(test_fib(9, 34))
print(test_fib(-4, 0))
print(test_fib(15, 610))
```",2023-11-20T17:58:47+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",Sergpoipoip,"```
def test_fib(n, expected):
    return fib(n) == expected

def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    return fib(n-1) + fib(n-2)

print(test_fib(0, 0))
print(test_fib(1, 1))
print(test_fib(7, 13))
```",2023-11-21T09:07:53+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",alicepiazzi,"```
def test_fib(n, expected):
    if fib(n) == expected:
        return True
    else:
        return False


def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

print(fib(1, 1))  
print(fib(0, 0))
print(fib(-1, 0))
print(fib(9,34))
```
",2023-11-21T16:49:08+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",MariaFrancesca6,"```py
def test_fib(n, expected):
    result = fib(n)
    if result == expected:
        return True
    else: 
        return False

def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

print(test_fib(3,2))
print(test_fib(8,21))
print(test_fib(0,0))
print(test_fib(1,1))
```",2023-11-21T17:31:29+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",matildepassafaro,"```
# define the function
def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)

# test case for the function
def test_fib(n, expected):
    result = fib(n)
    if expected == result:
        return True
    else:
        return False

# test runs
print(test_fib(0, 0))
print(test_fib(1, 1))
print(test_fib(4, 3))
print(test_fib(7, 13))
```",2023-11-21T17:37:06+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",valentinabertelli,"```
def test_f (n, expected):
   result = f(n)
   if result == expected:
      return True
   else:
      return False

def f(n):
   if n <= 0:
      return 0
   elif n == 1:
       return 1
   else:
      return f(n - 1) + f(n - 2)
   
print (test_f(4, 3)) #True
print (test_f(4, 5)) #False 
```",2023-11-21T18:21:51+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",CarlaMenegat,"![Captura de Tela 2023-11-21 às 19 26 41](https://github.com/comp-think/2023-2024/assets/146187896/9df1d046-d3a0-4cf2-96c5-936a6db52f23)
",2023-11-21T18:27:22+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",rufferbaraldi,"````
def test_fib(n, expected):
    result = fib(n)
    if result == expected:
        return True
    else:
        return False

def fib(n):
    if n <= 0:
        return 0
    else:
        if n == 1:
            return 1
        else: 
            return fib(n - 1) + fib(n - 2) 
           
print(test_fib(0, 0))
print(test_fib(1, 1))
print(test_fib(5, 5))
print(test_fib(6, 8))
```",2023-11-21T21:56:09+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",essepuntato,"Thanks for your takes. Here are a few comments:

* @agaveeoleandro very well-thought the strategy for testing. However, it is essential that the testing function returns always either `True` or `False` and not other outputs.
* @enricabruno @valentinabertelli, when preparing the tests, you must constantly check that what each test returns is `True`. In case any of your tests return `False`, it means that your code is not working. Thus, please avoid testing the incorrectness of execution on purpose (like `test_fib(1, 3)`) since the only thing you can claim after executing it is that your code is not working correctly. In addition, try to expand the tests to include some other reasonable (i.e. input number greater than 1) value.
* @katyakrsn @krzywonos, see my comments on the previous exercise (there are the same issues also here).
* @alicepiazzi you are not running the tests in your code.",2023-11-22T08:02:04+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",simocasaz,"def test_fib(n, expected):
    result = fib(n)
    if result == expected:
        return True
    else:
        return False
    


def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)

print(test_fib(7, 13))
print(test_fib(1, 1))
print(test_fib(2, 1))
print(test_fib(0, 0))",2023-11-29T17:25:07+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",vattelalberto,"```python
def test_fib(n, expected):
    result = fib(n)
    if result == expected:
        return True
    else:
        return False

def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)

print(test_fib(-1, 0))
print(test_fib(0, 0))
print(test_fib(1, 1))
print(test_fib(3, 2))
print(test_fib(10, 55))
```",2023-12-05T11:33:22+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 2",saramadonia,"
![recursionex2](https://github.com/comp-think/2023-2024/assets/146438182/18dd1383-6a91-40aa-a174-b2f1274967f1)

",2023-12-22T17:07:55+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",frammenti,"```python
def test_exponentiation(base_number, exponent, expected):
    result = exponentiation(base_number, exponent)
    if expected == result:
        return True
    else:
        return expected, result

def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1
    else:
        # Recursive call that reads as x^n = x * x^(n-1) = x * x * x^(n-2) until n reaches 0:
        # x^n = x n times * x^0 = x n times * 1
        result = base_number * exponentiation(base_number, exponent-1)
    return result

print(test_exponentiation(3,4,81))
print(test_exponentiation(17,1,17))
print(test_exponentiation(2,0,1))
print(test_exponentiation(-5,2,25)) # With negatives, result is positive if exponent is even
print(test_exponentiation(-5,3,-125)) # Result is negative if exponent is odd
```",2023-11-20T08:32:50+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",Liber-R,"![Screenshot 2023-11-20 102228](https://github.com/comp-think/2023-2024/assets/132198967/3d0c55a7-73e8-4d5e-8ae9-242c22ab470d)
",2023-11-20T09:22:59+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",Asemica-me,"```
#Test case
def test_exponentation(base_number, exponent, expected):
    if exponentiation(base_number, exponent) == expected:
        return True
    else:
        return False

#Algorithm
def exponentiation(base_number, exponent):
    # Base case: when exponent is 0, result is 1
    if exponent == 0:
        return 1
    # Recursive case: multiply base_number by the result of exponentiation with a reduced exponent
    else:
        return base_number * exponentiation(base_number, exponent - 1)

print(test_exponentation(3, 4, 81))
print(test_exponentation(17, 1, 17))
print(test_exponentation(2, 0, 1))
```",2023-11-20T13:05:42+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",enricabruno,"``` py
# test function
def test_exponentiation(base_number, exponent, expected):
    result = exponentiation(base_number, exponent)
    if result == expected:
        return True
    else:
        return False

# function
def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1
    else:
        return base_number * exponentiation(base_number, exponent-1)

# three tests run
print(test_exponentiation(3, 4, 81)) # True
print(test_exponentiation(17, 1, 17)) # True
print(test_exponentiation(2, 0, 1)) # basic case

```",2023-11-20T14:11:19+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",Chiaramartina,"<img width=""633"" alt=""Schermata 2023-11-20 alle 15 11 01"" src=""https://github.com/comp-think/2023-2024/assets/106493111/79fc3822-d8b8-4674-a413-f1efb86a63c5"">
",2023-11-20T14:11:36+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",valetedd,"```
#Ex 1 Recursion

def test_exponentiation(base_number, exponent, expected):
    if exponentiation(base_number, exponent) == expected:
        return True
    else:
        return False

def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1
    elif exponent == 1:
        return base_number
    else: 
        return base_number * exponentiation(base_number, exponent - 1)

print(test_exponentiation(3, 4, 81))
print(test_exponentiation(17, 1, 17))
print(test_exponentiation(2, 0, 1))

```",2023-11-20T14:23:49+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",ThIheb,"```
def test_exponentiation(base_number, exponent, expected):
    result = exponentiation(base_number, exponent)
    if expected == result:
        return True
    else:
        return expected, result

def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1
    else:
        result = base_number * exponentiation(base_number, exponent-1)
        return result
print(test_exponentiation(3,4,81))
print(test_exponentiation(17,1,17))
print(test_exponentiation(2,0,1))
```",2023-11-20T14:24:39+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",katyakrsn,"```
def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1
    else:
        return base_number * exponentiation(base_number, exponent - 1)


test_1 = exponentiation(3, 4)
print(test_1)

test_2 = exponentiation(17, 1)
print(test_2)

test_3 = exponentiation(2, 0)
print(test_3)
```",2023-11-20T14:28:20+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",krzywonos,"```
def test_exponentiation(base_number, exponent, expected):
    result = exponentiation(base_number, exponent)
    if expected == result:
        return True
    else:
        return expected, result

def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1
    else:
        return base_number * exponentiation(base_number, exponent - 1)
        
print(test_exponentiation(3,4,81))
print(test_exponentiation(17,1,17))
print(test_exponentiation(2,0,1))
```",2023-11-20T15:44:43+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",qwindici,"```
def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1
    else:
        return base_number * exponentiation(base_number, exponent - 1)


def test_exponentiation(base_number, exponent, expected):
    if exponentiation(base_number, exponent) == expected:
        return True
    else:
        return False


print(test_exponentiation(3, 4, 81))
print(test_exponentiation(17, 1, 17))
print(test_exponentiation(2, 0, 1))
```",2023-11-20T17:49:37+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",Sergpoipoip,"```
def test_exponentiation(base_number, exponent, expected):
    return exponentiation(base_number, exponent) == expected

def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1
    return exponentiation(base_number, exponent-1) * base_number

print(test_exponentiation(3, 4, 81))
print(test_exponentiation(17, 1, 17))
print(test_exponentiation(2, 0, 1))
```",2023-11-21T08:46:50+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",CarlaMenegat,"![Captura de Tela 2023-11-21 às 11 22 53](https://github.com/comp-think/2023-2024/assets/146187896/412165ed-3834-49c8-8549-bcf9adbf74b0)
",2023-11-21T10:23:09+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",alicepiazzi,"
```
def test_exponentiation(base_number, exponent, expected):
    if exponentiation(base_number, exponent) == expected:
        return True
    else:
        return False
        
def exponentiation(base_number, exponent):    #3=base number, 4=exponent
    if exponent == 0:   
        return 1 
    else:
        return base_number * exponentiation(base_number, exponent - 1)

print(exponentiation(3, 4, 81))
print(exponentiation(17, 1, 17))
print(exponentiation(2, 0, 1))

```",2023-11-21T16:47:15+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",MariaFrancesca6,"```py
def test_esp(base_number, exponent , expected):
    result = esp(base_number, exponent)
    if result == expected:
        return True
    else:
        return False

def esp(base_number, exponent):
    if exponent == 0:
        return 1
    elif exponent == 1:
        return base_number
    else:
        return base_number * esp(base_number, exponent - 1)

print(test_esp(3,4,81))
print(test_esp(17,1,17))
print(test_esp(2,0,1))
```",2023-11-21T17:26:26+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",matildepassafaro,"```
# define the function
def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1
    else:
        return base_number * exponentiation(base_number, exponent - 1)

# test case for the function
def test_exponentiation(base_number, exponent, expected):
    result = exponentiation(base_number, exponent)
    if expected == result:
        return True
    else:
        return False

# test runs: use as input 3 exponent 4, 17 exponent 1 and 2 exponent 0
print(test_exponentiation(3, 4, 81))
print(test_exponentiation(17, 1, 17))
print(test_exponentiation(2, 0, 1))
```",2023-11-21T17:35:02+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",VirginiaDa00,"<img width=""769"" alt=""es 1 lez 8"" src=""https://github.com/comp-think/2023-2024/assets/147997710/e26194b3-7efc-4620-aaf6-a31086a8ca1b"">
",2023-11-21T17:48:12+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",rufferbaraldi,"```
def test_exp_number(int_1, int_2, expected):
    result = exp_number(int_1, int_2)
    if result == expected:
        return True
    else:
        return False
        
def exp_number(int_1, int_2):
    if int_2 == 0:
        return 1
    else:
        return int_1 * exp_number(int_1, int_2 - 1)
       
print(test_exp_number(3,4,81))
print(test_exp_number(17,1,17))
print(test_exp_number(2,0,1))
```",2023-11-21T21:39:32+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",essepuntato,"Thank you for all your takes. Just a few comments:

* @agaveeoleandro @ThIheb @krzywonos, the tests must always return `True` or `False`, nothing else (even if it is clear why you decided on a different return value for the `False` situation. However, that could be avoided by printing on the screen the result of the execution of the algorithm in the test with its expected value;

* @katyakrsn, you did not develop the testing function at all. Please look at the solutions from your colleagues to see what I mean, and also read the text where I introduce Python (chapter four), which includes templates for organising the tests.",2023-11-22T07:49:05+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",simocasaz,"```
def test_exponentiation(base_number, exponent, expected):
    result = exponentiation(base_number, exponent)
    if expected == result:
        return True
    else:
        return False

def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1
    else:
        exponent -= 1
        return base_number * exponentiation(base_number, exponent)


print(test_exponentiation(3, 4, 81))
print(test_exponentiation(17, 1, 17))
print(test_exponentiation(2, 0, 1))
```

",2023-11-29T17:01:07+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",vattelalberto,"```python
def test_exponentiation(base_number, exponent, expected):
    result = exponentiation(base_number, exponent)
    if result == expected:
        return True
    else:
        return False

def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1
    else:
        return base_number * exponentiation(base_number, exponent - 1)

print(test_exponentiation(3, 4, 81))
print(test_exponentiation(17, 1, 17))
print(test_exponentiation(2, 0, 1))
```",2023-12-05T11:27:02+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",saramadonia,"![recursionex1](https://github.com/comp-think/2023-2024/assets/146438182/4dc9b816-8fa0-4d92-b465-57a5ce573a13)
",2023-12-22T16:48:52+00:00
comp-think/2023-2024,"Lecture ""Recursion"", exercise 1",saramadonia,"![recursionex1](https://github.com/comp-think/2023-2024/assets/146438182/a8744393-5456-4b19-99bc-3f43da9c080a)
",2023-12-22T16:50:40+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",Liber-R,"![Screenshot 2023-11-15 102739](https://github.com/comp-think/2023-2024/assets/132198967/9435a9c5-d3d0-4144-97d2-a5afc071eed5)
",2023-11-15T09:28:55+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",Asemica-me,"My set = {""Gandalf"", ""Merry"", ""Sam"", ""Pippin"", ""Frodo"", ""Saruman"", ""Galadriel""}

1<sup>st</sup> method:
```
set_hobbit = {""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
set_magician = {""Saruman"", ""Gandalf""}

my_dict = dict()
my_dict[""hobbit""] = set_hobbit
my_dict[""magician""] = set_magician

```

2<sup>nd</sup> method:
```
set_hobbit = set()
set_hobbit.add(""Frodo"")
set_hobbit.add(""Sam"")
set_hobbit.add(""Pippin"")
set_hobbit.add(""Merry"")

set_magician = set()
set_magician.add(""Saruman"")
set_magician.add(""Gandalf"")

my_dict = dict()
my_dict[""hobbit""] = set_hobbit
my_dict[""magician""] = set_magician
```

Output:
```
{'hobbit': {'Frodo', 'Sam', 'Merry', 'Pippin'}, 'magician': {'Saruman', 'Gandalf'}}
```",2023-11-15T12:44:20+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",valentinabertelli,"```
my_set = set({""Frodo"", ""Pippin"", ""Saruman"", ""Galadriel"", ""Gandalf"", ""Sam"", ""Merry""})
set_hobbit = set()
set_hobbit.update(set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""}))
set_magician = set()
set_magician.update(set({""Saruman"", ""Gandalf""}))
my_dict = dict()
my_dict[""hobbit""] = set_hobbit
my_dict[""magician""] = set_magician
#my_dict became:
#dict({'hobbit': {'Pippin', 'Merry', 'Frodo', 'Sam'}, 'magician': {'Gandalf', 'Saruman'}})
```",2023-11-15T15:07:58+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",Alice-Ant,"set_hobbit = {""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
set_magician = {""Saruman"", ""Gandalf""}

my_dict = dict()
my_dict[""hobbit""] = set_hobbit
my_dict[""magician""] = set_magician

Output:
{'hobbit': {'Merry', 'Pippin', 'Frodo', 'Sam'}, 'magician': {'Gandalf', 'Saruman'}}",2023-11-15T18:03:31+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",katyakrsn,"```
set_hobbit = {""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
set_magician = {""Saruman"", ""Gandalf""}
characters = {""hobbit"": set_hobbit, ""magicians"": set_magician}
print(characters)
```",2023-11-15T18:14:45+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",ThIheb,"```
set_hobbit = set({""Frodo"",""Sam"",""Pippin"",""Merry""})
set_magician = set({""Saruman"",""Gandalf""})
Lor_dict = dict()
Lor_dict[""Hobbit""] = set_hobbit
Lor_dict[""Magician""] = set_magician
print(Lor_dict)

#The outputwould be {'Hobbit': {'Merry', 'Pippin', 'Frodo', 'Sam'}, 'Magician': {'Gandalf', 'Saruman'}}

```",2023-11-15T18:23:33+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",qwindici,"```
set_hobbit = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = set({""Saruman"", ""Gandalf""})

my_dict = {""hobbit"": set_hobbit, ""magician"": set_magician}
```",2023-11-16T11:39:24+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",krzywonos,"```
set_hobbit = {""Frodo"", ""Sam"", ""Pippin"", ""Merry""};
set_wizard = {""Saruman"", ""Gandalf""};
lotr_dict = {};
lotr_dict[""hobbits""] = set_hobbit;
lotr_dict[""wizards""] = set_wizard;
print(lotr_dict);
# {'hobbits': {'Merry', 'Sam', 'Frodo', 'Pippin'}, 'wizards': {'Saruman', 'Gandalf'}}
```",2023-11-16T17:58:58+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",MariaFrancesca6,"```py
set_hobbit = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = set({""Saruman"", ""Gandalf""})

my_dict = dict()
my_dict[""hobbit""] = (set_hobbit)
my_dict[""magician""] = (set_magician)
print(my_dict)
my_dict = {'hobbit': {'Merry', 'Pippin', 'Sam', 'Frodo'}, 'magician': {'Gandalf', 'Saruman'}}
```",2023-11-16T21:04:08+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",rufferbaraldi,"```
set_hobbit = ({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = ({""Saruman"", ""Gandalf""})
tolkien_dict = dict()
tolkien_dict[""hobbit""] = (set_hobbit)
tolkien_dict[""magician""] = (set_magician)
print(tolkien_dict)

#{'hobbit': {'Sam', 'Frodo', 'Pippin', 'Merry'}, 'magician': {'Gandalf', 'Saruman'}}
```",2023-11-16T22:12:42+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",enricabruno,"``` py
# creation of the first set
set_hobbit = ({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
# creation of the second set
set_magician = ({""Saruman"", ""Gandalf""})
# creation of the dictionary
hobbit_magician_dict = dict()
hobbit_magician_dict[""hobbit""] = set_hobbit
hobbit_magician_dict[""magician""] = set_magician
# the dictionary containing the two pairs
print(hobbit_magician_dict)
```

output: {'hobbit': {'Sam', 'Pippin', 'Merry', 'Frodo'}, 'magician': {'Saruman', 'Gandalf'}}",2023-11-18T12:59:20+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",frammenti,"```python
set_hobbit = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = set({""Saruman"", ""Gandalf""})

#Method 1
my_dict = {}
my_dict[""hobbit""] = set_hobbit
my_dict[""magician""] = set_magician

# Method 2
my_dict = {""hobbit"": set_hobbit, ""magician"": set_magician}

# Output
# {'hobbit': {'Frodo', 'Merry', 'Pippin', 'Sam'}, 'magician': {'Gandalf', 'Saruman'}}
```",2023-11-18T19:09:25+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",alicepiazzi,"```
set_hobbit = set()
set_hobbit.add (""Frodo"")
set_hobbit.add (""Sam"")
set_hobbit.add (""Pippin"")
set_hobbit.add (""Merry"")
print(set_hobbit)

set_magician = set()
set_magician.add (""Saruman"")
set_magician.add (""Gandalf"")
print(set_magician) 

my_dict = dict()
my_dict[""hobbit""] = (set_hobbit)
my_dict[""magician""] = (set_magician)

print(my_dict)
my_dict = {'hobbit': {'Merry', 'Pippin', 'Sam', 'Frodo'}, 'magician': {'Gandalf', 'Saruman'}}
```",2023-11-18T22:01:16+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",saramadonia,"set_hobbit = {""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
set_magician = {""Saruman"", ""Gandalf""}
my_dict = {hobbits : set_obbit, magician : set_magician}

",2023-11-19T13:27:52+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",simocasaz,"```
set_hobbit = {""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
set_magician ={""Saruman"", ""Gandalf""}
my_dict = dict()
my_dict[""hobbit""] = set_hobbit
my_dict[""magician""] = set_magician
```",2023-11-19T16:35:40+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",matildepassafaro,"```
set_hobbit = {""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
set_magician = {""Saruman"", ""Gandalf""}
# create a dictionary
my_dict = dict()
# add key-value pairs
my_dict[""hobbit""] = set_hobbit
my_dict[""magician""] = set_magician
print(my_dict)
```
my_dict = {""hobbit"": {""Frodo"", ""Sam"", ""Pippin"", ""Merry""}, ""magician"": {""Saruman"", ""Gandalf""}}",2023-11-19T16:47:45+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",Chiaramartina,"set_hobbit = set()
set_hobbit.add(""Frodo"")
set_hobbit.add(""Sam"")
set_hobbit.add(""Pippin"")
set_hobbit.add(""Merry"")

set_magician = set()
set_magician.add(""Saruman"")
set_magician.add(""Gandalf"")

my_dict = dict()
my_dict[""hobbit""] = set_hobbit
my_dict[""magician""] = set_magician

print(my_dict)

my_dict={'hobbit': {'Sam', 'Pippin', 'Frodo', 'Merry'}, 'magician': {'Gandalf', 'Saruman'}}",2023-11-19T16:49:44+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",Sergpoipoip,"```
set_hobbit = {""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
set_magician = {""Saruman"", ""Gandalf""}
characters = {'hobbit': set_hobbit, 'magician': set_magician}
```",2023-11-19T17:25:47+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",CarlaMenegat,"![Captura de Tela 2023-11-19 às 20 16 54](https://github.com/comp-think/2023-2024/assets/146187896/23e01a55-8b45-4f09-a1d1-c760ecd9f7de)
",2023-11-19T19:17:10+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 3",annapasetto0,"set_hobbit = {""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
set_magician = {""Saruman"", ""Gandalf""}

lord_dictionary = dict()
lord_dictionary[""hobbit""] = set_hobbit
lord_dictionary[""magician""] = set_magician

get_hobby = lord_dictionary.get(""hobbit"")
get_magician = lord_dictionary.get(""magician"")


print(get_hobby)
print(get_magician)",2023-11-27T17:56:31+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",Liber-R,"![Screenshot 2023-11-15 102309](https://github.com/comp-think/2023-2024/assets/132198967/49a4010f-b412-4d80-8c32-e9bb79c31b48)
",2023-11-15T09:29:25+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",Asemica-me,"My set = {""Pippin"", ""Frodo"", ""Bilbo"", ""Merry"", ""Sam""}
```
my_set = {""Pippin"", ""Frodo"", ""Bilbo"", ""Merry"", ""Sam""}
my_set.remove(""Bilbo"")
​my_set.add(""Galadriel"")
my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))
```

Output:
```
{""Gandalf"", ""Merry"", ""Sam"", ""Pippin"", ""Frodo"", ""Saruman"", ""Galadriel""}
```
Current status of `my_set` :
My set = {""Gandalf"", ""Merry"", ""Sam"", ""Pippin"", ""Frodo"", ""Saruman"", ""Galadriel""}",2023-11-15T12:43:38+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",valentinabertelli,"```
my_set = set({""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""})

my_set.remove(""Bilbo"") #""Bilbo"" is removed from the set
#my_set became:
#set({""Frodo"", ""Pippin"", ""Sam"", ""Merry""})

my_set.add(""Galadriel"") #""Galadriel"" is added to the set
#my_set became:
#set = ({""Frodo"", ""Pippin"", ""Galadriel"", ""Sam"", ""Merry""})

my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})) #""Saruman"" and ""Gandalf"" are added to the set, ""Frodo"" is not added to the set because is already present
#my_set became:
#set = ({""Frodo"", ""Pippin"", ""Saruman"", ""Galadriel"",""Gandalf"",""Sam"",""Merry""})
```",2023-11-15T14:56:29+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",Alice-Ant,"my_set.remove(""Bilbo"") - removes ""Bilbo"" from the set
{""Frodo"", ""Pippin"", ""Sam"", ""Merry""}

my_set.add(""Galadriel"") - adds ""Galadriel"" to the set
{""Frodo"", ""Pippin"", ""Galadriel"", ""Sam"", ""Merry""}

my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})) -  adds ""Saruman"" and ""Gandalf"" to the set, ""Frodo"" is not added, already present

Current status of my_set is
{'Sam', 'Saruman', 'Pippin', 'Merry', 'Frodo', 'Galadriel', 'Gandalf'}",2023-11-15T17:58:21+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",katyakrsn,"```
my_set = {""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
my_set.remove(""Bilbo"")  # Bilbo is removed from the set
my_set.add(""Galadriel"")  # Galadriel is added to the set
my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))  # Adds these new elements to my_set, except for Frodo
print(my_set)
```",2023-11-15T18:07:59+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",ThIheb,"```
my_set = {""Bilbo"", ""Frodo"", ""Sam"", ""Pippin, ""Merry""}
my_set.remove(""Bilbo"")
#The string ""Bilbo"" will be removed from the set

my_set.add(""Galdriel"")   
#The string ""Galdriel is added to the set

my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))

#The state of the set will be {""Frodo"", ""Sam"", ""Pippin"", ""Merry"", ""Galdriel"", ""Saruman"", ""Gandalf""}
The string ""Frodo"" wasn't added because it already existed in the first set

```

",2023-11-15T18:16:07+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",qwindici,"```
my_set = {""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
# remove 'Bilbo'
my_set.remove(""Bilbo"")
# add ""Galadriel""
my_set.add(""Galadriel"")
# add the set {""Saruman"", ""Frodo"", ""Gandalf""}, the element already in the set won't be repeated
my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))

print(my_set)  # {'Sam', 'Saruman', 'Galadriel', 'Merry', 'Frodo', 'Gandalf', 'Pippin'}
```",2023-11-16T11:34:02+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",krzywonos,"```
my_set = {""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
my_set.remove(""Bilbo"")
# my_set = {""Sam"", ""Frodo"", ""Merry"", ""Pippin""}
my_set.add(""Galadriel"")
# my_set = {""Frodo"", ""Sam"", ""Galadriel"", ""Pippin"", ""Merry""}
my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))
# my_set = {""Frodo"",""Galadriel"", ""Sam"", ""Saruman"", ""Pippin"", ""Gandalf"", ""Merry""}
```",2023-11-16T17:53:54+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",MariaFrancesca6,"```py
my_set = {'Bilbo', 'Frodo', 'Merry', 'Pippin', 'Sam'}

my_set.remove(""Bilbo"")
#the ""Bilbo"" string has been removed
print(my_set)
my_set = {'Frodo', 'Sam', 'Pippin', 'Merry'}

my_set.add(""Galadriel"")
#the ""Galadriel"" string has been added
print(my_set)
my_set = {'Galadriel', 'Frodo', 'Sam', 'Pippin', 'Merry'}

my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))
#the method update add elements from another set
print(my_set)
my_set = {'Galadriel', 'Frodo', 'Saruman', 'Sam', 'Pippin', 'Gandalf', 'Merry'}
```",2023-11-16T20:55:32+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",rufferbaraldi,"```
my_set = {'Sam', 'Frodo', 'Pippin', 'Bilbo', 'Merry'}
my_set.remove(""Bilbo"")
#my_set = {'Frodo', 'Sam', 'Pippin', 'Merry'}

my_set.add(""Galadriel"")
#my_set = {'Frodo', 'Sam', 'Pippin', 'Galadriel', 'Merry'}

my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))
#my_set = {'Sam', 'Galadriel', 'Saruman', 'Merry', 'Gandalf', 'Pippin',  'Frodo'}
```",2023-11-16T22:02:45+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",enricabruno,"``` py
# creation of the set with the given elements
my_set = set({""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Mery""})
# the current set
print(my_set)
# removing the element ""Bilbo""
my_set.remove(""Bilbo"")
# first status of the set without ""Bilbo""
print(my_set)
# addition of the element ""Galadriel""
my_set.add(""Galadriel"")
# second status of the set with the addition of ""Galadriel""
print(my_set)
# updating the set with new given elements
my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))
# third status of the set updated
print(my_set)
```

final output: {'Sam', 'Mery', 'Pippin', 'Saruman', 'Galadriel', 'Gandalf', 'Frodo'}",2023-11-18T09:47:33+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",frammenti,"```python
my_set = {""Saruman"", ""Gandalf"", ""Merry"", ""Sam"", ""Frodo"", ""Galadriel"", ""Pippin""}
```",2023-11-18T18:57:56+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",alicepiazzi,"```
my_first_set = set()  # create an empy set
my_first_set.add (""Bilbo"") # add elements
my_first_set.add (""Frodo"")
my_first_set.add (""Sam"")
my_first_set.add (""Pippin"")
my_first_set.add (""Merry"")
my_first_set.remove(""Bilbo"") # remove elements
my_first_set.add(""Galadriel"") # add an element
my_first_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})) #current status of my_first_set

print (my_first_set)

my_first_set = {""Galadriel"", ""Saruman"", ""Gandalf"", ""Pippin"", ""Sam"", ""Frodo"", ""Merry""}``
```",2023-11-18T19:41:12+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",saramadonia,"my_set =  {""Sam"", ""Pippin"", ""Merry"", ""Frodo"", ""Bilbo""}

my_set.remove(""Bilbo"") # removes ""Bilbo"" element to the set
print(my_set)
Sam Pippin Merry Frodo

​my_set.add(""Galadriel"") # adds ""Galadriel"" element to the set
print(my_set)
Sam Pippin  Galadriel Merry Frodo

​my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})) # adds to my_set elements from another set
print(my_set)
Sam Pippin  Galadriel Frodo Merry Saruman Gandalf",2023-11-19T13:21:43+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",Sergpoipoip,"after the execution of the provided operations with `my_set` this variable will store the set `{'Saruman', 'Merry', 'Frodo', 'Sam', 'Gandalf', 'Pippin', 'Galadriel'}`",2023-11-19T15:26:50+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",simocasaz,"```
a_set = {""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
my_set.remove(""Bilbo"") # The item ""Bilbo"" is no longer in the set
​my_set.add(""Galadriel"") # The item ""Galadriel"" has been added to the set
​my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})) # The items ""Saruman"" and ""Gandalf"" are now in the set. The item ""Frodo"" has not been added, since it was already present in my_set
```",2023-11-19T16:19:54+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",Chiaramartina,"my_set = {""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
my_set.remove(""Bilbo"") 
#Bilbo has been removed
my_set.add(""Galadriel"") 
#Galadriel has been added
my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))
#The set was updated with new elements but ""Frodo"" wasn't repeated
print (my_set)

my_set={'Frodo', 'Sam', 'Merry', 'Saruman', 'Galadriel', 'Pippin', 'Gandalf'}",2023-11-19T16:22:17+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",matildepassafaro,"my_set = {""Sam"", ""Pippin"", ""Bilbo"", ""Frodo"", ""Merry""}

status of my_set after the execution of my_set.remove(""Bilbo""):
my_set = {""Sam"", ""Pippin"", ""Frodo"", ""Merry""}

status of my_set after the execution of my_set.add(""Galadriel""):
my_set = {""Sam"", ""Pippin"", ""Galadriel"", ""Frodo"", ""Merry""}

status of my_set after the execution of my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})):
my_set = {""Sam"", ""Gandalf"", ""Pippin"", ""Saruman"", ""Galadriel"", ""Frodo"", ""Merry""}",2023-11-19T16:39:22+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",CarlaMenegat,"![Captura de Tela 2023-11-19 às 20 00 47](https://github.com/comp-think/2023-2024/assets/146187896/90b257de-f21c-4204-9c71-81b6e1d42074)
",2023-11-19T19:01:54+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",VirginiaDa00,"
<img width=""692"" alt=""es2 lez 7"" src=""https://github.com/comp-think/2023-2024/assets/147997710/53a2cce2-c4a1-4b75-9371-68f529648fed"">

",2023-11-20T07:56:23+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",essepuntato,"Thanks for your takes. Just one comment:

* @Liber-R @katyakrsn @simocasaz, you did not say what is the final output.",2023-11-22T08:08:54+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 2",annapasetto0,"my_set = set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")

my_set.remove(""Bilbo"") #Bilbo is removed (Frodo, Sam, Pippin, Merry)
my_set.add(""Galadriel"") #Galadriel is added to the set (Frodo, Sam, Pippin, Merry, Galadriel)
my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})) #Saruman and Gandalf are now in my_set

print(my_set)

#output: {'Saruman', 'Frodo', 'Galadriel', 'Gandalf', 'Merry', 'Sam', 'Pippin'}",2023-11-27T17:41:46+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",Liber-R,"![Screenshot 2023-11-15 102249](https://github.com/comp-think/2023-2024/assets/132198967/0dea7823-e2dc-4dac-9a02-9ae6b7047a70)
",2023-11-15T09:29:58+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",Asemica-me,"1<sup>st</sup> way:
```
my_set = set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")
``` 

2<sup>nd</sup> way:
```
my_set = {""Pippin"", ""Frodo"", ""Bilbo"", ""Merry"", ""Sam""}
```
(same) output obtained: 
```
{""Pippin"", ""Frodo"", ""Bilbo"", ""Merry"", ""Sam""}
```
Current status of `my_set` :
My set = {""Pippin"", ""Frodo"", ""Bilbo"", ""Merry"", ""Sam""}",2023-11-15T12:43:12+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",valentinabertelli,"```
my_set = set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")
#my_set became:
#set ({""Frodo"", ""Merry"", ""Bilbo"", ""Pippin"", ""Sam""})
```
",2023-11-15T14:46:52+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",Alice-Ant,"my_set = set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")
print (my_set)

The output is: {'Merry', 'Frodo', 'Bilbo', 'Pippin', 'Sam'}",2023-11-15T17:53:59+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",katyakrsn,"```
s1 = {""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
print(s1)
```",2023-11-15T18:03:15+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",ThIheb,"```
set1 = set()
set1.add(""Bilbo"")
set1.add(""Frodo"")
set1.add(""Sam"")
set1.add(""Pippin"")
set1.add(""Merry"")
```",2023-11-15T18:11:01+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",qwindici,"```
# 1st way
characters = set([""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""])

# 2nd way
characters_2 = {""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""}

# 3rd way
characters_3 = set()
character_list = [""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""]
for character in character_list: 
   characters_3.add(character)
```",2023-11-16T11:29:43+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",krzywonos,"`hobbits = {""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""}`",2023-11-16T17:41:59+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",MariaFrancesca6,"```py
the_hobbits = set()
the_hobbits.add(""Bilbo"")
the_hobbits.add(""Frodo"")
the_hobbits.add(""Sam"")
the_hobbits.add(""Pippin"")
the_hobbits.add(""Merry"")
print(the_hobbits)

the_hobbits = {'Bilbo', 'Frodo', 'Merry', 'Pippin', 'Sam'}
```",2023-11-16T20:39:13+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",rufferbaraldi,"```
tolkien_set = set()
tolkien_set.add(""Bilbo"")
tolkien_set.add(""Frodo"")
tolkien_set.add(""Sam"")
tolkien_set.add(""Pippin"")
tolkien_set.add(""Merry"")
print(tolkien_set)

{'Sam', 'Frodo', 'Pippin', 'Bilbo', 'Merry'}
```",2023-11-16T21:42:05+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",enricabruno,"1)
``` py
 # create a set
person_set = set({""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
# print the set
print(person_set)
```
2)
``` py
# create an empy set
person_set = set()
# add elements
person_set.add(""Bilbo"")
person_set.add(""Frodo"")
person_set.add(""Sam"")
person_set.add(""Pippin"")
person_set.add(""Mery"")
#print the set 
print(person_set)
```

output: {'Mery', 'Pippin', 'Frodo', 'Bilbo', 'Sam'}


",2023-11-18T09:33:22+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",frammenti,"```python
hobbits = [""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""]
my_set = set(hobbits)
```",2023-11-18T18:56:46+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",alicepiazzi,"```
my_first_set = set()  # create an empy set
my_first_set.add (""Bilbo"")  # add elements
my_first_set.add (""Frodo"")
my_first_set.add (""Sam"")
my_first_set.add (""Pippin"")
my_first_set.add (""Merry"")
print (my_first_set) #print the set 

my_first_set = {""Sam"", ""Pippin"", ""Merry"", ""Frodo"", ""Bilbo""}
```",2023-11-18T19:11:24+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",saramadonia,"""​Bilbo""​, ""​Frodo""​, ""​Sam""​, ""​Pippin""​, ""​Merry""​
# 1 shortcut
hobbit_set = {""Sam"", ""Pippin"", ""Merry"", ""Frodo"", ""Bilbo""}

# 2
hobbit_set = set()
hobbit_set.add(""Bilbo"")
hobbit_set.add(""Frodo"")
hobbit_set.add(""Sam"")
hobbit_set.add(""Pippin"")
hobbit_set.add(""Merry"")

# 3
hobbits = [​Bilbo""​, ""​Frodo""​, ""​Sam""​, ""​Pippin""​, ""​Merry""​]
hobbit_set = set(hobbits)",2023-11-19T12:53:34+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",Sergpoipoip,"`hobbits = set([""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""])`",2023-11-19T15:20:51+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",Chiaramartina,"my_set=set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Marry"")
print (my_set)

my_set={'Bilbo', 'Pippin', 'Marry', 'Frodo', 'Sam'}
",2023-11-19T16:10:46+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",simocasaz,"`a_set = {""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""}`",2023-11-19T16:12:22+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",matildepassafaro,"```
# create empty set
my_set = set()
# add items to the set
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")
# print the set
print(my_set)
```",2023-11-19T16:27:23+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",CarlaMenegat,"![Captura de Tela 2023-11-19 às 19 49 50](https://github.com/comp-think/2023-2024/assets/146187896/7cfebd31-910e-4f9f-87da-230bf90a392b)

![Captura de Tela 2023-11-19 às 19 51 54](https://github.com/comp-think/2023-2024/assets/146187896/cbb6ee4a-d0bf-437a-90b2-c502b7e06b59)
",2023-11-19T18:52:37+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",VirginiaDa00,"<img width=""596"" alt=""es 1 lez 7"" src=""https://github.com/comp-think/2023-2024/assets/147997710/f94b397c-0eda-4bf4-b243-e853454c5d7a"">
",2023-11-20T07:55:55+00:00
comp-think/2023-2024,"Lecture ""Organising information: unordered structures"", exercise 1",annapasetto0,"#first way
lord_set = {""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
print(lord_set)

#second way
lord_list = [""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""]
lord_set_2 = set(lord_list)
print(lord_set_2)

#third way
lord_set_3 = set()
lord_set_3.add(""Bilbo"")
lord_set_3.add(""Frodo"")
lord_set_3.add(""Sam"")
lord_set_3.add(""Pippin"")
lord_set_3.add(""Merry"")
print(lord_set_3)",2023-11-27T17:18:27+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 5",vattelalberto,"```
def test_my_reversed(input_list, expected):
    result = my_reversed(input_list)
    if result == expected:
        return True
    else:
        return False

def my_reversed(input_list):
    reversed_list = list()
    n = len(input_list)
    while n > 0:
        reversed_list.append(input_list[n - 1])
        n = n-1
    return reversed_list

print(test_my_reversed(list([""a"", ""b"", ""c""]), list([""c"", ""b"", ""a""])))
print(test_my_reversed(list([""a"", ""b"", ""c"", 123, ""test""]), list([""test"", 123, ""c"", ""b"", ""a""])))
print(test_my_reversed(list([""a"", ""b"", ""c""]), list([""d"", 15, ""a""])))
```",2023-11-13T19:28:55+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 5",valetedd,"```
def test_my_reversed(input_list, expected):
    if my_reversed(input_list) == expected:
        return True
    else: 
        return False

def my_reversed(input_list):
    reversed_list = input_list[::-1]
    return reversed_list

print(test_my_reversed(list([0, 1, 2, 3]), list([3, 2, 1, 0])))
```
Otherwise:
```
def test_my_reversed(input_list, expected):
    if my_reversed(input_list) == expected:
        return True
    else: 
        return False

def my_reversed(input_list):
    rev_list = list()
    index_list = range(1, len(input_list) + 1)
    for i in index_list:
        rev_list.append(input_list[-i])
    return rev_list

print(test_my_reversed(list([1, 2, 3, 4]), list([4, 3, 2, 1])))",2023-11-14T00:58:37+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 5",Liber-R,"![Screenshot 2023-11-14 094318](https://github.com/comp-think/2023-2024/assets/132198967/e8ebbd1c-15cb-4100-aa7e-687ee000fb2d)
",2023-11-14T08:44:00+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 5",frammenti,"```python
# Test case for the algorithm
def test_my_reversed(input_list,expected):
    result = my_reversed(input_list)
    if expected == result:
        return True
    else:
        return False

# Code of the algorithm
def my_reversed(input_list):
    reversed_list = [] # A new empty list where to store the result
    # List comprehension that iters through index number and appends the negative-1
    # indexed item to the output list (e.g. for index 0 the -1 indexed (last) item)
    reversed_list = [input_list[0-(i+1)] for i in range(len(input_list))]
    return reversed_list

print(test_my_reversed([1, 2, 3, 4], [4, 3, 2, 1])) # True
print(test_my_reversed([""a"", ""b"", ""c"", ""d""], [""d"", ""c"", ""b"", ""a""])) # True
print(test_my_reversed([4, 3, 2, 1], [1, 2, 3, 4])) # True
print(test_my_reversed([0, 1, 0, 1, 1], [1, 1, 0, 1, 0])) # True
print(test_my_reversed([1], [1])) # True
print(test_my_reversed([], [])) # True

```",2023-11-14T14:54:07+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 5",colakogluezgi00,"```
def my_reversed(input_list):
    reversed_list = list()
    i = len(input_list)
    while i > 0:
        reversed_list.append(input_list[i-1])
        i-=1    
    return reversed_list

def test(input,expectation):
    if input == expectation:
        return True
    else:
        return False
    
dhdk = [""comp-think"",""tram"",""sedt"",""tesr""]
reversed_dhdk = dhdk[::-1]
print(test(my_reversed(dhdk),reversed_dhdk))
```",2023-11-14T22:29:34+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 5",qwindici,"```
def my_reversed(input_list):
    reversed_list = []
    for item in input_list:
        reversed_list.insert(0, item)
    return reversed_list

# test function
def test_my_reversed(input_list, expected):
    if my_reversed(input_list) == expected:
        return True
    else:
        return False

# test cases
test_my_reversed([1, 2, 3, 4], [4, 3, 2, 1])
test_my_reversed([], [])
test_my_reversed([3, 2, 1], [1, 2, 3])
test_my_reversed(['Hey'], ['Hey'])
```",2023-11-15T17:14:38+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 5",rufferbaraldi,"```
def test_my_reversed(input_list, expected):
    result = my_reversed(input_list)
    if expected == result:
        return True
    else:
        return False


def my_reversed(input_list):
    reversed_list = []
    for item in input_list:
        reversed_list.insert(0, item)
    return reversed_list

print(test_my_reversed([1, 2, 3, 4], [4, 3, 2, 1]))
print(test_my_reversed([""a"", ""b"", ""c"", ""d""], [""d"", ""c"", ""b"", ""a""]))
print(test_my_reversed([0], [0]))
```",2023-11-16T08:24:41+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 5",valentinabertelli,"```
def test_my_reversed(input_list, expected):
    result = my_reversed(input_list)
    if result == expected:
        return True
    else:
        return False

def my_reversed(input_list):
    result_list = []
    for item in input_list:
      result_list.insert(0, item)
    return result_list    
    
print(test_my_reversed(([0, 1, 2, 3]), ([3, 2, 1, 0])))  
```",2023-11-17T14:18:22+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 5",enricabruno,"``` py
# test function
def test_my_reverse(reverse_number, expected):
    result = my_reverse(reverse_number)
    if result == expected:
        return True
    else:
        return False
# function
def my_reverse(reverse_number):
    reverse_list = list()
    n = 0
    while reverse_number > n:
        reverse_list.append(n)
        n += 1
    return reverse_list

# three tests run
print(test_my_reverse(-1, ([0, 1, 2])))
print(test_my_reverse(2, ([0, 1, 2])))
print(test_my_reverse(3, ([0, 1, 2])))
```

1° output: False
2nd output: False
3rd output: True",2023-11-19T11:24:56+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 5",Sergpoipoip,"```
def test_my_reversed(input_list, expected):
    result = my_reversed(input_list)
    return result == expected

def my_reversed(input_list):
    res = []
    for i in range(1, len(input_list)+1):
        res.append(input_list[-i])
    return res

print(test_my_reversed(['a', 'b', 'c', 'd'], ['d', 'c', 'b', 'a']))
print(test_my_reversed([0], [0]))
```",2023-11-19T15:01:25+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 5",simocasaz,"```
from collections import deque

def test_my_reversed(input_list, expected):
    result = my_reversed(input_list)
    if result == expected:
        return True
    else:
        return False
    
def my_reversed(input_list):
    my_stack = deque()
    my_stack.extend(input_list)
    copied_stack = my_stack.copy()
    reversed_list = list()

    for item in my_stack:
        item = copied_stack.pop()
        reversed_list.append(item)

    return reversed_list
    
print(test_my_reversed([""Batman"", ""Superman"", ""Flash"", ""Wonder Woman"", ""Joker"", ""Cyborg""], ['Cyborg', 'Joker', 'Wonder Woman', 'Flash', 'Superman', 'Batman']))
print(test_my_reversed([""Batman"", ""Superman"", ""Batman"", ""Flash""], ['Flash', 'Batman', 'Superman', 'Batman']))
print(test_my_reversed([""Batman""], [""Batman""]))
print(test_my_reversed([], []))
```",2023-11-19T15:12:36+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 5",CarlaMenegat,"![Captura de Tela 2023-11-19 às 19 32 33](https://github.com/comp-think/2023-2024/assets/146187896/52750536-7207-412f-a528-387e5e24c69b)
",2023-11-19T18:33:25+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 5",MariaFrancesca6,"```py
def test_my_reversed(input_list, expected):
    result = my_reversed(input_list)
    if result == expected:
        return True
    else:
        return False

def my_reversed(input_list):
    output_list = list()
    # n is the number of items in the input_list that is the same for the output_list
    # and n is also used for indexing items
    n = len(input_list)
    for item in input_list:
        # appending to the first position of the output_list
        # the item that stands in the last position of the input_list
        output_list.append(input_list[n-1])
        n -= 1
    return output_list
    
print(test_my_reversed([],[]))
print(test_my_reversed([0,1],[1,0]))
print(test_my_reversed([6,7,8,9],[9,8,7,6]))
```",2023-11-19T21:40:15+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 4",vattelalberto,"```
def test_my_range(stop_number, expected):
    result = my_range(stop_number)
    if result == expected:
        return True
    else:
        return False

def my_range(stop_number):
    range_list = list()
    n=0
    while stop_number > n:
        range_list.append(n)
        n += 1
    return range_list

print(test_my_range(5, list([0, 1, 2, 3, 4])))
print(test_my_range(2, list([0, 1, 2])))
print(test_my_range(0, list()))
```",2023-11-13T19:19:28+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 4",valetedd,"```
def test_my_range(stop_number, expected):
    if my_range(stop_number) == expected:
        return True
    else:
        return False

def my_range(stop_number):
    result = list()
    n = 0
    while n < stop_number:
        result.append(n)
        n += 1
    return result

print(test_my_range(4, list([0, 1, 2, 3])))",2023-11-13T23:44:23+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 4",Liber-R,"![Screenshot 2023-11-15 093141](https://github.com/comp-think/2023-2024/assets/132198967/266cad5c-9539-4960-960c-9eafde2ae582)


",2023-11-14T08:42:43+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 4",frammenti,"```python
# Test case for the algorithm
def test_my_range(stop_number,expected):
    result = my_range(stop_number)
    if expected == result:
        return True
    else:
        return False

# Code of the algorithm
def my_range(stop_number):
    my_range = [] # A new empty list where to store the result
    n = 0 # range() counter starts from 0
    # Each cycle the number is appended to the list and increased by 1
    while n < stop_number: # Last number listed is stop_number - 1
        my_range.append(n)
        n += 1
    return my_range

print(test_my_range(8, [0, 1, 2, 3, 4, 5, 6, 7])) # True
print(test_my_range(1, [0])) # True
print(test_my_range(0, [])) # True
```",2023-11-14T09:52:56+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 4",colakogluezgi00,"```
def my_range(stop_number):
    return_list = list()
    i=0
    while i<stop_number:
        return_list.append(i)
        i+=1
    return return_list

def test(input, expectation):
    ls = list()
    for i in my_range(len(input)):
      ls.append((i, input[i]))
    if ls==expectation:
        return True
    else:
        return False        

dhdk = [""comp-think"",""tram"",""sedt"",""tesr""]
print(test(dhdk,list(enumerate(dhdk))))
```",2023-11-14T22:29:31+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 4",qwindici,"```
def my_range(stop_number):
    counter = 0
    range_list = []
    while counter < stop_number:
        range_list.append(counter)
        counter += 1
    return range_list


def test_my_range(stop_number, expected):
    if my_range(stop_number) == expected:
        return True
    else:
        return False

# tests
print(test_my_range(5, [0, 1, 2, 3, 4]))
print(test_my_range(0, []))
print(test_my_range(1, [0]))
```",2023-11-15T16:43:43+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 4",rufferbaraldi,"```
def test_my_range(stop_number, expected):
     result = my_range(stop_number)
     if result == expected:
          return True
     else:
           return False

def my_range(stop_number):
    range_list = []
    while stop_number > 0:
          stop_number = stop_number - 1
          range_list.append(stop_number)
    return reversed(range_list)

print(test_my_range(6, [0, 1, 2, 3, 4, 5]))


#edited after seaching the function reverse()

def test_my_range(stop_number, expected):
     result = my_range(stop_number)
     if result == expected:
          return True
     else:
           return False

def my_range(stop_number):
    range_list = []
    while stop_number > 0:
          stop_number = stop_number - 1
          range_list.append(stop_number)
    range_list.reverse()
    return range_list
    

print(test_my_range(6, [0, 1, 2, 3, 4, 5]))
```",2023-11-15T20:07:12+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 4",valentinabertelli,"```
def test_my_range(stop_number, expected):
    result = my_range(stop_number)
    if result == expected:
        return True
    else:
        return False
    
def my_range(stop_number):
    result_list = []
    while stop_number > 0:
        stop_number -= 1
        result_list.insert(0, stop_number)    
    return result_list 

print(test_my_range(4, ([0, 1, 2, 3])))
```",2023-11-17T13:39:31+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 4",enricabruno,"``` py
# test function
def test_my_range(stop_number, expected):
    result = my_range(stop_number)
    if result == expected:
        return True
    else:
        return False
# function
def my_range(stop_number):
    range_list = list()
    n = 0
    while stop_number > n:
        range_list.append(n)
        n += 1
    return range_list

# two tests run
print(test_my_range(5, ([0, 1, 2, 3, 4, 5])))
print(test_my_range(5, ([0, 1, 2, 3, 4])))
```
1° output: False
2nd output: True",2023-11-19T11:17:02+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 4",simocasaz,"```
from collections import deque

def test_my_range(stop_number, expected):
    result = my_range(stop_number)
    if result == expected:
        return True
    else:
        return False

def my_range(stop_number):
    output_stack = deque()
    output_list=list()
    
    while stop_number > 0:
        stop_number -= 1
        output_stack.append(stop_number)

    clone_output_stack = output_stack.copy()

    for item in output_stack:
        item = clone_output_stack.pop()
        output_list.append(item)
    
    return output_list
    
print(test_my_range(10, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]))
print(test_my_range(1, [0]))
print(test_my_range(2, [0, 1]))
print(test_my_range(0, []))
```
",2023-11-19T12:33:58+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 4",Sergpoipoip,"```
def test_my_range(stop_number, expected):
    result = my_range(stop_number)
    return result == expected

def my_range(stop_number):
    i = 0
    res = []
    while i < stop_number:
        res.append(i)
        i += 1
    return res

print(test_my_range(0, []))
print(test_my_range(5, [0, 1, 2, 3, 4])
```",2023-11-19T14:46:03+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 4",matildepassafaro,"```
# test case for the function
def test_my_range(stop_number, expected):
    result = my_range(stop_number)
    if result == expected:
        return True
    else:
        return False
    
# define the function my_range
def my_range(stop_number):
    l = [0, 1, 2, 3, 4, 5]
    output_list = list()
    if stop_number >= 0:
        for item in l:
            if item < stop_number:
                output_list.append(item)
    print(output_list)
    return(output_list)

# test runs
print(test_my_range(3, [0, 1, 2]))
print(test_my_range(0, []))
print(test_my_range(1, [0]))
```",2023-11-19T17:06:26+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 4",CarlaMenegat,"![Captura de Tela 2023-11-19 às 18 58 01](https://github.com/comp-think/2023-2024/assets/146187896/edd659ee-e499-4461-86dc-3b32158b0728)
",2023-11-19T17:58:43+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 4",MariaFrancesca6,"```py
def test_my_range(stop_number, expected):
    result = my_range(stop_number)
    if result == expected:
        return True
    else: 
        return False

def my_range(stop_number):
    output_list = list()
    # set a counter standing for the position of the item in the list
    x = 0
    while x < stop_number:
        output_list.append(x)
        x += 1
    return output_list

print(test_my_range(0,[]))
print(test_my_range(5,[0,1,2,3,4]))
```",2023-11-19T21:29:52+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 3",vattelalberto,"```
def test_my_enumerate(input_list, expected):
    result = my_enumerate(input_list)
    if result == expected:
        return True
    else:
        return False

def my_enumerate(input_list):
    enumerate_list = list()
    n = 0
    for item in input_list:
        item_tuple = (n, item)
        enumerate_list.append(item_tuple)
        n = n+1
    return enumerate_list

print(test_my_enumerate(list([""a"", ""b"", ""c""]), list([(0, ""a""), (1, ""b""), (2, ""c"")])))
print(test_my_enumerate(list([""a"", ""b"", ""c""]), list([(1, ""a""), (5, ""b""), (2, ""d"")])))
```",2023-11-13T19:12:23+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 3",valetedd,"```
def test_my_enumerate(input_list, expected):
    if my_enumerate(input_list) == expected:
        return True
    else:
        return False

def my_enumerate(input_list):
    index_list = range(len(input_list))
    result = list()
    for item in index_list:
        result.append((item, input_list[item]))
    
    return result

print(test_my_enumerate(list([""a"", ""b"", ""c"",]), list([(0, ""a""), (1, ""b""), (2, ""c"")])))
```",2023-11-13T21:47:34+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 3",Liber-R,"![Screenshot 2023-11-15 100647](https://github.com/comp-think/2023-2024/assets/132198967/4e3892e7-e707-409d-8cd4-939e2ad47ea8)


",2023-11-14T08:40:24+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 3",frammenti,"```python
# Test case for the algorithm
def test_my_enumerate(input_list,expected):
    result = my_enumerate(input_list)
    if expected == result:
        return True
    else:
        return False

# Code of the algorithm
def my_enumerate(input_list):
    output_list = [] # A new empty list where to store the result
    # List comprehension to fill the output list with tuples of paired index number and element of input_list
    output_list = [(i, input_list[i]) for i in range(len(input_list))]
    return output_list

# Test 1: List of Thomas Bernhard's major novels in chronological order
book_list = [""Perturbamento"", ""La fornace"", ""Correzione"", ""Il nipote di Wittengstein"", ""Il soccombente"", ""A colpi d'ascia"", ""Antichi Maestri"", ""Estinzione""]
book_list_enumerated = [(0, ""Perturbamento""), (1, ""La fornace""), (2, ""Correzione""), (3, ""Il nipote di Wittengstein""), (4, ""Il soccombente""), (5, ""A colpi d'ascia""), (6, ""Antichi Maestri""), (7, ""Estinzione"")]

# Test 2: Same list sorted alphabetically
book_list_sorted = sorted(book_list)
book_list_sorted_enumerated = [(0, ""A colpi d'ascia""), (1, ""Antichi Maestri""), (2, ""Correzione""), (3, ""Estinzione""), (4, ""Il nipote di Wittengstein""), (5, ""Il soccombente""), (6, ""La fornace""), (7, ""Perturbamento"")]

# Test 3: Same list with one element removed
book_list_popped = book_list.copy()
book_list_popped.pop(2)
book_list_popped_enumerated = [(0, ""Perturbamento""), (1, ""La fornace""), (2, ""Il nipote di Wittengstein""), (3, ""Il soccombente""), (4, ""A colpi d'ascia""), (5, ""Antichi Maestri""), (6, ""Estinzione"")]

print(test_my_enumerate(book_list, book_list_enumerated))
print(test_my_enumerate(book_list_sorted,book_list_sorted_enumerated))
print(test_my_enumerate(book_list_popped, book_list_popped_enumerated))
```",2023-11-14T09:18:45+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 3",colakogluezgi00,"```
def my_enumerate(input_list):
    enum_list = list()
    for i in range(len(input_list)):
        enum_list. append((i, input_list[i])) 
    return enum_list

def test(input,expectation):
    if input == expectation:
        return True
    else:
        return False

dhdk = [""comp-think"",""tram"",""sedt"",""tesr""]
enum_dhdk = list(enumerate(dhdk))
print(test(my_enumerate(dhdk),enum_dhdk))
```",2023-11-14T22:29:28+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 3",qwindici,"```
def my_enumerate(input_list):
    counter = 0
    enumerated_list = []
   
    for item in input_list:
        enumerated_list.append((counter, item))
        counter += 1
    return enumerated_list

def test_my_enumerate(input_list, expected):
    result = my_enumerate(input_list)
    if result == expected:
        return True
    else:
        return False

# test cases 
print(
    test_my_enumerate([""Hi"", ""how"", ""are"", ""you""], [(0, ""Hi""), (1, ""how""), (2, ""are""), (3, ""you"")])
    
) # normal list
print(test_my_enumerate([], [])) # empty list
print(test_my_enumerate(['one element'], [(0, 'one element')])) # one element list

```",2023-11-15T16:30:32+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 3",rufferbaraldi,"```
def test_my_enumerate(input_list, expected):
     result = my_enumerate(input_list)
     if result == expected:
          return True
     else:
           return False

def my_enumerate(input_list):
     list_counter = 0
     output_list = []
     for item in input_list:        
        output_list.append((list_counter, item))
        list_counter = list_counter + 1
     return output_list

print(test_my_enumerate([""a"", ""b"", ""c""], [(0, ""a""), (1, ""b""), (2, ""c"")]))
print(test_my_enumerate([""a""], [(0, ""a"")]))
print(test_my_enumerate([], []))
```",2023-11-15T19:07:46+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 3",valentinabertelli,"```
def test_my_enumerate(input_list, expected):
    test_result = my_enumerate(input_list)
    if test_result == expected:
        return True
    else:
        return False

def my_enumerate(input_list):
    result = list([])
    for item in input_list:
       position = input_list.index(item)
       my_tuple = (position, item)
       result.append(my_tuple)
    return result   
       

print(test_my_enumerate(list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]), list([(0, ""Coraline""), (1, ""American Gods""), (2, ""The Graveyard Book""), (3, ""Good Omens""), (4, ""Neverwhere"")])))
```",2023-11-16T19:00:02+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 3",Sergpoipoip,"```
def test_my_enumerate(input_list, expected):
    return my_enumerate(input_list) == expected

def my_enumerate(input_list):
    res = []
    for i in range(len(input_list)):
        res.append((i, input_list[i]))
    return res

print(test_my_enumerate([12, 'q', 3, {'a':1}], [(0, 12), (1, 'q'), (2, 3), (3, {'a':1})]))
```",2023-11-17T08:52:41+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 3",simocasaz,"This is the final function

```
def test_enum(input_list, expected):
    result = enum(input_list)
    if result == expected:
        return True
    else:
        return False

def enum(input_list):
    output_list = list()
    position = 0
    for item in input_list:
        new_tuple = (position, item)
        output_list.append(new_tuple)
        position += 1
    
    return output_list

print(test_enum([""Giovanna"", ""Luigi"", ""Pietro"", ""Lara"", ""Giulia""], [(0, ""Giovanna""), (1, ""Luigi""), (2, ""Pietro""), (3, ""Lara""), (4, ""Giulia"")])) # usual input
print(test_enum([""Berlin"", 2, ""Rome"", ""Rome""], [(0, ""Berlin""), (1, 2), (2, ""Rome""), (3, ""Rome"")])) # strange input: repetition of same elements and different data types in the input list
print(test_enum([""Wien""], [(0, ""Wien"")])) # strange input: just one element
print(test_enum([], [])) # strange input: empty list as input

```


I have to say that the tests were very useful. I failed twice before getting the right answer.
First fail:
```
def enum(input_list):
    output_list = list()
    for item in input_list:
        position = input_list.index(item)
        new_tuple = (position, item)
        output_list.append(new_tuple)
        
    return output_list
```
In this first function I used list.index(x) without remembering that if there is more than one item with value x, this method will return the first index location. I discovered the error by running the test using the input with repeated values.
Second fail:

```
def enum(input_list):
    output_list = list()
    for item in input_list:
        position = 0
        new_tuple = (position, item)
        output_list.append(new_tuple)
        position += 1
    
    return output_list
```
Here all the tests failed. I realized that I had to assign the value 0 to the position variable outside the for loop, otherwise the computer would have assigned the value 0 to the variable at every iteration.",2023-11-17T17:22:00+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 3",enricabruno,"``` py
# test function
def test_my_enumerate(input_list, expected):
    result = my_enumerate(input_list)
    if result == expected:
        return True
    else:
        return False

# function
def my_enumerate(input_list):
    output_list = list()
    position = 0
    for item in input_list:
        my_tuple = (position, item)
        output_list.append(my_tuple)
        position += 1
    return output_list

# two tests run
print(test_my_enumerate([""a"", ""b"", ""c"", ""d""], [(1, ""a""), (2, ""b""), (3, ""c""), (4, ""d"")]))
print(test_my_enumerate([""a"", ""b"", ""c"", ""d""], [(0, ""a""), (1, ""b""), (2, ""c""), (3, ""d"")]))
```

1° output: False
2nd output: True",2023-11-19T11:03:21+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 3",CarlaMenegat,"![Captura de Tela 2023-11-19 às 17 45 35](https://github.com/comp-think/2023-2024/assets/146187896/c649dc84-bfce-4a89-80fe-5f6dd9cbbef2)
",2023-11-19T16:46:07+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 3",MariaFrancesca6,"```py
def test_my_enumerate(input_list,expected):
    result = my_enumerate(input_list)
    if result == expected:
        return True
    else:
        return False

def my_enumerate(input_list):
    output_list = list()
    # set a variable equal to 0 that stands for the position of the first item 
    x=0
    for item in input_list:
        # the final result is a list of tuples
        tuple = (x,item)
        output_list.append(tuple)
        # increment by one the position each time until the end of the loop
        x = x+1
    return output_list
    
print(test_my_enumerate([],[]))
print(test_my_enumerate([1,2,3,33,3],[(0,1),(1,2),(2,3),(3,33),(4,3)]))
```",2023-11-19T21:00:34+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 2",vattelalberto,"```
from collections import deque

def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if result == expected:
        return True
    else:
        return False

def stack_from_list(input_list):
    output_stack = deque() # the stack to create
    # Iterate each element in the input list and add it to the stack
    for item in input_list:
        output_stack.append(item)
    return output_stack

print(test_stack_from_list(list([""a"", ""b"", ""c""]), deque([""a"", ""b"", ""c""])))
print(test_stack_from_list(list([""a"", ""b"", ""c""]), deque([""g"", ""b"", ""c""])))
```",2023-11-13T18:48:19+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 2",Liber-R,"![Screenshot 2023-11-14 093720](https://github.com/comp-think/2023-2024/assets/132198967/42e7718b-0715-4c98-8e16-01d6cc51b47d)
![Screenshot 2023-11-14 093734](https://github.com/comp-think/2023-2024/assets/132198967/97972b10-ffff-481a-a59a-e027fcfdd57c)
",2023-11-14T08:38:54+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 2",rufferbaraldi,"```
from collections import deque

def test_stack_from_list(input_list, prediction):
     result = stack_from_list(input_list)
     if result == prediction:
          return True
     else:
          return False

def stack_from_list(input_list):
     output_stack = deque() 
     for item in input_list:
          output_stack.append(item)
     return output_stack

print(test_stack_from_list([""1"", ""2"", ""3""], deque([""1"", ""2"", ""3""])))
```",2023-11-14T21:11:04+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 2",ThIheb,"from collections import deque

def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if result == expected:
        return True
    else:
        return False

def stack_from_list(input_list):
    output_stack = deque() # the stack to create
    # Iterate each element in the input list and add it to the stack
    for item in input_list:
        output_stack.append(item)
    return output_stack

print(test_stack_from_list(list([""1"", ""2"", ""3""]), deque([""1"", ""2"", ""3""])))
print(test_stack_from_list(list([""1"", ""2"", ""3""]), deque([""2"", ""2"", ""3""])))",2023-11-14T21:23:44+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 2",colakogluezgi00,"```
def test(input, expectation):
    if input == expectation:
        return True
    else:
        False

dhdk = [""comp-think"",""tram"",""sedt"",""tesr""]
deque_dhdk=deque(dhdk)
print(test(stack_from_list(dhdk),deque_dhdk))
```",2023-11-14T22:29:20+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 2",MariaFrancesca6,"```py

def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if expected == result:
        return True
    else:
        return False

from collections import deque

def stack_from_list(input_list):
    output_stack = deque() 
    for item in input_list:
        output_stack.append(item)
    return output_stack

print(test_stack_from_list([],deque()))
print(test_stack_from_list([0,1,2,3], deque([0,1,2,3])))
```
Now the test returns True: 
![image](https://github.com/comp-think/2023-2024/assets/146453979/27f33cfd-a6d7-400b-96ca-c80e1e184cc3)
",2023-11-14T23:23:01+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 2",frammenti,"```python
from collections import deque

# Test case for the algorithm
def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if expected == result:
        return True
    else:
        return False

def stack_from_list(input_list):
    output_stack = deque()  # the stack to create

    # Iterate each element in the input list and add it to the stack
    for item in input_list:
        output_stack.append(item)

    return output_stack
    
book_list = [""Perturbamento"", ""La fornace"", ""Correzione"", ""Il nipote di Wittengstein"", ""Il soccombente"", ""A colpi d'ascia"", ""Antichi Maestri"", ""Estinzione""]
book_stack = deque([""Perturbamento"", ""La fornace"", ""Correzione"", ""Il nipote di Wittengstein"", ""Il soccombente"", ""A colpi d'ascia"", ""Antichi Maestri"", ""Estinzione""])

print(test_stack_from_list(book_list, book_stack)) # A case in point
print(test_stack_from_list([], deque([]))) # Empty list
print(test_stack_from_list([1], deque([1]))) # List of one item
```",2023-11-15T09:20:35+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 2",qwindici,"
```
from collections import deque
def stack_from_list(input_list):
   output_stack = deque() 
   for item in input_list:
      output_stack.append(item)
   return output_stack

def test_stack_from_list(input_list, expected):
   result = stack_from_list(input_list)
   if result == expected:
      return True
   else:
      return False
   
print(test_stack_from_list([1, 2, 3, 4, 5], deque([1, 2, 3, 4, 5])))
print(test_stack_from_list([], deque()))

```",2023-11-15T16:19:42+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 2",saramadonia,"from collections import deque

def test_stack_from_list(input_list, expected_output_stack)
    output_stack = stack_from_list(input_list)
    return expected_stack == output_stack


print(test_stack_from_list([""gemini"", ""virgo"", ""libra""], deque([""gemini"", ""virgo"", ""libra""]))

print(test_stack_from_list([1, 2, 3, 4), deque([1, 2, 3, 4]))",2023-11-16T07:36:38+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 2",valentinabertelli,"```
from collections import deque

def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if result == expected:
        return True
    else:
        return False
        
def stack_from_list(input_list):
    output_stack = deque()
    for item in input_list:
        output_stack.append(item)
    return output_stack    
        
print(test_stack_from_list(list([""a"", ""b"", ""c""]), deque([""a"", ""b"", ""c""])))
```",2023-11-16T14:57:53+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 2",Sergpoipoip,"```
from collections import deque

def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if result == expected:
        return True
    else:
        return False

def stack_from_list(input_list):
    output_stack = deque()
    for item in input_list:
        output_stack.append(item)
    return output_stack

print(test_stack_from_list([4, 6, 7, 1], deque([4, 6, 7, 1]))
```",2023-11-16T18:18:04+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 2",simocasaz,"```
from collections import deque

def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if expected == result:
        return True
    else:
        return False


def stack_from_list(input_list):
    output_stack = deque()

    for item in input_list:
        output_stack.append(item)

    return output_stack


print(test_stack_from_list([""Torino"", ""Milano"", ""Bari"", ""Roma"", ""Foggia""], deque([""Torino"", ""Milano"", ""Bari"", ""Roma"", ""Foggia""]))) # usual input
print(test_stack_from_list([""Luigi""], deque([""Luigi""]))) # strange input: just one element
print(test_stack_from_list([""Giovanna"", 1, ""Giovanna"", 6], deque([""Giovanna"", 1, ""Giovanna"", 6]))) #strange input: repetition of same elements and different data types in the input list
print(test_stack_from_list([], deque([]))) # strange input: the input list is empty
```",2023-11-17T16:05:42+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 2",enricabruno,"``` py
# test function to create a stack from a list
def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if result == expected:
        return True
    else:
        return False
        
from collections import deque
        
# function to create a stack from a list
def stack_from_list(input_list):
    output_stack = deque() 
    # for-each loop execution
    for item in input_list:
        output_stack.append(item)
    return output_stack
   
# test run
print(test_stack_from_list(list([""Ciao"", ""Sono"", ""Giorgia""]), deque([""Ciao"", ""Sono"", ""Giorgia""])))
```

output: True",2023-11-19T10:20:12+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 2",CarlaMenegat,"![Captura de Tela 2023-11-19 às 17 11 17](https://github.com/comp-think/2023-2024/assets/146187896/7fb3c329-51f2-4881-8764-28defb6ed447)
",2023-11-19T16:12:30+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 1",vattelalberto,"FOR-EACH LOOP EXECUTION
enumerate(input_list) will result in:
enumerate([(0, ""Coraline""), (1, ""American Gods""),
(2, ""The Graveyard Book""), (3, ""Good Omens""),
(4, ""Neverwhere"")])

Iteration 1
position = 0
item =""Coraline""
item == value_to_search is False
Continue to next iteration

Iteration 2
position = 1
item =""American Gods""
item == value_to_search is False
Continue to next iteration

Iteration 3
position = 2
item =""The Graveyard Book""
item == value_to_search is False
Continue to next iteration

Iteration 4
position = 3
item =""Good Omens""
item == value_to_search is False
Continue to next iteration

Iteration 5
position = 4
item =""Neverwhere""
item == value_to_search is False
Return `None` and end the execution of the algorithm",2023-11-13T18:30:19+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 1",valetedd,"FOR-EACH LOOP EXECUTION
enumerate(input_list) will result in:
enumerate([(0, ""Coraline""), (1, ""American Gods""),
(2, ""The Graveyard Book""), (3, ""Good Omens""),
(4, ""Neverwhere"")])

Iteration 1
position = 0
item = ""Coraline""
item == value_to_search is False
Continue to the next iteration

Iteration 2
position = 1
item = ""American Gods""
item == value_to_search is False
Continue to the next iteration

Iteration 3
position = 2
item = ""The Graveyard Book""
item == value_to_search is False
Continue to the next iteration

Iteration 4
position = 3
item = ""Good Omens""
item == value_to_search is False
Continue to the next iteration

Iteration 5
position = 4
item = ""Neverwhere""
item == value_to_search is False
No further iteration in the loop is possible: break the loop.
Return ´´´None´´´ and end the execution of the algorithm.",2023-11-13T20:58:10+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 1",Alice-Ant,"We begin with enumerating the book list, assigning an index to each book. Then we define a function to check if the search book is on the list by comparing the titles. If the book is not found we tell the program to return None, else we say that the book was found on the list.
If I understood and executed it all correctly we should get the following code with the result:
<img width=""593"" alt=""Screenshot 2023-11-13 at 10 23 25 pm"" src=""https://github.com/comp-think/2023-2024/assets/147634010/816c63bf-d33e-42be-94e4-402710b6c22e"">
",2023-11-13T21:27:56+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 1",Liber-R,"![Screenshot 2023-11-14 093427](https://github.com/comp-think/2023-2024/assets/132198967/e9f29aea-30b7-481e-80bf-3c15e1bf46d1)
![Screenshot 2023-11-14 093442](https://github.com/comp-think/2023-2024/assets/132198967/4f7171d8-194d-42b5-9451-343772e2bcbc)
",2023-11-14T08:35:28+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 1",ThIheb,"linear_search(list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]), ""The Sandman"")

FOR-EACH LOOP EXECUTION
 enumerate(input_list) will result in:
 enumerate([(0, ""Coraline), (1, ""American Gods""), (2, ""The Graveyard Book""), (3, ""Good Omens""), (4, ""Neverwhere""), (5, ""The Sandman"")])

Iteration 1
position = 0
item = ""Coraline""
item == value_to_search is False
Continue to next iteration

Iteration 2
position = 1
item = ""American Gods""
item == value_to_search is False
Continue to next iteration

Iteration 3
position = 2
item = ""The Graveyard Book""
item == value_to_search is False
Continue to next iteration

Iteration 4
position = 3
item = ""Good Omens""
item == value_to_search is False
Continue to next iteration

Iteration 5
position = 4
item = ""Neverwhere""
item == value_to_search is False

The loop stops here because there is no further positions in the list and the algorithm returns ""None""",2023-11-14T20:33:03+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 1",rufferbaraldi,"linear_search(list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]), ""The Sandman"")

FOR-EACH LOOP EXECUTION
enumerate(input_list) will result in:
enumerate([(0, ""Coraline""), (1, ""American Gods""), (2, ""The Graveyard Book""), (3, ""Good Omens""),(4, ""Neverwhere""), (5, ""The Sandman"")])

 Iteration 1
 position = 0
 item = ""Coraline""
 item == value_to_search is False
 Continue to the next iteration

 Iteration 2
 position = 1
 item = ""American Gods""
 item == value_to_search is False
 Continue to the next iteration

 Iteration 3
 position = 2
 item = ""The Graveyard Book""
 item == value_to_search is False
 Continue to the next iteration

Iteration 4
 position = 3
 item = ""Good Omens""
 item == value_to_search is False
 Continue to the next iteration

Iteration 5
 position = 4
 item = ""Neverwhere""
 item == value_to_search is False

 None is returned",2023-11-14T20:46:47+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 1",MariaFrancesca6,"list_of_books = list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""])
linear_search(list_of_books, ""The Sandman"")

FOR-EACH LOOP EXECUTION
enumerate(list_of_books) will result in:
enumerate([(0, ""Coraline""), (1, ""American Gods""), (2, ""The Graveyard Book""), (3, ""Good Omens""), (4, ""Neverwhere"")])

#Iteration 1
position = 0
item = ""Coraline""
item == value_to_search is False
#Continue to the next iteration

#Iteration 2
position = 1
item = ""American Gods""
item == value_to_search is False
#Continue to the next iteration

#Iteration 3
position = 2
item = ""The Graveyard Book""
item == value_to_search is False
#Continue to next iteration

#Iteration 4
position = 3
item = ""Good Omens""
item == value_to_search is False
#Continue to the next iteration

#Iteration 5
position = 4
item = ""Neverwhere""
item == value_to_search is False
#End of items, end of iterations
#No item matches the value_to_search
#Return none and end the execution of the algorithm",2023-11-14T22:42:15+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 1",saramadonia," execution steps of linear_search(list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]), ""The Sandman"")

following the algorithm 
def linear_search(input_list, value_to_search):
    for position, item in enumerate(input_list):
        if item == value_to_search:
            return position

#the function enumerate(input_list) creates a list of tuples and will result in:
enumerate([(0, ""Coraline""), (1, ""American Gods""), (2, ""The Graveyard Book""), (3, ""Good Omens""), (4, ""Neverwhere"")])

#for loops iterate thorugh each item and check  if the item is equal to the searched value until True
#iteration_1
position=0
item =""Coraline""
item == value_to_search is  False

#iteration_2
position=1
item =""American Gods""
item == value_to_search is  False

#iteration_3
position=2
item =""The Graveyard Book""
item == value_to_search is  False

#Iteration_4
position=3
item =""Good Omens""
item == value_to_search is  False

#iteration_5
position=4
item =""Neverwhere""
item == value_to_search is  False

#None is returned since no match is found between the items and the value_to_search


",2023-11-15T09:35:17+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 1",qwindici,"list_of_books = list([""Coraline"", ""American Gods"",
""The Graveyard Book"", ""Good Omens"",
""Neverwhere""]) linear_search(list_of_books, ""The Graveyard Book"")

#FOR-EACH LOOP EXECUTION
#enumerate(input_list) will result in:
#enumerate([(0, ""Coraline""), (1, ""American Gods""), (2, ""The Graveyard Book""), (3, ""Good Omens""), (4, ""Neverwhere"")]) 

#Iteration 1
#position = 0
#item = ""Coraline""
#item == value_to_search is False

#Continue to the next iteration

#Iteration 2
#position = 1
#item = ""American Gods""
#item == value_to_search is False

#Continue to the next iteration

#Iteration 3

#position = 2
#item = ""The Graveyard Book""
#item == value_to_search is False

#Continue to the next iteration

#Iteration 4

#position = 3
#item = ""Good Omens""
#item == value_to_search is False

#Continue to the next iteration

#Iteration 5

#position = 4
#item = ""Neverwhere""
#item == value_to_search is False

#The loop is over since there are no other elements in the list. 

#There are no other instructions in the function, so it automatically returns None. 

",2023-11-15T16:06:48+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 1",valentinabertelli,"```
list_of_books = list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""])           
linear_search(list_of_books, ""The Sandman"")

# FOR-EACH LOOP EXECUTION
# enumerate(input_list) will result in:
# enumerate([(0, ""Coraline""), (1, ""American Gods""), (2, ""The Graveyard Book""), (3, ""Good Omens""), (4, ""Neverwhere"")])
#
# Iteration 1
# position = 0
# item = ""Coraline""
# item == value_to_search is False
# Continue to the next iteration
#
# Iteration 2
# position = 1
# item = ""American Gods""
# item == value_to_search is False
# Continue to the next iteration
#
# Iteration 3
# position = 2
# item = ""The Graveyard Book""
# item == value_to_search is False
# Continue to the next iteration
#
# Iteration 4
# position = 3
# item = ""Good Omens""
# item == value_to_search is False
# Continue to the next iteration
#
# Iteration 5
# position = 4
# item = ""Neverwhere""
# item == value_to_search is False
# 
# ""The Sandman"" is not contained in list_of_books
# the iteration stops and None is returned
```",2023-11-16T14:24:07+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 1",Chiaramartina,"linear_search(list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]), ""The Sandman"")

FOR-EACH LOOP EXECUTION
enumerate(input_list) will result in:
enumerate([(0, ""Coraline""), (1, ""American Gods""), (2, ""The Graveyard Book""), (3, ""Good Omens""), (4, ""Neverwhere"")]))

iteration 1
position = 0
item = ”Coraline”
item==value to search is False

Continue to the next iteration

iteration 2
position = 1
item = ” American Gods”
item==value to search is False
Continue to the next iteration

iteration 3
position = 2
item = “The Graveyard Book”
item==value to search is False
Continue to the next iteration

iteration 4
position = 3
item = “Good Omens” 
item==value to search is False
Continue to the next iteration

iteration 5
position = 4
item = ” Neverwhere”
item==value to search is False
Continue to the next iteration

Return none and end the execution of the algorithm
",2023-11-16T14:59:39+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 1",Sergpoipoip,"```
# FOR-EACH LOOP EXECUTION
# enumerate(input_list) will result in:
# enumerate([(0, ""Coraline""), (1, ""American Gods""),
# (2, ""The Graveyard Book""), (3, ""Good Omens""),
# (4, ""Neverwhere"")])
#
# Iteration 1
# position = 0
# item = ""Coraline""
# item == value_to_search is False
# Continue to the next iteration
#
# Iteration 2
# position = 1
# item = ""American Gods""
# item == value_to_search is False
# Continue to the next iteration
#
# Iteration 3
# position = 2
# item = ""The Graveyard Book""
# item == value_to_search is False
# Continue to the next iteration
# 
# Iteration 4
# position = 3
# item = ""Good Omens""
# item == value_to_search is False
# Continue to the next iteration
# 
# Iteration 5
# position = 4
# item = ""Neverwhere""
# item == value_to_search is False
# Continue to the next iteration
# for-loop termiantion, function stops and return None as ""The Sandman"" is not in a given list
```",2023-11-16T18:04:54+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 1",simocasaz,"```
list_of_books = list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""])

def linear_search(input_list, value_to_search):
    for position, item in enumerate(input_list):
        if item == value_to_search:
            return position

linear_search(list_of_books, ""The Sandman"")

# FOR-EACH LOOP EXECUTION
# enumerate(input_list) will result in:
# enumerate([(0, ""Coraline""), (1, ""American Gods""),
# (2, ""The Graveyard Book""), (3, ""Good Omens""),
# (4, ""Neverwhere"")])
#
# Iteration 1
# position = 0
# item = ""Coraline""
# item == value_to_search is False
# Continue to the next iteration
#
# Iteration 2
# position = 1
# item = ""American Gods""
# item == value_to_search is False
# Continue to the next iteration
#
# Iteration 3
# position = 2
# item = ""The Graveyard Book""
# item == value_to_search is False
# Continue to the next iteration
#
# Iteration 4
# position = 3
# item = ""Good Omens""
# item == value_to_search is False
# Continue to the next iteration
#
# Iteration 5
# position = 4
# item = ""Neverwhere""
# item == value_to_search is False
# This was the last item of the list
# Since the condition was never fulfilled during the iteration, the ""return position"" command is not executed
# The output of the function is none





```",2023-11-17T15:37:27+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 1",enricabruno,"``` py
# linear search function
def linear_search(books_list, value_to_search):
# for loop execution
    for position, item in enumerate(books_list):
        if item == value_to_search:
            return position
# main
books_list = list([""Coraline"", ""American Gods"", ""The Graceyard Book"", ""Good Omens"", ""Neverwhere""])
print(linear_search(books_list, ""The Sandman""))
print(linear_search(books_list, ""American Gods""))
```

1° output: None
2nd output: 1",2023-11-19T09:15:01+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 1",CarlaMenegat,"FOR-EACH LOOP EXECUTION
enumerate(list_of_books) will result in:
enumerate([(0, ""Coraline""), (1, ""American Gods""), (2, ""The Graveyard Book""), (3, ""Good Omens""), (4, ""Neverwhere"")])

#Iteration 1
position = 0
item = ""Coraline""
item == value_to_search is False
#Continue to the next iteration

#Iteration 2
position = 1
item = ""American Gods""
item == value_to_search is False
#Continue to the next iteration

#Iteration 3
position = 2
item = ""The Graveyard Book""
item == value_to_search is False
#Continue to next iteration

#Iteration 4
position = 3
item = ""Good Omens""
item == value_to_search is False
#Continue to the next iteration

#Iteration 5
position = 4
item = ""Neverwhere""
item == value_to_search is False
#End of items, end of iterations
#No item matches the value_to_search
#Return none and end the execution of the algorithm",2023-11-19T14:20:51+00:00
comp-think/2023-2024,"Lecture ""Brute-force argorithms"", exercise 1",matildepassafaro,"```
# linear_search(list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere"", """"]), ""The Sandman"")
#
# FOR EACH LOOP EXECUTION
# enumerate(list) will result in:
# enumerate ([(0, ""Coraline""), (1, ""American Gods""), (2, ""The Graveyard Book""), (3, ""Good Omens""), (4, ""Neverwhere"")])
#
# iteration 1
# position 0
# item = ""Coraline""
# item == value_to_search is False
# Continue to the next iteration
#
# iteration 2
# position 1
# item = ""American Gods""
# item == value_to_search is False
# Continue to the next iteration
#
# iteration 3
# position 2
# item = ""The Graveyard Book""
# item == value_to_search is False
# Continue to the next iteration
#
# iteration 4
# position 3
# item = ""Good Omens""
# item == value_to_search is False
# Continue to the next iteration
#
# iteration 5 
# position 4
# item = ""Neverwhere""
# item == value_to_search is False
# Return None and end the execution of the algorithm
```",2023-11-19T16:58:06+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",qwindici,"`deque(['Hermione', 'Ron', 'Severus', 'Voldemort'])`
First, the first element was removed with popleft(), then an element was appended at the end of the queue with append and another element was removed from the start of the queue. ",2023-10-23T10:08:28+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",vattelalberto,"```
my_queue.popleft()
```
->`my_queue` will be `[""Harry, ""Hermione, ""Ron"", ""Severus""]`
```
my_queue.append(""Voldemort"")
```
->`my_queue` will be `[""Harry, ""Hermione, ""Ron"", ""Severus"", ""Voldemort""]`
```
my_queue.popleft()
```
->`my_queue` will be `[""Hermione, ""Ron"", ""Severus"", ""Voldemort""]`",2023-10-23T10:31:51+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",saramadonia,"
- my_queue.popleft() will remove the first item on the list according to the FIFO strategy -> [""Harry"", ""Hermione"", ""Ron"", ""Severus""]
-  my_queue.append(""Voldemort"") wil add a new item at the right end of the queue ->[""Harry"", ""Hermione"", ""Ron"", ""Severus"", ""Voldemort""]
- my_queue.popleft() will remove the first item on the left end of the queue -> [""Hermione"", ""Ron"", ""Severus"", ""Voldemort""]

",2023-10-23T10:43:37+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",frammenti,"```python
>>> from collections import deque
>>> my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
#1
>>> my_queue.popleft()
'Draco'
#First element added (first indexed) to the queue is removed
#through popleft() method.
>>> print(my_queue)
deque(['Harry', 'Hermione', 'Ron', 'Severus'])
#2
>>> my_queue.append(""Voldemort"")
#Through the append() method, a new element is added at the end
#(after last indexed item) of the queue.
>>> print(my_queue)
deque(['Harry', 'Hermione', 'Ron', 'Severus', 'Voldemort'])
#3
>>> my_queue.popleft()
'Harry'
#By applying popleft() again, the second element originally
#added to the queue, now first indexed, is removed.
>>> print(my_queue)
deque(['Hermione', 'Ron', 'Severus', 'Voldemort'])
```",2023-10-23T11:39:57+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",Liber-R,"![Screenshot 2023-10-23 144525](https://github.com/comp-think/2023-2024/assets/132198967/ebbb6025-2258-47da-879c-82639f6f4ae0)
",2023-10-23T12:46:03+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",MariaFrancesca6,"```python
#import deque from collections
>>> from collections import deque
#the given queue
>>> my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
#remove ""Draco"" from the left (FIFO strategy)
>>> my_queue.popleft()
'Draco'
>>> print(my_queue)
deque(['Harry', 'Hermione', 'Ron', 'Severus'])
#add ""Voldemort"" at the right of the queue
>>> my_queue.append(""Voldemort"")
>>> print(my_queue)
deque(['Harry', 'Hermione', 'Ron', 'Severus', 'Voldemort'])
#remove ""Harry"" from the left (FIFO strategy)
>>> my_queue.popleft()
'Harry'
>>> print(my_queue)
deque(['Hermione', 'Ron', 'Severus', 'Voldemort'])
```",2023-10-23T14:46:24+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",matildepassafaro,"Current status of my_queue: [""Hermione"", ""Ron"", ""Severus"", ""Voldemort""]",2023-10-24T16:52:47+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",alicepiazzi,"<img width=""462"" alt=""Schermata 2023-10-24 alle 22 54 27"" src=""https://github.com/comp-think/2023-2024/assets/105540684/7b30967a-7414-4a38-9fd2-acdf7432d550"">
",2023-10-24T20:55:23+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",ThIheb,"![exercice3](https://github.com/comp-think/2023-2024/assets/146657705/53e6fa75-7dcd-4706-8208-0a83a3e696d7)
The result is [""Hermione"", ""Ron"", ""Severus"", ""Voldemort""]",2023-10-27T11:29:12+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",Alice-Ant,"<img width=""491"" alt=""Screenshot 2023-10-28 at 00 08 53"" src=""https://github.com/comp-think/2023-2024/assets/147634010/d0e6611d-99a6-419c-8f84-7008c1b84e91"">
",2023-10-27T22:09:37+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",rufferbaraldi,"my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_queue.popleft()

#Draco is removed

my_queue.append(""Voldemort"")

#Voldemort is added after Severus

my_queue.popleft()

#Harry is removed, now the order is ""Hermione, Ron, Severus, Voldemort""",2023-10-29T11:02:32+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",parkful,"from collections import deque
my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_queue.popleft()
my_queue.append(""Voldemort"") 
my_queue.popleft()
print (my_queue)

<img width=""1169"" alt=""#15"" src=""https://github.com/comp-think/2023-2024/assets/147994157/4f5b68ec-33e8-4a46-862c-187ea04ff3e5"">
",2023-11-01T16:13:21+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",simocasaz,"```
# The first exercise
potter_characters = list()
potter_characters.append(""Harry"")
potter_characters.append(""Draco"")
potter_characters.append(""Hermione"")
potter_characters.append(""Ron"")
potter_characters.append(""Severus"")
potter_characters.sort()

# The third exercise
my_queue = deque(potter_characters) # Creating the queue by processing the elements included in the list of the first exercise
print(my_queue) # Printing to check if everything is ok
my_queue.popleft() # The first element on the left (""Draco"") is removed.
print(my_queue) # Printing to see the corrent status. Now ""Draco"" is no longer in the queue.
my_queue.append(""Voldemort"") # ""Voldemort"" is added at the end (that is, the right) of the queue.
print(my_queue) # Now ""Voldemort"" is behind ""Severus"".
my_queue.popleft() # The first element on the left (""Harry"") is removed.
print(my_queue) # Now there are four elements in the queue.

```",2023-11-03T10:21:34+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",Asemica-me,"my_queue = deque([""Hermione"", ""Ron"", ""Severus"", ""Voldemort""])",2023-11-03T17:01:08+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",Chiaramartina,"my_queue.popleft()

- Draco is removed

my_queue.append(""Voldemort"")

- Voldemort is added

my_queue.popleft()

- Harry is removed

<img width=""1214"" alt=""Schermata 2023-11-04 alle 12 18 28"" src=""https://github.com/comp-think/2023-2024/assets/106493111/6e15e9f4-23f1-4d33-9063-c1e93d761520"">
",2023-11-04T11:22:23+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",Sergpoipoip,"As queue sotres elements in First-In-First-Out (FIFO) manner, the execution of the following operations `my_queue.popleft(), my_queue.append(""Voldemort""), my_queue.popleft()` will result in this queue: `my_queue = deque([""Hermione"", ""Ron"", ""Severus"", ""Voldemort""])`",2023-11-05T13:47:01+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",enricabruno,"<img width=""1438"" alt=""OrganisingInfo-ex3"" src=""https://github.com/comp-think/2023-2024/assets/83347862/07b42965-7f41-4058-8d1d-7bb31ddf5ca9"">
",2023-11-07T14:57:29+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",annapasetto0,"![hp_queue](https://github.com/comp-think/2023-2024/assets/136476266/d6535ec6-8566-4ac6-acdc-69d21a7842d0)
",2023-11-07T20:11:02+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",VirginiaDa00,"<img width=""865"" alt=""es 3 lezione 5"" src=""https://github.com/comp-think/2023-2024/assets/147997710/ff5b3747-d236-4171-b5f8-326a5a677bac"">
",2023-11-12T20:21:18+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 3",CarlaMenegat,"![Captura de Tela 2023-11-19 às 16 14 13](https://github.com/comp-think/2023-2024/assets/146187896/8c48e0ee-be8b-4f44-a0ac-ae31cbfa3d82)
",2023-11-19T15:14:31+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",qwindici,"`deque(['Draco', 'Harry', 'Hermione', 'Voldermort'])`
Firstly, the last two elements of the stack (so the ones on the top) were removed with pop, secondly, a new element was added on the top with append. ",2023-10-23T10:05:23+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",vattelalberto,"```
my_stack.pop()
```
->`my_stack` will be `[""Draco"", ""Harry"", ""Hermione"", ""Ron""]`
```
my_stack.pop()
```
->`my_stack` will be `[""Draco"", ""Harry"", ""Hermione""]`
```
my_stack.append(""Voldemort"")
```
->`my_stack` will be `[""Draco"", ""Harry"", ""Hermione"", ""Voldemort""]`",2023-10-23T10:27:45+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",frammenti,"```python
>>> from collections import deque
>>> my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
#1
>>> my_stack.pop()
'Severus'
#First element (last indexed) on top of the stack is removed
#through pop() method.
>>> print(my_stack)
deque(['Draco', 'Harry', 'Hermione', 'Ron'])
#2
>>> my_stack.pop()
'Ron'
#By applying pop() again, the former second (second last indexed),
#now first element on stack is removed.
>>> print(my_stack)
deque(['Draco', 'Harry', 'Hermione'])
#3
>>> my_stack.append(""Voldemort"")
#Through the append() method, a new element is added on top
#(after last indexed item) of the stack.
>>> print(my_stack)
deque(['Draco', 'Harry', 'Hermione', 'Voldemort'])
```",2023-10-23T11:22:37+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",Liber-R,"![Screenshot 2023-10-23 143252](https://github.com/comp-think/2023-2024/assets/132198967/1334bffe-8da1-4ffd-a2e5-e71a45eba8f3)
",2023-10-23T12:33:24+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",MariaFrancesca6,"```python
#import deque from collections
>>> from collections import deque
#the given stack
>>> my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
#remove ""Severus"" from the top (LIFO strategy)
>>> my_stack.pop()
'Severus'
>>> print(my_stack)
deque(['Draco', 'Harry', 'Hermione', 'Ron'])
#from the current state of the stack remove ""Ron"" from the top (LIFO strategy)
>>> my_stack.pop()
'Ron'
>>> print(my_stack)
deque(['Draco', 'Harry', 'Hermione'])
#add a new element on the top of the stack
>>> my_stack.append(""Voldemort"")
>>> print(my_stack)
deque(['Draco', 'Harry', 'Hermione', 'Voldemort'])
>>>
```
",2023-10-23T14:32:28+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",matildepassafaro,"Current status of my_stack: [""Draco"", ""Harry"", ""Hermione"", ""Voldemort""]",2023-10-24T16:47:28+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",alicepiazzi,"
<img width=""436"" alt=""Schermata 2023-10-24 alle 22 49 25"" src=""https://github.com/comp-think/2023-2024/assets/105540684/0d3d6517-e271-4fa7-ba05-ca1b0202d998"">

",2023-10-24T20:50:38+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",ThIheb,"The initial line that starts the stack would provide the following

- ([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

After running the first ""pop"" command we remove the first item on the stack so we get:
- (|""Draco"", ""Harry"", ""Hermione"", ""Ron"")]

After running the second ""pop"" command we remove the new first item on the stack and so we get :
- ([""Draco"", ""Harry"", ""Hermione""])

After appending ""Voldemort"" the string will be put in the last position of the stack and so we obtain
- ([""Draco"", ""Harry"", ""Hermione"", ""Voldemort""])


",2023-10-27T11:55:27+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",Alice-Ant,"my_stack.pop()
=> removed ""Severus"" from the stack

my_stack.pop()
=> removed ""Ron"" from the updated stack

my_stack.append(""Voldemort"")
=> added a new element to the stack

Current status:
deque(['Draco', 'Harry', 'Hermione', 'Voldemort'])

<img width=""503"" alt=""Screenshot 2023-10-28 at 00 01 19"" src=""https://github.com/comp-think/2023-2024/assets/147634010/d61ce1c5-05f3-4b78-98ca-4f5ecad7201e"">
",2023-10-27T22:04:56+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",rufferbaraldi,"my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_stack.pop()

#Severus is removed

my_stack.pop()

#Ron is removed

my_stack.append(""Voldemort"")

#Voldemort is added to the end of the stack, the order is ""Draco, Harry, Hermione, Voldemort""",2023-10-29T10:59:31+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",parkful,"from collections import deque
my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_stack.pop()
my_stack.pop()
my_stack.append(""Voldemort"")
print (my_stack)

deque([""Draco"", ""Harry"", ""Hermione"",""Voldemort""])

<img width=""1134"" alt=""#14"" src=""https://github.com/comp-think/2023-2024/assets/147994157/986ac59e-a48a-40ac-866e-52c31b5e519d"">
",2023-11-01T16:10:35+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",simocasaz,"```
from collections import deque # Importing the module from the package

# The first exercise
potter_characters = list()
potter_characters.append(""Harry"")
potter_characters.append(""Draco"")
potter_characters.append(""Hermione"")
potter_characters.append(""Ron"")
potter_characters.append(""Severus"")
potter_characters.sort()

# The second exercise
my_stack = deque(potter_characters) # Creating the stack by processing the elements included in the list of the first exercise
print(my_stack) # Printing to check if everything is ok
my_stack.pop()
print(my_stack) # Printing to see the corrent status. Now ""Severus"" is no longer in the stack. Four elements remain.
my_stack.pop()
print(my_stack) # Printing to see the corrent status. Now ""Ron"" is no longer in the stack. Three elements remain.
my_stack.append(""Voldemort"")
print(my_stack) # Now ""Voldemort"" has been added to the stuck over the element ""Hermione"".
```

I hope that I will not be found by Death Eaters after naming He Who Must Not Be Named
",2023-11-03T09:56:49+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",Chiaramartina,"my_stack.pop() 

- Severus is removed from the stack

my_stack.pop() 

- Ron is removed from the stack

my_stack.append(""Voldemort"") 

- Voldemort is added in the last position on the stack

<img width=""1159"" alt=""Schermata 2023-11-03 alle 11 31 40"" src=""https://github.com/comp-think/2023-2024/assets/106493111/e412deae-5186-40b7-a6c1-e496d35c87fc"">

",2023-11-03T10:37:56+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",Asemica-me,"my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Voldemort])",2023-11-03T16:58:41+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",Sergpoipoip,"As stack stores items in Last-In-First-Out (LIFO) manner, so as a result of performing the following operations `my_stack.pop(), my_stack.pop(), my_stack.append(""Voldemort"")`, the stack will look like this `my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Voldemort""])`",2023-11-05T13:41:30+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",enricabruno,"<img width=""1368"" alt=""OrganisingInfo-ex2"" src=""https://github.com/comp-think/2023-2024/assets/83347862/7ffecbe7-8095-4ccf-a8c1-df923330b5b3"">
",2023-11-07T14:47:44+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",annapasetto0,"![stack_hp](https://github.com/comp-think/2023-2024/assets/136476266/9138a063-e6e8-4a7e-9511-4ec8d1c49543)
",2023-11-07T20:03:34+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",VirginiaDa00,"
<img width=""920"" alt=""es2 lez 5"" src=""https://github.com/comp-think/2023-2024/assets/147997710/151b2337-d427-43d3-acfa-a16afbc0fe21"">
status of harry_potter_stack after the execution of:

1. harry_potter_stack-pop() -->Severus is removed from the stack
2. harry_potter_stack.pop() -->Ron is removed from the stack
3. harry_potter_append(""Voldemort"") -->Voldemort is added in the last position 
result:
deque([""Draco"", ""Harry"", ""Hermione"", ""Voldemort""])
",2023-11-12T19:25:39+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 2",CarlaMenegat,"![Captura de Tela 2023-11-19 às 15 57 49](https://github.com/comp-think/2023-2024/assets/146187896/04280e42-5c4d-4660-8fde-34f5f76a09b8)

#with the first my_stack.pop() the last object is removed --> Severus
#with the second my_stack.pop() the now last object is removed --> Ron
#with my_stack.append(""Voldemort"") --> Voldemort becomes the last object on the stack. 

#then
deque(['Draco', 'Harry', 'Hermione', 'Voldemort'])
",2023-11-19T15:04:13+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",qwindici,"```
hp_characters = ['Harry', 'Draco', 'Hermione', 'Ron', 'Severus']
hp_characters.sort()
```",2023-10-23T10:01:54+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",vattelalberto,"```python
characters_list = list()
characters_list.append(""Harry"")
characters_list.append(""Draco"")
characters_list.append(""Hermione"")
characters_list.append(""Ron"")
characters_list.append(""Severus"")
characters_list.sort()

#ceck result
print(characters_list)
```",2023-10-23T10:23:04+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",frammenti,"```python
my_list = list()
my_list.append(""Harry"")
my_list.append(""Draco"")
my_list.append(""Hermione"")
my_list.append(""Ron"")
my_list.append(""Severus"")
my_list.sort()

print(my_list)
```",2023-10-23T10:23:55+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",saramadonia,"![sort()](https://github.com/comp-think/2023-2024/assets/146438182/f9e41d50-4f08-43e4-8ed1-b5e7592decee)
",2023-10-23T10:30:40+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",Liber-R,"![Screenshot 2023-10-23 142239](https://github.com/comp-think/2023-2024/assets/132198967/d46816b3-da2c-4385-bf57-f7f910fc9073)
",2023-10-23T12:23:20+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",MariaFrancesca6,"```python
#create list
character_list = list()
#add elements
character_list.append(""Harry"")
character_list.append(""Draco"")
character_list.append(""Hermione"")
character_list.append(""Ron"")
character_list.append(""Severus"")
#sort elements in alphabetical order
character_list.sort()
#show the result
print(character_list)
```
Here the result: 
![image](https://github.com/comp-think/2023-2024/assets/146453979/78f16ed9-b5bf-4071-8f62-cf87a554dd24)
",2023-10-23T14:07:46+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",ThIheb,"![list](https://github.com/comp-think/2023-2024/assets/146657705/6e53c56c-82aa-4776-abf4-778ac25e880a)
I started by defining a list of strings as names which I later appended to a list and used the function sort to alphabetically order the names within the list",2023-10-24T09:40:53+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",matildepassafaro,"
<img width=""383"" alt=""list_python"" src=""https://github.com/comp-think/2023-2024/assets/146438198/89a24f1d-2e6c-4c78-ac38-7bf3c82cadab"">

Result from Python Tutor:


<img width=""898"" alt=""ordered_structures_exercise_1"" src=""https://github.com/comp-think/2023-2024/assets/146438198/b381c9d2-daf0-4282-b262-9f69839479e7"">
",2023-10-24T16:41:56+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",alicepiazzi,"<img width=""316"" alt=""Schermata 2023-10-24 alle 22 28 08"" src=""https://github.com/comp-think/2023-2024/assets/105540684/355ffb07-10ad-4792-9d1a-1fae4a2f90c9"">
",2023-10-24T20:29:38+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",Alice-Ant,">>> character_list = list ()
>>> character_list.append (""Harry"")
>>> character_list.append (""Draco"")
>>> character_list.append (""Hermione"")
>>> character_list.append (""Ron"")
>>> character_list.append (""Severus"")
>>> print(character_list)
['Harry', 'Draco', 'Hermione', 'Ron', 'Severus']
>>> sorted_list = sorted(character_list)
>>> print(sorted_list)
['Draco', 'Harry', 'Hermione', 'Ron', 'Severus']

<img width=""806"" alt=""Screenshot 2023-10-27 at 23 50 29"" src=""https://github.com/comp-think/2023-2024/assets/147634010/2538216a-345e-4fcf-af6d-2120170ea4a4"">

",2023-10-27T21:51:00+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",rufferbaraldi,"hp_char = list()
hp_char.append(""Harry"")
hp_char.append(""Draco"")
hp_char.append(""Hermione"")
hp_char.append(""Ron"")
hp_char.append(""Severus"")
hp_char.sort()
print(hp_char)",2023-10-29T10:54:19+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",parkful,"first_list = list()
first_list.append(""​Harry"")
first_list.append(""​Draco"")
first_list.append(""​Hermione"")
fifst_list.append(""​Ron"")
first_list.append(""​Severus"")
first_list.sort()
print (first_list)


<img width=""1155"" alt=""#13"" src=""https://github.com/comp-think/2023-2024/assets/147994157/301721cf-9457-4747-a37c-5743113d36fe"">
",2023-11-01T16:08:13+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",simocasaz,"```
potter_characters = list()
potter_characters.append(""Harry"")
potter_characters.append(""Draco"")
potter_characters.append(""Hermione"")
potter_characters.append(""Ron"")
potter_characters.append(""Severus"")
potter_characters.sort()
print(potter_characters)
```",2023-11-02T13:59:44+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",Chiaramartina,"potter_list=list()
potter_list.append(""Harry"")
potter_list.append(""Draco"")
potter_list.append(""Hermione"")
potter_list.append(""Ron"")
potter_list.append(""Severus"")
potter_list.sort()

print(potter_list)",2023-11-03T08:50:17+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",Asemica-me,"```
hp_characters_list = list()

hp_characters_list.append(""Draco"")
hp_characters_list.append(""Harry"")
hp_characters_list.append(""Hermione"")
hp_characters_list.append(""Ron"")
hp_characters_list.append(""Severus"")
```",2023-11-03T15:34:15+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",Sergpoipoip,"![List_1](https://github.com/comp-think/2023-2024/assets/35369089/e89e8428-0fdd-4b20-a7c5-0e0a9a23c719)
",2023-11-05T13:21:41+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",enricabruno,"<img width=""1142"" alt=""OrganisingInfo-ex1"" src=""https://github.com/comp-think/2023-2024/assets/83347862/28e83607-67ab-48f0-beda-29a779ee0c79"">
",2023-11-07T14:18:28+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",annapasetto0,"![lista_hp](https://github.com/comp-think/2023-2024/assets/136476266/f61a248c-456a-41db-8d52-cb09841b461f)

",2023-11-07T19:43:37+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",VirginiaDa00,"<img width=""872"" alt=""lezione 5 es1"" src=""https://github.com/comp-think/2023-2024/assets/147997710/1d467236-e7bd-4aea-a1dd-737998efaeee"">
",2023-11-12T19:18:24+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",essepuntato,"@ThIheb and @alicepiazzi, try to print the final list you have created to see if it is organised as requested by the exercise.",2023-11-13T06:41:51+00:00
comp-think/2023-2024,"Lecture ""Organising information: ordered structures"", exercise 1",CarlaMenegat,"
![Captura de Tela 2023-11-19 às 15 48 44](https://github.com/comp-think/2023-2024/assets/146187896/4af27d6f-86ef-467c-9c83-8b79aba40c0c)

",2023-11-19T14:50:06+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",qwindici,"```
def is_in_bibliography(word_1, word_2, bib_entry):
   counter = 0 
   if word_1 in bib_entry:
      counter += 1
   if word_2 in bib_entry:
      counter += 1
   return counter

print(is_in_bibliography('Peroni', 'HTML', 'Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132'))
```

output = 2 

`print(is_in_bibliography('Peroni', 'word', 'Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132'))`

output = 1

`print(is_in_bibliography('barboncino', 'word', 'Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132'))`

output = 0",2023-10-20T14:11:08+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",valetedd,"![pytests_ex3](https://github.com/comp-think/2023-2024/assets/147620147/75a51170-7b73-4c93-9554-c70a58cd0d3e)
```

# test function for the algorithm

def test_is_in_entry(first_word, second_word, bib_entry, expected):
    result = is_in_entry(first_word, second_word, bib_entry)
    if result == expected:
        return True
    else:
        return False

# function

def is_in_entry(first_word, second_word, bib_entry):
    result = 0
    if first_word in bib_entry:
        result += 1
    if second_word in bib_entry:
        result += 1
    return result 

# tests

print(test_is_in_entry(""murder"", ""horror"", ""Tagliaferri, L. (2018). How To Code in Python. ISBN: 978-0999773017"", 0))
print(test_is_in_entry(""Code"", ""ananas"", ""Tagliaferri, L. (2018). How To Code in Python. ISBN: 978-0999773017"", 1))
print(test_is_in_entry(""Python"", ""ISBN"", ""Tagliaferri, L. (2018). How To Code in Python. ISBN: 978-0999773017"", 2))    

```",2023-10-20T18:40:05+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",Asemica-me,"```
# Consider three different strings as input:
# two words and a bibliographic entry of a published paper. 
# The algorithm must return 
# the number 2 if the bibliographic entry contains both words; 
# the number 1 if the bibliographic entry contains only one word; 
# the number 0 otherwise.


# Test case for the algorithm
def test_contains_word(first_word, second_word, bib_entry, expected):
    result = contains_word(first_word, second_word, bib_entry)
    if expected == result:
        return True
    else:
        return False


# Code of the algorithm
def contains_word(first_word, second_word, bib_entry):  # input/output: input two words and a bibliographic entry
    result = 0  # process1: initialize the result value to 0

    if first_word in bib_entry:  # decision1: the first word is in the bibliographic entry (?)
        result = result + 1  # if decision1 returns yes ==> process2: sum 1 to the result value

    if second_word in bib_entry:  # if decision1 returns no ==> decision2: the second word is in the bibliographic entry (?)
        result = result + 1  # process3: sum 1 to the result value

    return result  # input/output: return the result value


# Three different test runs considering particular input data as emulated in chapter 'Algorithms'
print(test_contains_word(""Shotton"", ""Open"",
                         ""Shotton, D. (2013). Open Citations. Nature, 502: 295–297. doi:10.1038/502295a"", 2))
print(test_contains_word(""Citations"", ""Science"",
                         ""Shotton, D. (2013). Open Citations. Nature, 502: 295–297. doi:10.1038/502295a"", 1))
print(test_contains_word(""References"", ""1983"",
                         ""Shotton, D. (2013). Open Citations. Nature, 502: 295–297. doi:10.1038/502295a"", 0))
```",2023-10-21T09:52:06+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",frammenti,"```python
# TEST FUNCTION
# The output integer of the contains_word function is compared with the given expected value
# to return a boolean value
def test_contains_word(first_word, second_word, bib_entry, expected):
    result = contains_word(first_word, second_word, bib_entry)
    if expected == result:
        return True
    else:
        return False

# FUNCTION
# Returns 0 if no word is present in bib_entry, 1 if only one, 2 if both
def contains_word(first_word, second_word, bib_entry):
    result = 0 # set counter to 0
    if first_word in bib_entry:
        result += 1 # short for result = result + 1
    if second_word in bib_entry:
        result += 1
    return result

# Tuples of bibliographic entries to be accessed via *args for test
bib1 = (""Conquistata"", ""Superiore"",
        ""Residori, M. (2004). L'idea del poema. Studi sulla Gerusalemme Conquistata di Torquato Tasso, Pisa, Scuola Normale Superiore."")
bib2 = (""Divine"", ""Comedy"",
        ""Barolini, T. (1992). The Undivine Comedy. Detheologizing Dante, New Jersey, Princeton University Press, pp. 48-73."")
bib3 = (""riconoscimento"", ""gratitudine"",
        ""Kremers, D. (1966). Rinaldo und Odysseus. Zur Frage der Diesseitserkenntnis bei Luigi Pulci und Dante Alighieri, Heidelberg, Winter."")

# Three different test runs
print(test_contains_word(*bib1, 2))
print(test_contains_word(*bib2, 1))
print(test_contains_word(*bib3, 0))
```

[Algorithm Test in Python Tutor](https://pythontutor.com/render.html#code=%23%20TEST%20FUNCTION%0A%23%20The%20output%20integer%20of%20the%20contains_word%20function%20is%20compared%20with%20the%20given%20expected%20value%0A%23%20to%20return%20a%20boolean%20value%0Adef%20test_contains_word%28first_word,%20second_word,%20bib_entry,%20expected%29%3A%0A%20%20%20%20result%20%3D%20contains_word%28first_word,%20second_word,%20bib_entry%29%0A%20%20%20%20if%20expected%20%3D%3D%20result%3A%0A%20%20%20%20%20%20%20%20return%20True%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20return%20False%0A%0A%23%20FUNCTION%0A%23%20Returns%200%20if%20no%20word%20is%20present%20in%20bib_entry,%201%20if%20only%20one,%202%20if%20both%0Adef%20contains_word%28first_word,%20second_word,%20bib_entry%29%3A%0A%20%20%20%20result%20%3D%200%20%23%20set%20counter%20to%200%0A%20%20%20%20if%20first_word%20in%20bib_entry%3A%0A%20%20%20%20%20%20%20%20result%20%2B%3D%201%20%23%20short%20for%20result%20%3D%20result%20%2B%201%0A%20%20%20%20if%20second_word%20in%20bib_entry%3A%0A%20%20%20%20%20%20%20%20result%20%2B%3D%201%0A%20%20%20%20return%20result%0A%0A%23%20Tuples%20of%20bibliographic%20entries%20to%20be%20accessed%20via%20*args%20for%20test%0Abib1%20%3D%20%28%22Conquistata%22,%20%22Superiore%22,%0A%20%20%20%20%20%20%20%20%22Residori,%20M.%20%282004%29.%20L'idea%20del%20poema.%20Studi%20sulla%20Gerusalemme%20Conquistata%20di%20Torquato%20Tasso,%20Pisa,%20Scuola%20Normale%20Superiore.%22%29%0Abib2%20%3D%20%28%22Divine%22,%20%22Comedy%22,%0A%20%20%20%20%20%20%20%20%22Barolini,%20T.%20%281992%29.%20The%20Undivine%20Comedy.%20Detheologizing%20Dante,%20New%20Jersey,%20Princeton%20University%20Press,%20pp.%2048-73.%22%29%0Abib3%20%3D%20%28%22riconoscimento%22,%20%22gratitudine%22,%0A%20%20%20%20%20%20%20%20%22Kremers,%20D.%20%281966%29.%20Rinaldo%20und%20Odysseus.%20Zur%20Frage%20der%20Diesseitserkenntnis%20bei%20Luigi%20Pulci%20und%20Dante%20Alighieri,%20Heidelberg,%20Winter.%22%29%0A%0A%23%20Three%20different%20test%20runs%0Aprint%28test_contains_word%28*bib1,%202%29%29%0Aprint%28test_contains_word%28*bib2,%201%29%29%0Aprint%28test_contains_word%28*bib3,%200%29%29&cumulative=true&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false)

![image](https://github.com/comp-think/2023-2024/assets/146438454/b4e9d9e0-1f96-47fb-b5fd-e1cf2de8c4bb)",2023-10-21T11:13:37+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",Liber-R,"![Screenshot 2023-10-21 143739](https://github.com/comp-think/2023-2024/assets/132198967/d5196aa1-d3fa-48e9-be84-7370c5265cdc)
",2023-10-21T12:40:33+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",Chiaramartina,"def test_bibliography (word_one, word_two, bib_entry, expected):
    result=bibliography (word_one, word_two, bib_entry)
    if expected==result:
        return True
    else:
        return False

def bibliography (word_one,word_two,bib_entry):
    result= 0
    if word_one in bib_entry:
        result = result +1
    if word_two in bib_entry:
        result = result +1
    return result
        
print(test_bibliography( ""Shotton"", ""Open"",
""Shotton, D. (2013). Open Citations. Nature, 502: 295–297. doi:10.1038/502295a"", 2))
print(test_bibliography( ""Citations"", ""Science"",
""Shotton, D. (2013). Open Citations. Nature, 502: 295–297. doi:10.1038/502295a"", 1))
print(test_bibliography( ""References"", ""1983"",
""Shotton, D. (2013). Open Citations. Nature, 502: 295–297. doi:10.1038/502295a"", 0))",2023-10-21T16:34:36+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",alicepiazzi,"#Consider three different strings as input:
#two words and a bibliographic entry 
#The algorithm must return the following output:
#number 2 if the bibliographic entry contains both words; 
#number 1 if the bibliographic entry contains only one word; 
#number 0 otherwise.

#test function for the algorithm
def test_contains_word(first_word, second_word, bibliographic_entry, expected) 
    result= test_contains_word(first word, second_word; bibliographica_entry)
    if expected == result 
        return True
    else:
        return False 
    
#function
def test_contains_word(first_word, second_word, bibliographical_entry)
    result = 0
    if first_word is in bibliographical_entry
        result = +1
    if second_word is in bibliographical_entry
        result = +1
    return result 

#Test returns
bib1 = (""Conquistata"", ""Superiore"",
        ""Residori, M. (2004). L'idea del poema. Studi sulla Gerusalemme Conquistata di Torquato Tasso, Pisa, Scuola Normale Superiore."")
    result = 2
bib2 = (""Divine"", ""Comedy"",
        ""Barolini, T. (1992). The Undivine Comedy. Detheologizing Dante, New Jersey, Princeton University Press, pp. 48-73."")
    result = 1
bib3 = (""riconoscimento"", ""gratitudine"",
        ""Kremers, D. (1966). Rinaldo und Odysseus. Zur Frage der Diesseitserkenntnis bei Luigi Pulci und Dante Alighieri, Heidelberg, Winter."")
    result = 0",2023-10-22T10:59:48+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",ThIheb,"![Ex3](https://github.com/comp-think/2023-2024/assets/146657705/0a5633e6-a536-4918-85fa-ea2203acf10b)

Also ran the following 3 tests and they also returned the expected results : 
print(test_check_bib(""D"", ""2013"",
                         ""Shotton, D. (2013). Open Citations. Nature, 502: 295–297. doi:10.1038/502295a"", 2))
print(test_check_bib(""Shotton"", ""Dream"",
                         ""Shotton, D. (2013). Open Citations. Nature, 502: 295–297. doi:10.1038/502295a"", 1))
print(test_check_bib(""Close"", ""1984"",
                         ""Shotton, D. (2013). Open Citations. Nature, 502: 295–297. doi:10.1038/502295a"", 0))
",2023-10-22T16:17:21+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",AnnaNicoletti,![image](https://github.com/comp-think/2023-2024/assets/147601727/0e19ca85-d66b-4872-a575-539d08fef2ce),2023-10-22T19:42:53+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",rufferbaraldi,"![python](https://github.com/comp-think/2023-2024/assets/147972854/37307564-60e0-41e2-b4bd-f0f9cda35568)
",2023-10-22T20:30:32+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",matildepassafaro,"
<img width=""908"" alt=""programming_languages_exercise_3"" src=""https://github.com/comp-think/2023-2024/assets/146438198/42050917-7aa9-4524-98d3-f3777a3ea98e"">

",2023-10-22T21:14:53+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",MariaFrancesca6,"Test function works well 'cause the return values are always False: 

![image](https://github.com/comp-think/2023-2024/assets/146453979/4d515456-8195-4c0a-98b1-1b37e7ae7f3c)

Function executed with different inputs works well 'cause the return values are always True: 

![image](https://github.com/comp-think/2023-2024/assets/146453979/eccb333f-22db-4789-b90c-461b3198a184)

",2023-10-22T21:20:34+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",valentinabertelli,"def test_contains_word(first_word, second_word, bib_entry, expected):
    result = contains_word(first_word, second_word, bib_entry)
    if result == expected:
        return True
    else:
        return False

def contains_word(first_word, second_word, bib_entry):
    result_value = 0
    if first_word in bib_entry:
        result_value = result_value + 1
    if second_word in bib_entry:
        result_value = result_value + 1
    return result_value
       
print(test_contains_word(""Virginia"", ""stanza"", ""Virginia Woolf, Una stanza tutta per sé, Milano, Feltrinelli, 2013"", 2))
print(test_contains_word(""Virginia"", ""Roma"", ""Virginia Woolf, Una stanza tutta per sé, Milano, Feltrinelli, 2013"", 1))
print(test_contains_word(""Einaudi"", ""stanza"", ""Virginia Woolf, Una stanza tutta per sé, Milano, Feltrinelli, 2013"", 1))
print(test_contains_word(""Einaudi"", ""Roma"", ""Virginia Woolf, Una stanza tutta per sé, Milano, Feltrinelli, 2013"", 0))",2023-10-22T21:36:42+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",vattelalberto,"```
def test_check_bib(word1, word2, bib_entry, expected):
    result = check_bib(word1, word2, bib_entry)
    if result == expected:
        return True
    else:
        return False

def check_bib(word1, word2, bib_entry):
    word1_in_bib = word1 in bib_entry
    word2_in_bib = word2 in bib_entry
    result_value = 0
    if word1_in_bib:
        result_value = result_value + 1
    if word2_in_bib:
        result_value = result_value + 1
    return result_value

print(test_check_bib(""a"", ""b"", ""abcd"", 2))
print(test_check_bib(""a"", ""b"", ""acde"", 1))
print(test_check_bib(""a"", ""b"", ""bcde"", 1))
print(test_check_bib(""a"", ""b"", ""wxyz"", 0))",2023-10-22T23:24:03+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",enricabruno,"#TEST FUNCTION
def test_contains_word(first_word, second_word, bib_entry, expected):
    result = contains_word(first_word, second_word, bib_entry)
    if expected == result:
        return True
    else:
        return False

#FUNCTION
def contains_word(first_word, second_word, bib_entry):
    result = 0
    if first_word in bib_entry:
        result = result + 1 
    if second_word in bib_entry:
        result = result + 1
    return result

#TESTS
print(test_contains_word(""Shotton"", ""Open"", ""Shotton, D. (2013). Open Citations. Nature, 502: 295-297. doi:10.1038/502295a"", 2))
print(test_contains_word(""Citations"", ""Science"", ""Shotton, D. (2013). Open Citations. Nature, 502: 295-297. doi:10.1038/502295a"", 1))
print(test_contains_word(""References"", ""1983"",  ""Shotton, D. (2013). Open Citations. Nature, 502: 295-297. doi:10.1038/502295a"", 0))",2023-10-23T07:17:14+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",saramadonia,"![myfirst](https://github.com/comp-think/2023-2024/assets/146438182/2b251476-6cd0-4be3-97a7-e7140ca54a24)
",2023-10-23T10:14:53+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",simocasaz,"Here is the code to fail the first tests:
```
# Test case for the algorithm
def test_contains_word(first_word, second_word, bib_entry, expected):
    result = contains_word(first_word, second_word, bib_entry)
    if result == expected:
        return True
    else:
        return False

# Code of the algorithm
def contains_word(first_word, second_word, bib_entry):
    return

# Three different tests run
print(test_contains_word(""Shotton"", ""Open"", ""Shotton, D. (2013). Open Citations. Nature, 502: 295–297. doi:10.1038/502295a"", 2))
print(test_contains_word(""Citations"", ""Science"", ""Shotton, D. (2013). Open Citations. Nature, 502: 295–297. doi:10.1038/502295a"", 1))
print(test_contains_word(""References"", ""1983"", ""Shotton, D. (2013). Open Citations. Nature, 502: 295–297. doi:10.1038/502295a"", 0))
```
The printed values for the initial failed tests:

```
False
False
False
```

Here is the code with the complete function:

```
# Test case for the algorithm
def test_contains_word(first_word, second_word, bib_entry, expected):
    result = contains_word(first_word, second_word, bib_entry)
    if result == expected:
        return True
    else:
        return False

# Code of the algorithm
def contains_word(first_word, second_word, bib_entry):
    result_value = 0
    if first_word in bib_entry:
        result_value += 1
    if second_word in bib_entry:
        result_value += 1
    return result_value


# Three different tests run
print(test_contains_word(""Shotton"", ""Open"", ""Shotton, D. (2013). Open Citations. Nature, 502: 295–297. doi:10.1038/502295a"", 2))
print(test_contains_word(""Citations"", ""Science"", ""Shotton, D. (2013). Open Citations. Nature, 502: 295–297. doi:10.1038/502295a"", 1))
print(test_contains_word(""References"", ""1983"", ""Shotton, D. (2013). Open Citations. Nature, 502: 295–297. doi:10.1038/502295a"", 0))
```

Here the printed values for the passed tests:

```
True
True
True
```",2023-10-24T16:34:58+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",parkful,"def test_contains_word(first_word, second_word, bib_entry, expected):
    result = contains_word(first_word, second_word, bib_entry)
    if result == expected:
        return True
    else:
        return False


def contains_word(first_word, second_word, bib_entry):
    contains_no_word = 0
    contains_first_word = first_word in bib_entry
    contains_second_word = second_word in bib_entry
    if contains_first_word and contains_second_word:
        contains_no_word = contains_no_word + 2
    elif contains_first_word or contains_second_word:
        contains_no_word = contains_no_word + 1
    return contains_no_word 


print(test_contains_word(""started"", ""Walt"", 
""The way to get started is to quit talking and begin doing. -Walt Disney"", 2))
print(test_contains_word(""Osborne"", ""Wolowitz"",
""Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132"", 1))
print(test_contains_word(""Sheldon"", ""Leonard"",
""Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132"", 0))

<img width=""1465"" alt=""#12"" src=""https://github.com/comp-think/2023-2024/assets/147994157/abb984ec-7b7d-4215-bc2b-27e18c18a413"">
",2023-11-01T16:26:00+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 3",CarlaMenegat,"#test code
def test_contain_word(first_word, second_word, bibliography, expected):
    result = contain_word(first_word, second_word, bibliography)
    if result == expected:
        return True
    else:
        return False

#algorithm code
def contain_word(first_word, second_word, bibliography):
    result = 0
    if first_word in bibliography:
        result = result + 1
    if second_word in bibliography:
        result = result +1
    return result
    

print(test_contain_word(""Lara"", ""Chão"", ""Lara, Silvia Hunold ; Fachin, Phablo R. M. . Guerra contra Palmares. O manuscrito de 1678. 1. ed. São Paulo: Chão, 2021."", 2))
print(test_contain_word(""Palmares"", ""São Paulo"", ""Lara, Silvia Hunold ; Fachin, Phablo R. M. . Guerra contra Palmares. O manuscrito de 1678. 1. ed. São Paulo: Chão, 2021."", 2))
print(test_contain_word(""Silvia"", ""Fachin"", ""Lara, Silvia Hunold ; Fachin, Phablo R. M. . Guerra contra Palmares. O manuscrito de 1678. 1. ed. São Paulo: Chão, 2021."", 2))

![image](https://github.com/comp-think/2023-2024/assets/146187896/838cfbac-5e93-4faf-a26b-a53408d516bb)
",2023-11-16T15:06:25+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",vattelalberto,False ,2023-10-20T11:45:01+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",qwindici,"- ""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")
- True and not (""egg"" > ""span"")
- (Assuming that '>' means 'has more characters than'): True and not False
- True and True
- True 
",2023-10-20T13:59:17+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",FranciscoWu,"since spam is not in ""spa span sparql"", it's a True
since egg < span, it's a False
so it'll be: True and True,
it's a ""True""",2023-10-20T14:24:42+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",valetedd,"**""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")**

- ""spam"" not in ""spa span sparql"" = True; ""egg"" > ""span"" = False; 
- True and not (False) = True
",2023-10-20T16:22:00+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",Asemica-me,"
![null (8)](https://github.com/comp-think/2023-2024/assets/104790378/4ef8f026-7425-44b9-85aa-6d1b69c8b663)
The boolean value of `""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")` is **`True`**.",2023-10-20T21:44:43+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",frammenti,"```python
""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")
True and not False
True and True
True
```",2023-10-21T08:03:32+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",Liber-R,True,2023-10-21T11:05:48+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",alicepiazzi,"<img width=""475"" alt=""Schermata 2023-10-21 alle 13 37 57"" src=""https://github.com/comp-think/2023-2024/assets/105540684/65d8e0fa-0a11-47a2-b1c2-aa6b5815c0f3"">
",2023-10-21T11:38:49+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",Chiaramartina,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")
""spam"" not in ""spa span sparql"" = True
(""egg"" > ""span"") = False
True and not False
True and True 
True",2023-10-21T16:10:18+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",rufferbaraldi,"true and true

True",2023-10-22T07:23:20+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",matildepassafaro,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")
""spam"" not in ""spa span sparql"" and not False
""spam"" not in ""spa span sparql"" and True
True and True
True",2023-10-22T10:14:28+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",annapasetto0,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")
""spam"" not in ""spa span sparql"" and not False 
""spam"" not in ""spa span spargl"" and True
True and True 
True 
",2023-10-22T10:52:22+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",saramadonia,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")
True and not (""egg"" > ""span"")
True and not(False) #I have compared the strings' lexicographical order 
True and True
True",2023-10-22T11:43:38+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",ThIheb,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")

1. ""spam"" is not in ""spa span sparql"" so ""spam"" not in ""spa span sparql"" returns True
2. (""egg > ""span"") returns False (according to the order of the letters within the string)

So we have True and not (False)
True and True
True

The final result is True",2023-10-22T17:12:42+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",valentinabertelli,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")
""spam"" not in ""spa span sparql"" and not False
True and True
True",2023-10-22T17:40:11+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",AnnaNicoletti,![image](https://github.com/comp-think/2023-2024/assets/147601727/d4fd5792-1c8f-4d92-bd3c-41bd0bff64ea),2023-10-22T19:38:42+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",MariaFrancesca6,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")
""spam"" not in ""spa span sparql"" = True and not False
True and True
True",2023-10-22T19:53:04+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",enricabruno,"<img width=""622"" alt=""Screenshot 2023-10-22 alle 23 45 33"" src=""https://github.com/comp-think/2023-2024/assets/83347862/f665f106-0cd3-4124-ad7d-a3ebab0db124"">
",2023-10-22T21:46:26+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",elena2notti,True ,2023-10-23T04:54:22+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",simocasaz,"![IMG_20231025_193642.jpg](https://github.com/comp-think/2023-2024/assets/146863760/eec912cc-fc80-4cd7-8713-0df64936cc9f)

",2023-10-25T17:38:43+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",parkful,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")
""spam"" not in ""spa span sparql"" and not (False)
""spam"" not in ""spa span sparql"" and True
True and True
True
",2023-11-01T16:26:31+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 2",CarlaMenegat,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")
True and True
True",2023-11-16T10:08:53+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",vattelalberto,True,2023-10-20T11:43:16+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",qwindici,"not (not True or False and True) or False
not (False or False and True) or False 
not (False and True) or False
not (False) or False
True or False
True",2023-10-20T13:53:27+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",FranciscoWu,True,2023-10-20T14:19:08+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",annapasetto0,"not (not True or False and True) or False
not (False or False and True) or False
not (False and True) or False
not False or False
True or False = True

",2023-10-20T17:33:32+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",Asemica-me,"![null (7)](https://github.com/comp-think/2023-2024/assets/104790378/2739a96a-ed0a-4f6f-a447-f3cadad8c775)
 According to brackets and rules for application order, the boolean value of `not (not True or False and True) or False` is **`True`**.",2023-10-20T20:22:00+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",frammenti,"```python
not ((not True) or (False and True)) or False
not (False or False) or False
not False or False
True or False
True
```",2023-10-21T07:54:23+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",alicepiazzi,"
<img width=""603"" alt=""Schermata 2023-10-21 alle 12 29 39"" src=""https://github.com/comp-think/2023-2024/assets/105540684/d8e5aa33-e1f1-400d-935f-08973fa05766"">

",2023-10-21T10:30:18+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",Liber-R,True,2023-10-21T11:02:52+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",Chiaramartina,"not (not True or False and True) or False
not (False or False and True) or False
not (False and False) or False
not False or False 
not False 
True",2023-10-21T15:59:09+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",rufferbaraldi,True,2023-10-22T07:21:33+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",matildepassafaro,"not (not True or False and True) or False
not (False or False and True) or False
not (False or False) or False
not False or False
True or False
True",2023-10-22T10:06:54+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",saramadonia,"not (not True or False and True) or False
not(False or False and True) or False
not(False and True) or False
not (False) or False
True or False
True",2023-10-22T11:19:36+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",ThIheb,"Not (not True or False and True) or False
= Not (False or False and True) or False
= Not (False or False) or False
= Not ( False) or False
= True or False
= True",2023-10-22T17:07:38+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",valentinabertelli,"not (not True or False and True) or False
not (False or False and True) or False
not (False or False) or False
not False or False
True or False
True",2023-10-22T17:35:23+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",AnnaNicoletti,![image](https://github.com/comp-think/2023-2024/assets/147601727/1845b8c0-9555-4067-b6bd-1d46d294aa4b),2023-10-22T19:38:16+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",MariaFrancesca6,"not (not True or False and True) or False
not (False or False and True) or False
not (False and True) or False
not False or False
True or False
True

Correct way to solve it: 

not (not True or False and True) or False
not (False or False and True) or False
not (False or False) or False
not False or False
True or False
True",2023-10-22T19:45:05+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",enricabruno,"<img width=""1440"" alt=""Screenshot 2023-10-22 alle 23 45 09"" src=""https://github.com/comp-think/2023-2024/assets/83347862/779f2864-6858-48d2-83f0-0e24364c472f"">
",2023-10-22T21:45:16+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",elena2notti,True,2023-10-23T04:53:55+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",essepuntato,"Hi all, thanks for your take. It is important to remember that boolean operators must be applied with a particular priority among them, i.e. first `not`, then `and` and finally `or`.",2023-10-23T07:11:25+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",Kaosaier,"not True is False.
not False is True.
False and True is False.
not (not True or False and True) is not (False or False), which is equivalent to not False, which is True.
True or False is True.
Therefore, is True.",2023-10-23T07:18:39+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",saramadonia,"> not (not True or False and True) or False not(False or False and True) or False not(False and True) or False not (False) or False True or False True

edit:
not (not True or False and True) or False
not (False or False and True) or False
not (False or False) or False
not False or False
True or False
True
",2023-10-23T07:29:52+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",simocasaz,"![IMG_20231025_193635.jpg](https://github.com/comp-think/2023-2024/assets/146863760/5ead3106-26cf-4635-80f8-16dd916c81ae)

",2023-10-25T17:37:33+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",parkful,"not (not True or False and True) or False
not (False or False and True) or False
not (False or False) or False
not (False) or False
True or False 
True
",2023-11-01T16:27:14+00:00
comp-think/2023-2024,"Lecture ""Programming languages"", exercise 1",CarlaMenegat,"not (not True or False and True) or False
not ((not True) or False and True) or False
not (False or False) or False
not (False) or False
True or False
True",2023-11-16T10:07:08+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 3",vattelalberto,"I've slightly tweaked the machine used in exercise 2

``` name: ex2
input: '00000'
blank: '0'
start state: start
end state: end
table:
  start:
    '0': {R: zero_1}
    '1': {write: 0, R: one_1}
  zero_1:
    '0': {write: 0, R: zero_2}
    '1': {write: 0, R: one_2}
  one_1:
    '0': {write: 1, R: zero_2}
    '1': {write: 1, R: one_2}
  zero_2:
    '0': {write: 0, R: zero_3}
    '1': {write: 0, R: one_3}
  one_2:
    '0': {write: 1, R: zero_3}
    '1': {write: 1, R: one_3}
  zero_3:
    '0': {write: 0, R: zero_4}
    '1': {write: 0, R: one_4}
  one_3:
    '0': {write: 1, R: zero_4}
    '1': {write: 1, R: one_4}
  zero_4:
    '0': {write: 0, R: zero_5}
    '1': {write: 1, R: one_5}
  one_4:
    '0': {write: 1, R: zero_5}
    '1': {write: 1, R: one_5}
  zero_5:
    [0, 1]: {write: 0, L: 5_Z}
  one_5:
    [0, 1]: {write: 1, L: 5_1}
  5_Z:
    '0': {L: 4_Z}
    '1': {L: 4_1}
  5_1:
    '0': {L: 4_1}
    '1': {L: 4_11}
  4_Z:
    '0': {L: 3_Z}
    '1': {L: 3_1}
  4_1:
    '0': {L: 3_1}
    '1': {L: 3_11}
  4_11:
    '0': {L: 3_11}
    '1': {L: 3_111}
  3_Z:
    [0,1]: {L: 2_Z}
  3_1:
    '0': {L: 2_Z}
    '1': {L: 2_11}
  3_11:
    '0': {L: 2_11}
    '1': {L: 2_111}
  3_111:
    [0,1]: {L: 2_111}
  2_Z:
    [0,1]: {L: end}
  2_11:
    '0': {L: end}
    '1': {L: 1_111}
  2_111:
    [0,1]: {L: 1_111}
  1_111:
    [0,1]: {write: 1, L: end}
  end:
",2023-10-18T17:31:36+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 3",valetedd,"![turingex_3](https://github.com/comp-think/2023-2024/assets/147620147/12bf3567-09bc-45f8-9584-01a2f6a43e2f)
``` start state: start
table:
  
  start:
    ' ': {R: start}
    0: {R: check}
    1: {R: check_2}
  
  check:
    0: {R: check}
    1: {R: check_2}
    ' ': {L: return_n}
  
  check_2:
    0: {R: check_2}
    1: {R: check_3}
    ' ': {L: return_n}
  
  check_3:
    0: {R: check_3}
    1: {L: return_y}
    ' ': {L: return_n}
  
  return_n:
    [0,1]: {L: return_n}
    ' ': {write: 0, L: end}
  
  return_y:
    [0,1]: {L: return_y}
    ' ': {write: 1, L: end}
  
  end: ",2023-10-19T13:46:38+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 3",qwindici,"Update -- Without using dashes as in the first try: 

```
input: ' 10001'
blank: ' '
start state: start
table:
  start:
    ' ': {write: ' ', R: s0}
  s0:
   1: {R: s1}
   0: {R}
   ' ': {L: return_0}
  s1:
   1: {R: s2}
   0: {R}
   ' ': {L: return_0}
  s2: 
    1: {L: return_1}
    0: {R}
    ' ': {L: return_0}
  return_1: 
    [0, 1]: {L}
    ' ': {write: 1, L: end}
  return_0:
    [0, 1]: {L}
    ' ': {write: 0, L: end}
  end: 
```
 -------
 As in the second exercise, I use the s(n) to indicate the counting of 1s. However, in this case, instead of going to state 0 when a 0 is found, the machine stays in the same state. As before, I used dashes to get where the sequence ends in order to print the result. 

```
input: ' 01100'
blank: ' '
start state: start
table:
  start:
    ' ': {write: '-', R: s0}
  s0:
   1: {R: s1}
   0: {R}
   ' ': {L: return_0}
  s1:
   1: {R: s2}
   0: {R}
   ' ': {L: return_0}
  s2: 
    1: {R: return_1}
    0: {R}
    ' ': {L: return_0}
  return_1: 
    [0, 1]: {L}
    '-': {write: 1, L: end}
  return_0:
    [0, 1]: {L}
    '-': {write: 0, L: end}
  end:
```

<img width=""685"" alt=""Screenshot 2023-10-19 at 17 27 22"" src=""https://github.com/comp-think/2023-2024/assets/85878598/01f822d3-bf24-4926-bfa9-211f89494ea1"">

",2023-10-19T15:28:23+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 3",Liber-R,"Reformulation without blank symbols in the instructions.
![Screenshot 2023-10-21 125130](https://github.com/comp-think/2023-2024/assets/132198967/b5d699ac-a400-43e0-8487-6e5a1bd85b53)
",2023-10-19T15:50:53+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 3",ThIheb,"![Exercise 3](https://github.com/comp-think/2023-2024/assets/146657705/b8366ea9-4cbe-407d-a26e-3235921e3624)
Same principle as exercise 2
",2023-10-19T21:06:22+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 3",essepuntato,"Hi all, thanks for your takes. Just a note for all: remember that you are entitled to use only two symbols in the Turing Machines, i.e. `0` and `1`, so the blank symbol should be `0`. Using, as a blank symbol, the space character means to use three symbols in the Turing Machine...",2023-10-20T07:05:39+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 3",CarlaMenegat,"![Captura de Tela 2023-10-20 às 07 56 11](https://github.com/comp-think/2023-2024/assets/146187896/23066b06-cb23-466d-ac3c-6d3723cf6c54)
",2023-10-20T10:05:04+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 3",valetedd,"**Second attempt, w/o blanks**

![turingex_3](https://github.com/comp-think/2023-2024/assets/147620147/83da1aed-1d62-42bc-b95a-f6dade814586)
``` 
start state: start
table:
  
  start:
    0: {R: check_p1}
    
    # checking first three positions, count=0
  
  check_p1:
    0: {write: 1, R: check_p2}
    1: {R: check1_p2}
  check_p2:
    0: {write: 1, R: check_p3}
    1: {R: check1_p3}
  check_p3:
    0: {R: end}
    1: {R: check1_p4}
    
    # checking the three positions in the middle, count=1
  
  check1_p2:
    0: {write: 1, R: check1_p3}
    1: {R: check2_p3}
    
  check1_p3:
    0: {write: 1, R: check1_p4}
    1: {R: check2_p4}
    
  check1_p4:
    0: {R: end}
    1: {R: check2_p5}
  
  # checking last three positions, count=2
  
  check2_p3:
    0: {write: 1, R: check2_p4}
    1: {R: return_y}
  check2_p4:
    0: {write: 1, R: check2_p5}
    1: {R: return_y}
  check2_p5:
    0: {R: end}
    1: {L: return_y}
 
  return_y:
    1: {L: return_y}
    0: {write: 1, R: end}",2023-10-20T16:11:49+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 3",frammenti,"Start state: start
End state: stop

<table>
	<tr>
		<th>Current state</th>
		<th>Tape symbol</th>
		<th>Write symbol</th>
		<th>Move head</th>
		<th>Next state</th>
	</tr>
	<tr>
		<td>start</td>
		<td>1 or 0</td>
		<td>0</td>
		<td>R</td>
		<td>0-0</td>
	</tr>
	<tr>
		<td rowspan=""2"">0-0</td>
		<td>1</td>
		<td></td>
		<td>R</td>
		<td>1-0</td>
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>R</td>
		<td>0-1</td>
	</tr>
	<tr>
		<td rowspan=""2"">1-0</td>
		<td>1</td>
		<td></td>
		<td>R</td>
		<td>2-0</td>
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>R</td>
		<td>1-1</td>
	</tr>
	<tr>
		<td rowspan=""2"">2-0</td>
		<td>1</td>
		<td></td>
		<td>L</td>
		<td>result</td>
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>R</td>
		<td>2-1</td>
	</tr>
	<tr>
		<td rowspan=""2"">0-1</td>
		<td>1</td>
		<td></td>
		<td>R</td>
		<td>1-1</td>
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>R</td>
		<td>0-2</td>
	</tr>
	<tr>
		<td rowspan=""2"">0-2</td>
		<td>1</td>
		<td></td>
		<td>R</td>
		<td>1-2</td>
	</tr>
	<tr>
		<td>0</td>
		<td></td>
		<td>L</td>
		<td>stop</td>
	</tr>
	<tr>
		<td rowspan=""2"">1-1</td>
		<td>1</td>
		<td></td>
		<td>R</td>
		<td>2-1</td>
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>R</td>
		<td>1-2</td>
	</tr>
	<tr>
		<td rowspan=""2"">2-1</td>
		<td>1</td>
		<td></td>
		<td>L</td>
		<td>result</td>
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>R</td>
		<td>2-2</td>
	</tr>
	<tr>
		<td rowspan=""2"">1-2</td>
		<td>1</td>
		<td></td>
		<td>R</td>
		<td>2-2</td>
	</tr>
	<tr>
		<td>0</td>
		<td></td>
		<td>L</td>
		<td>stop</td>
	</tr>
	<tr>
		<td rowspan=""2"">2-2</td>
		<td>1</td>
		<td></td>
		<td>L</td>
		<td>result</td>
	</tr>
	<tr>
		<td>0</td>
		<td></td>
		<td>L</td>
		<td>stop</td>
	</tr>
	<tr>
		<td rowspan=""2"">result</td>
		<td>1</td>
		<td></td>
		<td>L</td>
		<td>result</td>
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>R</td>
		<td>stop</td>
	</tr>
	<tr>
		<td>stop</td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
</table>

```YAML
# search for at least three 1s in any order in 5 digit sequence
input: '001101' # as an example
blank: '0'
start state: start
table:
  # initialize result cell to 0
  start:
    [1,0]: {write: 0, R: 0-0}
  # state = A-B where A is the n. of occurrences of 1s so far and B is the same for 0s
  # all 1s first (fastest route to result = 1)
  0-0:
    [1]: {R: 1-0}
    [0]: {write: 1, R: 0-1}
  1-0:
    [1]: {R: 2-0}
    [0]: {write: 1, R: 1-1}
  2-0:
    [1]: {L: result}
    [0]: {write: 1, R: 2-1}
  # all 0s first (fastest route to result = 0)
  0-1:
    [1]: {R: 1-1}
    [0]: {write: 1, R: 0-2}
  0-2:
    [1]: {R: 1-2}
    [0]: {L: stop}
  # mixed occurrences of 1s and 0s
  1-1:
    [1]: {R: 2-1}
    [0]: {write: 1, R: 1-2}
  2-1:
    [1]: {L: result}
    [0]: {write: 1, R: 2-2}
  1-2:
    [1]: {R: 2-2}
    [0]: {L: stop}
  2-2:
    [1]: {L: result}
    [0]: {L: stop}
  # positive result: go backwards until 0 (starting cell) and print 1
  result:
    [1]: {L: result}
    [0]: {write: 1, R: stop}
  stop:
```

[Turing machine visualization](https://turingmachine.io/?import-gist=554066e96fd0c7e50e9171588a8bc6c3)

![image](https://github.com/comp-think/2023-2024/assets/146438454/ceb52a3c-14d4-4948-9d9a-bd4126b08e11)
",2023-10-21T06:43:22+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 3",simocasaz,"```
input: '000111'
blank: '0'
start state: A
table:
  A:
    0: { write: 0, R: B }
  
  B:
    0: { write: 1, R: C }
    1: { write: 1, R: oneone }
    
  C:
    0: { write: 1, R: D }
    1: { write: 1, R: oneone }
    
  D:
    0: { write: 1, R: E }
    1: { write: 1, R: oneone }
  
  E:
    0: { write: 1, R: F }
    1: { write: 1, R: oneone }
    
  F:
    0: { write: 1, L: end }
    1: { write: 1, L: end }
    
  D1:
    0: { write: 1, R: E1 }
    1: { write: 1, R: twoones }
    
  E1:
    0: { write: 1, R: F1 }
    1: { write: 1, R: twoones }
  
  F1:
    0: { write: 1, L: end }
    1: { write: 1, L: end }
    
  E2:
    0: { write: 1, R: F2 }
    1: { write: 1, L: yesresult }
    
  F2:
    0: { write: 1, L: end }
    1: { write: 1, L: yesresult }
    
  oneone:
    0: { write: 1, R: D1 }
    1: { write: 1, R: twoones }
  
  twoones:
    0: { write: 1, R: E2 }
    1: { write: 1, L: yesresult }
    
  yesresult:
    1: { write: 1, L: yesresult }
    0: { write: 1, L: end }
    
  
  end:
```

![esercizio3-computability](https://github.com/comp-think/2023-2024/assets/146863760/8c7232b1-9687-4aa9-b900-50ee8070d991)
",2023-10-22T17:01:36+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 2",vattelalberto,"I don't know if it is possible to implement the machine in a more compact way, here is the turingmachine.io code that i created that can solve the problem for any 5-digit input, shifting the input number to the right and displaying the result in the starting cell.
My implementations starts by copying the five digits one cell to the right, and then work backwards to check if there are three consecutive 1s.

```
input: '00000'
blank: '0'
start state: start
end state: end
table:
  start:
    '0': {R: zero_1}
    '1': {write: 0, R: one_1}
  zero_1:
    '0': {write: 0, R: zero_2}
    '1': {write: 0, R: one_2}
  one_1:
    '0': {write: 1, R: zero_2}
    '1': {write: 1, R: one_2}
  zero_2:
    '0': {write: 0, R: zero_3}
    '1': {write: 0, R: one_3}
  one_2:
    '0': {write: 1, R: zero_3}
    '1': {write: 1, R: one_3}
  zero_3:
    '0': {write: 0, R: zero_4}
    '1': {write: 0, R: one_4}
  one_3:
    '0': {write: 1, R: zero_4}
    '1': {write: 1, R: one_4}
  zero_4:
    '0': {write: 0, R: zero_5}
    '1': {write: 1, R: one_5}
  one_4:
    '0': {write: 1, R: zero_5}
    '1': {write: 1, R: one_5}
  zero_5:
    [0, 1]: {write: 0, L: 5_Z}
  one_5:
    [0, 1]: {write: 1, L: 5_1}
  5_Z:
    '0': {L: 4_Z}
    '1': {L: 4_1}
  5_1:
    '0': {L: 4_Z}
    '1': {L: 4_11}
  4_Z:
    '0': {L: 3_Z}
    '1': {L: 3_1}
  4_1:
    '0': {L: 3_Z}
    '1': {L: 3_11}
  4_11:
    '0': {L: 3_Z}
    '1': {L: 3_111}
  3_Z:
    [0,1]: {L: 2_Z}
  3_1:
    '0': {L: 2_Z}
    '1': {L: 2_11}
  3_11:
    '0': {L: 2_Z}
    '1': {L: 2_111}
  3_111:
    [0,1]: {L: 2_111}
  2_Z:
    [0,1]: {L: end}
  2_11:
    '0': {L: end}
    '1': {L: 1_111}
  2_111:
    [0,1]: {L: 1_111}
  1_111:
    [0,1]: {write: 1, L: end}
  end:
  ",2023-10-18T17:19:31+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 2",valetedd,"![turingex_2](https://github.com/comp-think/2023-2024/assets/147620147/1978ebfc-16d7-46e2-8196-871337d20455)
``` start state: start
table:
  
  start:
    ' ': {R: start}
    0: {R: check}
    1: {R: check_2}
  
  check:
    0: {R: check}
    1: {R: check_2}
    ' ': {L: return_n}
  check_2:
    0: {R: check}
    1: {R: check_3}
    ' ': {L: return_n}
  check_3:
    0: {R: check}
    1: {L: return_y}
    ' ': {L: return_n}
  return_n:
    [0,1]: {L: return_n}
    ' ': {write: 0, L: end}
  
  return_y:
    [0,1]: {L: return_y}
    ' ': {write: 1, L: end}
  end: ``` ",2023-10-19T13:45:20+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 2",qwindici,"In my code q(n) identifies how many 1s have been counted. When a 0 is encountered it goes back to q0 since the sequence of 1s should restart. I used dashes '-' (not sure this is allowed though) to identify the start and the end of the sequence in order to print the result. 

```
input: ' 00011'
blank: ' '
start state: start
table:
  start:
    ' ': {write: '-', R: q0}
  q0:
    ' ': {write: '-', L: return_0}
    0: {R}
    1: {R: q1}
  q1:
    0: {R: q0}
    1: {R: q2}
    ' ': {L: return_0}
  q2:
    0: {R: q0}
    1: {R: return_1}
    ' ': {L: return_0}
  return_1:
    [1, 0]: {L}
    '-': {write: 1, L: end}
  return_0: 
    [1, 0]: {L}
    '-': {write: 0, L: end}
  end:
```

<img width=""652"" alt=""Screenshot 2023-10-19 at 16 55 22"" src=""https://github.com/comp-think/2023-2024/assets/85878598/e81f808d-a8d2-4ec3-aa55-9b116794a250"">

**Update -- Managed to rewrite it without using dashes:**

```
input: ' 11111'
blank: ' '
start state: start
table:
  start:
    ' ': {R: q0}
  q0:
    ' ': {L: return_0}
    0: {R}
    1: {R: q1}
  q1:
    0: {R: q0}
    1: {R: q2}
    ' ': {L: return_0}
  q2:
    0: {R: q0}
    1: {L: return_1}
    ' ': {L: return_0}
  return_1:
    [1, 0]: {L}
    ' ': {write: 1, L: end}
  return_0: 
    [1, 0]: {L}
    ' ': {write: 0, L: end}
  end:
```
",2023-10-19T14:57:25+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 2",Liber-R,"Reformulation without blank symbols in the instructions
![Screenshot 2023-10-21 121919](https://github.com/comp-think/2023-2024/assets/132198967/4c882db6-e86f-44df-8259-e24a766722e2)
",2023-10-19T15:25:07+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 2",ThIheb,"![Exercise 2](https://github.com/comp-think/2023-2024/assets/146657705/844e2fe5-5953-4c24-8484-09d8811a54bb)
The initial sequence checks the numbers from left to right, if it finds three consecutive '1' it runs back to the starting position with the help of R1 otherwise it keeps checking if it finds a blank space or 0 it returns R0 which gives us 0",2023-10-19T20:18:20+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 2",rufferbaraldi,"I couldn't programm the part ""where the cell corresponding to the starting position of the head is where the final result must be stored."", But it works well despite this missing command. 

![Turing](https://github.com/comp-think/2023-2024/assets/147972854/df47ef89-63d4-45e4-8b8e-d8d4665d27de)


> input: '00111' or '01110' or '11100' or any other haha 
blank: '0'
start state: A
table:
  A:
    [0]: {write: 0, R: B}
    [1]: {write: 0, R: C}
  B:
     [0]: {write: 0, R: D}
     [1]: {write: 0, R: E}
  C:
    [0]: {write: 0, R: D}
    [1]: {write: 0, R: F}
  D:
    [0]: {write: 0, R: End}
    [1]: {write: 0, R: G}
  E:
     [0]: {write: 0, R: End}
     [1]: {write: 0, R: H}
  F:
    [0]: {write: 0, R: End}
    [1]: {write: 1, R: End}
  G:
    [0]: {write: 0, R: End}
    [1]: {write: 0, R: J}
  H: 
    [0]: {write: 0, R: End}
    [1]: {write: 1, R: End}
  J:
   [0]: {write: 0, R: End}
   [1]: {write: 1, R: End}
  End:
   [0,1]: {write: 0, R}
",2023-10-19T22:21:53+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 2",essepuntato,"Hi all, thanks for your takes. Just a note for all: remember that you are entitled to use only two symbols in the Turing Machines, i.e. `0` and `1`, so the blank symbol should be `0`. Using, as a blank symbol, the space character means to use three symbols in the Turing Machine...",2023-10-20T07:05:33+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 2",frammenti,"Start state: Start
End state: End

<table>
	<tr>
		<th>Current state</th>
		<th>Tape symbol</th>
		<th>Write symbol</th>
		<th>Move head</th>
		<th>Next state</th>
	</tr>
	<tr>
		<td>Start</td>
		<td>1 or 0</td>
		<td>0</td>
		<td>R</td>
		<td>First</td>
	</tr>
	<tr>
		<td rowspan=""2"">First</td>
		<td>1</td>
		<td></td>
		<td>R</td>
		<td>Second1</td>
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>R</td>
		<td>Second0</td>
	</tr>
	<tr>
		<td rowspan=""2"">Second1</td>
		<td>1</td>
		<td></td>
		<td>R</td>
		<td>Third1</td>
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>R</td>
		<td>Second0</td>
	</tr>
	<tr>
		<td rowspan=""2"">Third1</td>
		<td>1</td>
		<td></td>
		<td>L</td>
		<td>Result</td>
	</tr>
	<tr>
		<td>0</td>
		<td></td>
		<td>L</td>
		<td>End</td>
	</tr>
	<tr>
		<td rowspan=""2"">Second0</td>
		<td>1</td>
		<td></td>
		<td>R</td>
		<td>Second1</td>
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>R</td>
		<td>Third0</td>
	</tr>
	<tr>
		<td rowspan=""2"">Third0</td>
		<td>1</td>
		<td></td>
		<td>R</td>
		<td>Second1</td>
	</tr>
	<tr>
		<td>0</td>
		<td></td>
		<td>L</td>
		<td>End</td>
	</tr>
	<tr>
		<td rowspan=""2"">Result</td>
		<td>1</td>
		<td></td>
		<td>L</td>
		<td>Result</td>
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>R</td>
		<td>End</td>
	</tr>
	<tr>
		<td>End</td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
</table>

```YAML
# search for three consecutive 1s in 5 digit sequence
input: '011011' # as an example
blank: '0'
start state: Start
table:
  # initialize result cell to 0
  Start:
    [1,0]: {write: 0, R: First}
  # if 1 search for second 1, if 0 search for second 0
  First:
    [1]: {R: Second1}
    [0]: {write: 1, R: Second0}
  # if 1 search for third 1, if 0 search for second 0
  Second1:
    [1]: {R: Third1}
    [0]: {write: 1, R: Second0}
  # if 1 print result, if 0 end
  # (with 1/2 digits left, impossible to find three 1s)
  Third1:
    [1]: {L: Result}
    [0]: {L: End}
  # if 1 search for second 1, if 0 search for third 0
  Second0:
    [1]: {R: Second1}
    [0]: {write: 1, R: Third0}
  # if 1 search for second 1, if 0 end
  Third0:
    [1]: {R: Second1}
    [0]: {L: End}
  # positive result: go backwards until 0 (starting cell) and print 1
  Result:
    [1]: {L: Result}
    [0]: {write: 1, R: End}
  End:
```
[Turing machine visualization](https://turingmachine.io/?import-gist=a53574683646587452c7f6d3251054ec)
![image](https://github.com/comp-think/2023-2024/assets/146438454/6bc1c94c-ce32-49b1-b0a1-0940335ecf2b)

",2023-10-20T10:01:00+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 2",valetedd,"**Improving on previous attempt, which used blanks:**

![turingex_2](https://github.com/comp-think/2023-2024/assets/147620147/4bff2b24-8e7f-4708-b170-0006cc75801c)
``` blank: '0'
start state: start
table:
  
  start:
    0: {R: check_1}
  
  check_1:
    0: {write: 1, R: check_2}
    1: {R: ok_1}
    
  check_2:
    0: {write: 1, R: check_3}
    1: {R: ok_1}
    
  check_3:
    0: {L: end}
    1: {R: ok_1}

  ok_1:
    0: {write: 1, R: check_3}
    1: {R: ok_2}
  
  ok_2:
    0: {L: end}
    1: {R: ok_3}
  
  ok_3:
    [0, 1]: {L: return_y} 
  
  return_y:
    1: {L: return_y}
    0: {write: 1, R: end}
  
  end: 


",2023-10-20T15:12:53+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 2",simocasaz,"
```
input: '010011'
blank: '0'
start state: A
table:
  A:
    0: { write: 0, R: B }
  
  B:
    0: { write: 1, R: C }
    1: { write: 1, R: oneconsecutive }
    
  C:
    0: { write: 1, R: D }
    1: { write: 1, R: oneconsecutive }
    
  D:
    0: { write: 1, R: E }
    1: { write: 1, R: oneconsecutive }
  
  E:
    0: { write: 1, R: F }
    1: { write: 1, R: oneconsecutive }
    
  F:
    0: { write: 1, L: end }
    1: { write: 1, L: end }
    
  
  oneconsecutive:
    0: { write: 1, R: D }
    1: { write: 1, R: twoconsecutives }
  
  twoconsecutives:
    0: { write: 1, R: E }
    1: { write: 1, L: yesresult }
    
  yesresult:
    1: { write: 1, L: yesresult }
    0: { write: 1, L: end }
    
  
  end:

```

![esercizio2-computability](https://github.com/comp-think/2023-2024/assets/146863760/041d3153-b093-43d4-8af3-f8a0dd21a6fc)
",2023-10-22T16:50:51+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 2",CarlaMenegat,"A new tentative of solution:

![Captura de Tela 2023-11-02 às 14 19 36](https://github.com/comp-think/2023-2024/assets/146187896/965d20bf-6fb9-4cfe-bfe8-7f2771ddf2cc)
",2023-11-02T13:21:33+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",CarlaMenegat,"
![Captura de Tela 2023-10-20 às 12 36 26](https://github.com/comp-think/2023-2024/assets/146187896/b3278362-766c-4389-aca2-fd72cfb71d83)


![Captura de Tela 2023-10-18 às 14 18 24](https://github.com/comp-think/2023-2024/assets/146187896/d26b39c1-68d4-455d-b12e-87fce817bfe0)
",2023-10-18T12:18:46+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",vattelalberto,"![image](https://github.com/comp-think/2023-2024/assets/99617159/5ce65ade-38df-405a-81b2-f55a31effe66)
I managed to design a turing machine that works if the input is fixed (0) but could not design one working for any input number with only 4 nodes.
This is my turingmachine.io code:

```input: '0'
blank: '0'
start state: A
end state: D
table:
  A:
    '0' : {write: 1, R: B}
    '1'  : {write: 0, L: C}
  B:
    [0, 1] : {write: 1, L: A}
  C:
    [0, 1] : {write: 1, R: D}
  D:",2023-10-18T16:35:59+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",Liber-R,"![Screenshot 2023-10-19 180741](https://github.com/comp-think/2023-2024/assets/132198967/0aa346c9-7ce5-47d7-a002-e8cf4ee99678)
![Screenshot 2023-10-19 180733](https://github.com/comp-think/2023-2024/assets/132198967/3098ebdf-3f47-4808-84be-1cb19e4e901e)
",2023-10-18T17:04:39+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",Asemica-me,"![image](https://github.com/comp-think/2023-2024/assets/104790378/fcc5cb4e-a6a8-4e0d-8a50-b5c862000106)
```c
blank: '0' 
start state: A 
table: 
  A:
    0: { write: 1, L: B } 
    1: { write: 0, R: C }
  B:
    0: { write: 1, R: A }
  C:
    0: { write: 1, R: D }
  D:
``` 
![image](https://github.com/comp-think/2023-2024/assets/104790378/1f05a842-fb69-416d-8244-7f2c3eb36da7)

",2023-10-18T18:58:52+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",rufferbaraldi,"![Turingtable](https://github.com/comp-think/2023-2024/assets/147972854/8de53f74-b357-429b-a7a7-e78104fd4899)
![Turing](https://github.com/comp-think/2023-2024/assets/147972854/84051397-edb3-4767-9cbe-5c93ed1c999d)


input: '000'
blank: '0'
start state: A
end state: D
table:

  A:
    [0, 1] : {write: 1, R: B}
  B:
    [0, 1] : {write: 0, R: C}
  C:
    [0, 1] : {write: 1, L: D}
  D:
",2023-10-19T09:19:20+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",qwindici,"![telegram-cloud-photo-size-4-5875183131563245999-y](https://github.com/comp-think/2023-2024/assets/85878598/467a1e9c-b0bf-4be0-9c6b-0c21dc604734)

```
blank: '0'
start state: A
table:

  A:
    0: {write: 1, L: B}
  B: 
    1: {write: 0, R: C}
    0: {write: 1, R}
  C:
    0: {write: 1, L: D}
  D:

```

<img width=""389"" alt=""Screenshot 2023-10-19 at 13 37 47"" src=""https://github.com/comp-think/2023-2024/assets/85878598/12d3dc43-0f7b-4c96-be75-02f152c824f2"">
",2023-10-19T11:38:19+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",rufferbaraldi,"Correcting...

![Turingtable](https://github.com/comp-think/2023-2024/assets/147972854/214cb0dd-114c-40b1-8936-5d6169803a59)
![Turing](https://github.com/comp-think/2023-2024/assets/147972854/71709371-0fc7-46fc-95c8-aca3d5fd1927)
",2023-10-19T13:24:44+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",parkful,"<img width=""619"" alt=""Screenshot 2023-10-19 at 17 08 45"" src=""https://github.com/comp-think/2023-2024/assets/147994157/56438315-5d94-4071-9050-ebbe0c52cb46"">

<img width=""461"" alt=""Screenshot 2023-10-19 at 17 04 41"" src=""https://github.com/comp-think/2023-2024/assets/147994157/661c71e4-0bd2-4647-954e-e71afabf02ef"">

<img width=""683"" alt=""Screenshot 2023-10-19 at 17 06 02"" src=""https://github.com/comp-think/2023-2024/assets/147994157/cc7006ed-db33-4548-a99c-d1c90e18f238"">
98bbc8"">


",2023-10-19T15:06:46+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",valetedd,"![turingex_1](https://github.com/comp-think/2023-2024/assets/147620147/82ea3756-548c-4435-87f9-cea76c909e8e)
``` start state: A
table:
  A:
    [0, 1, ' ']: {write: '0', L: B}
  B:
    "" "": {write: 1, R: B}
    0: {R: C}
    1: {write: 0, R: C}
  C:
    "" "": {write: 1, L: D}
  D: ```",2023-10-19T15:22:42+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",valentinabertelli,"![ca3_es1](https://github.com/comp-think/2023-2024/assets/146438200/feb66334-bd6f-4cee-b428-211d3630ed14)
blank: "" ""
start state: A
table:
  A:
   0: {L: C}
   1: {L: C}
   "" "": {write: 0, R: B}
  B:
   0: {write: 1, L: A}
   1: {write: 1, L: A}
   "" "": {write: 1, L: A}
  C:
   0: {write: 1, L: D}
   1: {write: 1, L: D}
   "" "": {write: 1, L: D}
  D:",2023-10-19T17:59:37+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",VirginiaDa00,"<img width=""559"" alt=""Lez 3  Esercizio 1"" src=""https://github.com/comp-think/2023-2024/assets/147997710/b89e28fe-3dc7-49fa-adf7-eeb0ab5d12f9"">
",2023-10-20T07:02:59+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",essepuntato,"Hi all, thanks for your takes. Just a note for all: remember that you are entitled to use only two symbols in the Turing Machines, i.e. `0` and `1`, so the blank symbol should be `0`. Using, as a blank symbol, the space character means to use three symbols in the Turing Machine...",2023-10-20T07:05:26+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",frammenti,"Start state: A
End state: D

|Current state|Tape symbol|Write symbol|Move head|Next state|
|---|---|---|---|---|
|A|0|1|L|B|
|B|0|1|R|C|
|C|1|0|R|B|
|C|0||R|D|
|D|

```yaml
# 1 is printed only left and right the starting position.
blank: '0'
start state: A
table:
  # print 1, move left
  A:
    [0]: {write: 1, L: B}
  # print 1, move back right
  B:
    [0]: {write: 1, R: C}
  # check if 1, turn it to 0 and back to B, otherwise stop
  C:
    [1]: {write: 0, R: B}
    [0]: {R: D}
  D:
```

![image](https://github.com/comp-think/2023-2024/assets/146438454/582f5139-fb5e-484c-be0c-27efa5efe24f)
",2023-10-20T08:13:04+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",saramadonia,"![b3dbff25-0e86-4136-99f7-c9bb30a5caf0](https://github.com/comp-think/2023-2024/assets/146438182/32a0a6fd-77b9-4402-b277-2929f90fa2c3)
![957e68b0-618f-47a6-a4bf-33fac453b8a0](https://github.com/comp-think/2023-2024/assets/146438182/f6acf67f-4c08-474a-ab8a-425f6be7a370)
",2023-10-20T08:42:07+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",annapasetto0,"input: '00000'
blank: '0'
start state: A
table:
  A: 
    0: {write: 1, L: B}
    1: {write: 0, R: C}
  B:
    0: {write: 1, R: A}
  C:
    0: {write: 1, R: D}
  D:


![tab](https://github.com/comp-think/2023-2024/assets/136476266/235aaa6c-1ca6-4b03-9af7-dc1554dfbcda)

![tmv](https://github.com/comp-think/2023-2024/assets/136476266/d7fdf89d-5d5c-4126-a80b-6482331b5838)
",2023-10-20T09:45:50+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",simocasaz,"![IMG_20231022_183655.jpg](https://github.com/comp-think/2023-2024/assets/146863760/bd569101-9316-45de-8417-549ee0980989)

",2023-10-22T17:04:38+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",MariaFrancesca6,"Table of instructions: 

 ```
 blank: '0'
  start state: A
  table:
    A:
      0: {write: 1, L: B}  
      1: {write: 0, R: C}
    B:
      0: {write: 1, R: A}
    C:
      0: {write: 1, R: D}
    D:
```

Starting state: 

![image](https://github.com/comp-think/2023-2024/assets/146453979/5d7dbfb3-f2ba-46b3-b8ea-4d1e75717e56)

Final state:

![image](https://github.com/comp-think/2023-2024/assets/146453979/c7a18eed-6b82-4954-a45d-ae6c79ff97f5)
",2023-10-22T21:31:59+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",Sergpoipoip,"[](url)
![turing_machine_1](https://github.com/comp-think/2023-2024/assets/35369089/12359db3-3572-48e7-ba30-c2c2add10676)
",2023-10-23T16:26:21+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",Alice-Ant,"![IMG_2450](https://github.com/comp-think/2023-2024/assets/147634010/e9190714-1147-4f27-8a71-9cfb6763b2a6)
The machine starts in state A. If it reads a 0 or 1 in state A, it writes 1, moves right, and transitions to state B. In state B, if it reads a 0, it writes 0, moves left, and transitions to state C. If it reads a 1, it writes 1, moves right, and stays in state B. In state C, regardless of the input symbol, it writes 0, moves right, and transitions to the final state D. Once in state D, the machine halts and does not have any instructions specified for this state.",2023-10-30T08:52:21+00:00
comp-think/2023-2024,"Lecture ""Computability"", exercise 1",enricabruno,"Initial state: 
<img width=""1000"" alt=""computability-ex1-a"" src=""https://github.com/comp-think/2023-2024/assets/83347862/e24be842-af54-4992-9b01-13de8a283a6e"">

Final state:
<img width=""1003"" alt=""computability-ex1-b"" src=""https://github.com/comp-think/2023-2024/assets/83347862/1159ad45-bea7-41f3-9bd2-d3de43ccc2e3"">

",2023-11-02T10:49:40+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",vattelalberto,"![image](https://github.com/comp-think/2023-2024/assets/99617159/32d593e2-a76e-4838-ab7d-f9ccae6757e4)
-------------------------------------------------------------------------------------------------------------------------------
![image](https://github.com/comp-think/2023-2024/assets/99617159/0c97fd91-380f-4865-9ca8-60119ebb236f)
",2023-10-13T12:56:30+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",katyakrsn,"1)
<img width=""869"" alt=""1"" src=""https://github.com/comp-think/2023-2024/assets/145998112/c2929bf4-ce36-46f2-8e6c-d3e87ae57ed8"">

2)
<img width=""827"" alt=""2"" src=""https://github.com/comp-think/2023-2024/assets/145998112/0f78ca31-d8b8-41df-8068-d2786379e26c"">
",2023-10-13T20:01:50+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",frammenti,"![Fibonacci1](https://github.com/comp-think/2023-2024/assets/146438454/10bfce6c-7820-49ce-8a62-1e0e5b2064d8)
![Fibonacci2 drawio](https://github.com/comp-think/2023-2024/assets/146438454/df7cab3b-c204-4aea-8d1d-488952886e27)
![Fibonacci3 drawio](https://github.com/comp-think/2023-2024/assets/146438454/cb04a6b4-3aa0-460f-88cc-00af25844ffb)
",2023-10-14T07:27:50+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",saramadonia,"![flowchart 1_page-0001](https://github.com/comp-think/2023-2024/assets/146438182/5edcaca6-0398-4870-9d9f-951452f16f44)
![flowchart 2_page-0001](https://github.com/comp-think/2023-2024/assets/146438182/fcb2c818-06b4-45bd-a937-8387bcad9068)
",2023-10-14T14:02:07+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",qwindici,"![fibonacci1 (1)](https://github.com/comp-think/2023-2024/assets/85878598/47ef2569-15e6-43bd-8562-1317f7f2c6fe)
![fibonacci1](https://github.com/comp-think/2023-2024/assets/85878598/b3385fd8-6606-4562-a3b9-e0c569906876)
",2023-10-14T17:40:21+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",rufferbaraldi,"![Rubens drawio](https://github.com/comp-think/2023-2024/assets/147972854/aa5cfc80-ca10-4d11-bb46-bfdb198422b0)
![Rubens2 drawio](https://github.com/comp-think/2023-2024/assets/147972854/3316f8ca-68a0-442d-92b7-3f43873db30a)

",2023-10-15T10:19:52+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",CarlaMenegat,"Fibonacci sequence 1
![Captura de Tela 2023-10-15 às 12 16 31](https://github.com/comp-think/2023-2024/assets/146187896/fdf5d40c-e6f3-4e8d-8335-a63ba263d186)
Fibonacci sequence 2 
![Captura de Tela 2023-10-15 às 12 45 53](https://github.com/comp-think/2023-2024/assets/146187896/d40d7572-a081-4d01-9565-39ea9fd07c3d)

",2023-10-15T10:46:51+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",ThIheb,"![Problem 1](https://github.com/comp-think/2023-2024/assets/146657705/a1b501a5-4736-43b0-9de9-377ce8cc5359)
![Problem 2](https://github.com/comp-think/2023-2024/assets/146657705/21901ae7-736c-4521-be8b-586e5f9fa7d6)
",2023-10-15T19:09:08+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",valentinabertelli,"![flowchart 1](https://github.com/comp-think/2023-2024/assets/146438200/cc6fad18-bb60-4662-9429-8e30af043b6c)
![flowchart](https://github.com/comp-think/2023-2024/assets/146438200/4a8d55cc-7241-4d25-98fe-1fe9099697c0)
",2023-10-15T20:32:01+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",FranciscoWu,"![image](https://github.com/comp-think/2023-2024/assets/146438244/85f3cd3d-e8c4-497c-8a7e-9b3f0d0a5f25)
![image](https://github.com/comp-think/2023-2024/assets/146438244/9e6335a5-dfef-4314-8089-31fcc7881a61)
",2023-10-15T21:15:31+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",elena2notti,"![es2](https://github.com/comp-think/2023-2024/assets/146434685/6d87207c-f255-474d-b7f8-868a6da0803c)
",2023-10-16T10:29:51+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",Liber-R,"![Diagramma senza titolo drawio](https://github.com/comp-think/2023-2024/assets/132198967/4e50b6ff-ad6e-4c77-aef5-fef2f5ce1bc9)




![Fibonacci natural language second description flowchart](https://github.com/comp-think/2023-2024/assets/132198967/81b2603b-08ed-4e94-9e26-af2baa8e878d)
",2023-10-16T11:14:34+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",Chiaramartina,"<img width=""504"" alt=""Schermata 2023-10-16 alle 17 26 41"" src=""https://github.com/comp-think/2023-2024/assets/106493111/ce6b2924-5433-4f45-a2ca-1581b70552f6"">
",2023-10-16T15:27:31+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",csalguero10,"<img width=""863"" alt=""Captura de pantalla 2023-10-16 a la(s) 8 18 13 p m"" src=""https://github.com/comp-think/2023-2024/assets/122754852/d806bfd0-e85e-4e1b-a68b-9872926ebab2"">
<img width=""960"" alt=""Captura de pantalla 2023-10-16 a la(s) 8 18 44 p m"" src=""https://github.com/comp-think/2023-2024/assets/122754852/9efd3467-0e58-4d87-907b-c2a3236f6ab1"">
",2023-10-16T18:18:56+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",MariaFrancesca6,"![Fibonacci_1](https://github.com/comp-think/2023-2024/assets/146453979/ccc2cd6e-5cf6-4354-bb1d-834b68367d03)
![Fibonacci_2](https://github.com/comp-think/2023-2024/assets/146453979/a58f909f-c8f1-43c8-a7f3-fa770aaccf14)
",2023-10-16T20:17:12+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",alicepiazzi,"<img width=""600"" alt=""Schermata 2023-10-17 alle 09 30 47"" src=""https://github.com/comp-think/2023-2024/assets/105540684/b5756364-067d-49c2-891b-3c56cf48a85e"">


<img width=""786"" alt=""Schermata 2023-10-17 alle 09 40 47"" src=""https://github.com/comp-think/2023-2024/assets/105540684/ed5d64bc-23f5-4d8d-85e7-133890bca33c"">


",2023-10-17T07:45:26+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",valetedd,"![image](https://github.com/comp-think/2023-2024/assets/147620147/649c4fde-940b-4b11-afa2-e4c2333b98d9)
![image](https://github.com/comp-think/2023-2024/assets/147620147/f6aad9f4-e876-47a2-9759-73742f7cbf4d)

",2023-10-17T12:19:16+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",enricabruno,"![Lecture__Algorithms-ex3-a](https://github.com/comp-think/2023-2024/assets/83347862/10b08e89-2a49-4107-9b40-ae8958a3b01b)
![Lecture__Algorithms_-ex3-b](https://github.com/comp-think/2023-2024/assets/83347862/7f7c5ea9-a53a-4bb4-84f1-16ddeab04865)
",2023-10-17T16:09:08+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",simocasaz,"![IMG_20231017_182836.jpg](https://github.com/comp-think/2023-2024/assets/146863760/fc73e548-043a-4b96-90f8-6b5fe5d77480)

![IMG_20231017_183004.jpg](https://github.com/comp-think/2023-2024/assets/146863760/5e9d5cf7-eb05-41ab-a43b-394c1a9177b7)

",2023-10-17T16:30:39+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",VirginiaDa00,"![IMG_20231017_205029](https://github.com/comp-think/2023-2024/assets/147997710/09cdc367-4998-4dc8-b541-33ee91f89e2a)
",2023-10-17T18:57:47+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",Asemica-me,"Fibonacci algorithm num.1

> The function for calculating the nth Fibonacci number takes as input an integer “n”. If “n” is less than or equal to 0, then 0 is returned as a result. Otherwise, if “n” is less than or equal to 2, then 1 is returned. Otherwise, in all the other cases, associate the value “1” to two distinct variables “a” and “b”. Then, repeat the following operations indefinitely until a value is returned. Set the variable “c” as the sum of “a” plus “b”. If “n” is less than or equal to “3” then return “c”, otherwise assign the value of “b” to “a” and the value of “c” to “b”, and finally decrease the value of “n” by 1 before repeating. 

![1diag](https://github.com/comp-think/2023-2024/assets/104790378/af649870-60e0-4c50-a04e-daa902e6b409)



Fibonacci algorithm num.2

> The function for calculating the nth Fibonacci number takes as input an integer “n”. If “n” is less than or equal to 0, then 0 is returned as a result. Otherwise, if “n” is equal to 1, then 1 is returned. Otherwise, return the sum of the same function with “n-1” as input and still the same function with “n-2” as input.

![Untitled Diagram (1)](https://github.com/comp-think/2023-2024/assets/104790378/70420a7e-ca68-46c4-82a7-a827eebef719)
",2023-10-17T19:27:34+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",essepuntato,"Hi all, thanks for your takes. Just a few notes:

* You can avoid writing ""if"" and ""else if"" in decision widgets – they implicitly mean that.
* Try to run both the algorithms developed, passing 4 as input, and see if the result is what it should be expected (i.e. it should return 3). ",2023-10-18T07:15:33+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",NiccoloMolinati,"I know I'm late considering the assignment was due yesterday, but I still wanted to share!
![Screenshot 2023-10-17 020857 modificato](https://github.com/comp-think/2023-2024/assets/146438255/bdf66bca-b6f9-4443-bb0e-e953e388f9fe)

![Screenshot 2023-10-19 015624](https://github.com/comp-think/2023-2024/assets/146438255/6d53f6ff-460c-4cba-8079-80c4a46d4525)
",2023-10-18T23:59:42+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",Theengwar,"1st:
![comp-think 02 Ex03a NFKH](https://github.com/comp-think/2023-2024/assets/146437858/dd5ec9f1-186a-4712-99b8-2f20d4a5bc99)

2nd:
![comp-think 02 Ex03b NFKH](https://github.com/comp-think/2023-2024/assets/146437858/7516c204-0f30-4801-8363-cb1504ecf20a)
",2023-10-24T00:54:02+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",addonico,"![exercise 3-1](https://github.com/comp-think/2023-2024/assets/70325856/d4142993-ef7f-4fa3-aed9-44279d21c2d0)
![exercise 3-2](https://github.com/comp-think/2023-2024/assets/70325856/f583052d-2fae-42e6-844f-430b1bd252f4)
",2023-12-10T16:25:38+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",alichpova,"![F1 Fibonacci drawio](https://github.com/comp-think/2023-2024/assets/147817152/992d154d-30af-41d9-b7f0-bf077a09d20d)
",2024-07-02T20:39:47+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 3",alichpova,"![F2 Fibonacci drawio](https://github.com/comp-think/2023-2024/assets/147817152/19bdc6ff-1ace-42c7-a8cf-60fe97512b61)
",2024-07-02T21:10:35+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",FranciscoWu,"
![image](https://github.com/comp-think/2023-2024/assets/146438244/2dcf6655-25d9-4cb0-a46f-af778ce1d794)


word1 = input(""Input the word1:"")
word2 = input(""Input the word2:"")

if word1 == word2:
  print(""Yes"")
else:
  print(""No"")",2023-10-13T11:58:37+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",vattelalberto,"![image](https://github.com/comp-think/2023-2024/assets/99617159/1b820e4e-b3cd-4ecb-89ca-b6232e15075a)
",2023-10-13T12:31:40+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",elena2notti,"![ES 1](https://github.com/comp-think/2023-2024/assets/146434685/f85da817-c167-4eea-8927-2d28679d1576)
",2023-10-13T13:26:08+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",ThIheb,"![Flowchart](https://github.com/comp-think/2023-2024/assets/146657705/1f4f61b5-33b1-427e-8f74-165250826283)
",2023-10-13T15:24:18+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",saramadonia,"![flowchart_page-0001](https://github.com/comp-think/2023-2024/assets/146438182/fe9e28df-0256-45b1-9088-88a4b6f235d0)
",2023-10-13T15:48:35+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",katyakrsn,"
<img width=""762"" alt=""Ex 2"" src=""https://github.com/comp-think/2023-2024/assets/145998112/4f5fea0b-729c-4469-ada5-985db701099c"">
",2023-10-13T16:26:34+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",AnnaNicoletti,![image](https://github.com/comp-think/2023-2024/assets/147601727/0096bd7f-e4a8-4c1c-9e5a-070bf3ef37d9),2023-10-13T17:11:07+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",valentinabertelli,"![ex  2](https://github.com/comp-think/2023-2024/assets/146438200/0e9eefc2-a23a-49ea-96f2-643298901506)
",2023-10-13T17:54:20+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",qwindici,"<img width=""1041"" alt=""Screenshot 2023-10-14 at 10 28 36"" src=""https://github.com/comp-think/2023-2024/assets/85878598/1b04ceeb-5fbe-413c-9214-9cf2dfdb9e39"">
",2023-10-14T08:29:07+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",Asemica-me,"![Untitled Diagram](https://github.com/comp-think/2023-2024/assets/104790378/d7ae7eba-561f-4a70-b058-fdd82488ef1b)
",2023-10-14T14:54:26+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",CarlaMenegat,"
![Captura de Tela 2023-10-15 às 10 56 19](https://github.com/comp-think/2023-2024/assets/146187896/6999284d-fb49-4c65-b203-87120bd1a2b2)

",2023-10-15T08:57:47+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",rufferbaraldi,"![Untitled 2](https://github.com/comp-think/2023-2024/assets/147972854/930e6057-edd0-4ebe-bae8-7d99b6987411)
",2023-10-15T09:07:42+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",annapasetto0,"![Screenshot 2023-10-15 alle 11 29 41](https://github.com/comp-think/2023-2024/assets/136476266/a173ce22-84c2-48d7-b573-eef888f420e3)
",2023-10-15T09:31:18+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",matildepassafaro,"<img width=""517"" alt=""flowchart_exercise2"" src=""https://github.com/comp-think/2023-2024/assets/146438198/6cd756b4-75fa-4afb-8ee1-d52381a6f86b"">
",2023-10-15T10:57:50+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",simocasaz,"![IMG_20231015_165517.jpg](https://github.com/comp-think/2023-2024/assets/146863760/110b0006-fea6-4266-84fc-32500a06186e)

",2023-10-15T15:01:41+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",Liber-R,"![Finished_flowchart](https://github.com/comp-think/2023-2024/assets/132198967/a1771d46-03d1-4631-8e8e-17b2a030b29f)
",2023-10-16T09:58:19+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",Chiaramartina,"![Diagramma 1 drawio](https://github.com/comp-think/2023-2024/assets/106493111/dfb71171-f5c1-47b0-bccc-c4a1faeb7f3c)
",2023-10-16T10:26:30+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",csalguero10,"![untitled (1)](https://github.com/comp-think/2023-2024/assets/122754852/4806a559-4798-4b2b-b887-bbc0bf066789)
",2023-10-16T10:31:15+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",BeatriceBucci,"
<img width=""409"" alt=""Screenshot 2023-10-16 alle 12 47 04"" src=""https://github.com/comp-think/2023-2024/assets/99805412/b8bd2c26-cf6d-465e-add4-3873e2a41745"">
",2023-10-16T10:47:28+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",alicepiazzi,"
<img width=""647"" alt=""Schermata 2023-10-16 alle 16 40 43"" src=""https://github.com/comp-think/2023-2024/assets/105540684/8830caad-e7fb-44df-a1ca-61a0af7aaeaf"">
",2023-10-16T14:43:18+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",MariaFrancesca6,"![flowchart_1](https://github.com/comp-think/2023-2024/assets/146453979/61b12311-7777-4bc2-8d18-87a26323d757)
",2023-10-16T17:41:23+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",valetedd,"![image](https://github.com/comp-think/2023-2024/assets/147620147/dfb4b800-cb9d-4dcc-af72-67bc6b11ae51)
",2023-10-17T13:41:09+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",enricabruno,"![Lecture__Algorithms_-ex2](https://github.com/comp-think/2023-2024/assets/83347862/4764e440-db7b-4118-8135-8e2e994c489e)
",2023-10-17T15:59:41+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",Sergpoipoip,"[](url)
![flowchart_1](https://github.com/comp-think/2023-2024/assets/35369089/fb45f612-1055-4745-a328-3e0fe447b824)
",2023-10-17T16:12:36+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",VirginiaDa00,"![IMG_20231017_204920](https://github.com/comp-think/2023-2024/assets/147997710/271c4e32-a7c3-46f5-9827-269146873129)
",2023-10-17T18:57:01+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",essepuntato,"Hi, thanks for your takes. A few comments for you:

* The text says *objects* (that can be anything). It means that it should work also when you specify two integers as input. Thus, all the inputs talking about strings or words are a bit misleading.
* The string to return should be enclosed between double quotations (e.g. “yes”), since this is the way we have used to referring to a string, and to distinguish it from, for instance, integer. For instance “45” is a string composed of two characters, “4” and “5”, while 45 is the integer representing forty five.
* @elena2notti you return either 0 or 1. While these are reasonable outputs, they are not compliant with the natural language description, which says explicitly to return the string “yes” or “no” depending on the case.
* @BeatriceBucci it seems that your diagram goes beyond what is requested. Even if the process you describe can be formally correct, it does not address precisely the natural language text.
* @valetedd a few issue here. First, you cannot have two distinct inputs on two different branches, otherwise the computer do not know which branch to follow when it starts the execution - and, thus, you will miss one of the inputs. Second, the arrows starting from the decision widget should be labelled with yes/no or true/false to understand which one to follow depending on the result of the comparison.",2023-10-18T05:57:12+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",Theengwar,"![comp-think 02 Ex02 NFKH](https://github.com/comp-think/2023-2024/assets/146437858/a164117e-3b3d-4eb6-bc54-ab1349493938)
",2023-10-23T22:30:09+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",Alice-Ant,"<img width=""404"" alt=""Screenshot 2023-10-27 at 22 51 45"" src=""https://github.com/comp-think/2023-2024/assets/147634010/d5ac56a2-9b0d-4e73-bb2c-548d6fea50f5"">
",2023-10-27T20:52:30+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",addonico,"![flowchart(exercise 2) drawio](https://github.com/comp-think/2023-2024/assets/70325856/d9dd2fcc-ac4f-4a02-9687-9c6798a6f99f)
",2023-12-09T18:03:25+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 2",alichpova,"![Diagramme sans nom drawio](https://github.com/comp-think/2023-2024/assets/147817152/539ae2e1-0f3f-477f-96cf-0ac691e33737)
",2024-07-02T19:41:32+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",vattelalberto,The output would be 2 with these inputs,2023-10-13T11:10:41+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",FranciscoWu,"2, since both appeared",2023-10-13T11:42:56+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",katyakrsn,"2, because both of these input values are in the bibliographic entry",2023-10-13T11:49:44+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",qwindici,2,2023-10-13T11:51:19+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",elena2notti,2,2023-10-13T11:57:13+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",ThIheb,The output would be 2 since the two words can be found in the bibliographic entry,2023-10-13T15:03:43+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",saramadonia,"the output would be 2 because the result value initialised to 0 adds up to 1 each time the input values appear in the bibliographic entry, that is two times.",2023-10-13T15:22:01+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",AnnaNicoletti,2,2023-10-13T17:04:38+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",valentinabertelli,"the output is 2
",2023-10-13T17:25:18+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",rufferbaraldi,2,2023-10-15T08:53:38+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",annapasetto0,"2, both words are in the bibliographic entry",2023-10-15T09:07:38+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",CarlaMenegat,"it's 2 because 
![Captura de Tela 2023-10-15 às 11 20 31](https://github.com/comp-think/2023-2024/assets/146187896/e05a52f9-083e-4dda-8315-20a8c8909945)
",2023-10-15T09:21:44+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",matildepassafaro,"Since both words are in the bibliographic entry, the output is 2.",2023-10-15T10:25:50+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",simocasaz,The output is 2,2023-10-15T14:40:28+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",Liber-R,2,2023-10-16T09:32:33+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",BeatriceBucci,"I think the output is 2 since both words are contained in the bibliographic entry!
",2023-10-16T09:59:27+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",Chiaramartina,2 because both are in the bibliographic entry,2023-10-16T10:31:00+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",alicepiazzi,"The result of the execution of the algorithm using the input values:

word 1= ""Peroni"";
word 2= ""HTML"" and
bibliographical entry = ""Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132""

We start from 0, then we sum 1 to the result because the word 1= ""Peroni"" is in the be and then we sum 1 to the previous result because the word 2 =""HTML"" is in the be too. The final result is 2",2023-10-16T14:18:20+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",MariaFrancesca6,The result is 2 since both words appear into the b.e.,2023-10-16T17:14:47+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",Sergpoipoip,2,2023-10-17T15:37:08+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",enricabruno,"The result is 2:
![Lecture__Algorithms-_ex1](https://github.com/comp-think/2023-2024/assets/83347862/244a9701-544b-41b8-9383-1e97eb2e3945)
",2023-10-17T15:58:14+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",VirginiaDa00,2,2023-10-17T17:37:22+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",Theengwar,"Based on Figure 4 and the fact that both words are included in the bibliographic entry, the result is 2. ",2023-10-23T21:59:36+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",Alice-Ant,"The output will be ""2"", because both values are present in the entry",2023-10-27T20:46:14+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",ahmdrznzr,"2, because both of them are in the bibliographic entry.",2023-10-28T20:42:08+00:00
comp-think/2023-2024,"Lecture ""Algorithms"", exercise 1",addonico,"2, because both words ""Peroni"" and ""HTML"" are in the bibliographic entry.",2023-12-09T17:43:48+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",vattelalberto,"### **_Eating an Ice Cream_** and **_playing Hide and Seek_**

- Both are things that kids love to do
- Both are things that I still do without regret even if I should be a mature adult
- Both are more enjoyable during summer
- Both are perfect endings for a night out with your friends
- Both will make you thirsty afterward
- Both can make you dirty if you are not cautious
- Both are way harder if performed simultaneously with the other one",2023-10-11T09:28:29+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",katyakrsn,"**Translation and programming**

- Both involve working with languages and their syntax
- Both require logical thinking and problem-solving skills
- Both demand accuracy and attention to detail 
- Both fields evolve over time, thus continuous learning and staying up-to-date with the latest trends is a must",2023-10-11T14:17:01+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",Chiaramartina,"Making a cake and developing a website 

- Both have a systematic approaches
- Both have various components (different ingredients like eggs, flour / code, design elements etc)
- Both tasks requires a series of steps (like baking a cake / testing a website etc)
- Both tasks have an end goal
",2023-10-11T14:31:11+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",enricabruno,"**A vintage tennis racket and a classic guitar**

Two wooden objects not too large, light and composed of a handle and a wider and rounded part with strings. They are usually both handled with the hand (right or left) and it seems cool to throw them on the ground as a sign of rebellion and/or provocation.",2023-10-11T14:35:39+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",MariaFrancesca6,"**Take a shower and get dressed**
- at the very beginning you should be naked
- you have to put on products/clothes one at a time
- each person has their own routine and decides which steps have to be taken and in what order 
- some steps could be omitted, some should be mandatory
- it can be quick or take hours 
- both are daily activities (at least I hope so...)
- some may like it some may not
- both can make people feel better ",2023-10-11T14:49:34+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",Pepe066,"**Salt and sugar**

- Both of them are white powders.
- Both are used in cooking and make things taste better.
- It's a big problem when you put one instead of the other in a particular recipe.
- It's weird if you consume them by themselves.
- Both of them used to be extremely valuable.",2023-10-11T15:13:41+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",teresam2,"Listening to music and tiding up
•	Both can be performed singularly or in groups of two or more people.
•	Both can take place indoor or outdoor.
•	Both can span over various lengths of time (listening to a song/ to an album; picking something up/ tiding up a room)
•	Both can take place simultaneously with other activities (tiding up while listening to music; listening to music while commuting)
",2023-10-11T15:56:53+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",CarlaMenegat,"execute a knitting pattern and produce a loaf of bread;

Both tasks require precise ingredient measurements;
Both tasks require a minimum mastery of motor commands;
Both tasks require certain movements to be performed in a certain order;
Likewise, both require that the raw material be used in a precise certain way;
Both tasks require a waiting period somewhere in the process;
Both things can be purchased industrially, but there are people who insist on making them manually, even though the result is less controlled. ",2023-10-11T16:42:59+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",ThIheb,"### **_Watching a movie and reading a fictional book_**

- During both you're following a story (plot)
- Both movies and books have effects on their consumers (dramatic or comedic impact)
- Both are enjoyable during leisurely time
- Both can have multiple parts (trilogies or series)
- Both are creative products
- Both make the consumer think about a certain topic or idea",2023-10-11T18:23:06+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",qwindici,"DNA and sheet music 

- they are instructions to make something separate from themselves 
- vastly different outcomes can be obtained from a small number of basic elements to combine (notes, bases) 
- if a mistake is made following the instructions something new can emerge 
- they need an external apparatus to be interpreted and executed 
- they store information 
- they can be used countless times to reproduce the same thing ",2023-10-12T09:54:59+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",Asemica-me,"- Making a hair dye
- Cooking a dish

Common features:

There is a recipe to be followed, with calculated and measured ingredients and methodical procedures, in order to achieve a specific result possibly the most closer to one's own expectations. Heat can be used. Human senses are involved, namely sight, smell, touch, taste.",2023-10-12T13:43:59+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",alicepiazzi,"Two gray forks and two gray pencils:
- both are gray,
- both are couple,
- both are solid and can be touched
- both are tools that two people can use,
- both are necessary to complete actions: two people can use two forks in order to eat and two people can use two pencils in order to write ",2023-10-12T16:31:13+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",Sergpoipoip,"Put together lego construction sets and assemble IKEA furniture
1. both situations require the ability to follow the instructions
2. in both cases separate components are connected into one object
3. both activities usually are captivating",2023-10-12T16:55:05+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",valetedd,"A mechanical sewing machine and an umbrella: 
- both have metal components;
- they both are designed to make our life easier;
- their respective functions are executed through a mechanism;
- both require a human operator to function;
- if used incorrectly, they could harm you",2023-10-12T17:13:44+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",FranciscoWu,"A mobile phone and a laptop:

1. Both are designed to be easily transported and used in different locations
2. Both can be used without being plugged into an outlet
3. Both have an operating system, processors, and memory to run apps/programs
4. Both have the ability to connect to the internet, cell service, Wi-Fi, Bluetooth
5. Both have visual interfaces for viewing and interacting with content
6. Both can be used for phone calls, texting, email, video chat",2023-10-12T17:55:53+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",Liber-R,"The growth of a slime mold and the devoloping process of a transport system: both aim to reach crucial areas in the space within the most efficient way. In the first case to reach nutritive substances, in the second to meet the needs of a human settlement. Given the mutable nature of both the goals, both the processes mutate their own structure over time.",2023-10-12T18:21:20+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",elena2notti,"Breathing and sea waves:

- Both have a rhythmic pattern
- Both involve expansion and contraction
- Both result in the rising and falling of either the chest or the water's surface
- Both can be influenced by external factors like the environment and stress
- Both adapt to changes and interact with their surroundings
- Both strive for balance and stability
- Both are part of larger natural cycles
- Both can have a soothing and calming effect 
",2023-10-12T19:11:00+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",matildepassafaro,"An ashtray and a diaper: 

- They both contain waste; 
- They're both used by humans in certain moments/stages of their lives; 
- They can both be unpleasant to the touch and smell; 
- The failure to use these objects can lead to dirt and unhygienic conditions",2023-10-12T21:41:28+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",saramadonia,"asking your granny for a recipe and visiting the doctor

- both involve asking for help/aid
- both actions involve interpersonal interaction 
- in both cases  someone mediates between your need and your goal 
- both  will result in receiving a set of instructions
- in both cases you rely on someone else expertise",2023-10-13T07:51:18+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",simocasaz,"Playing _The Secret of Monkey Island _  (old adventure game with very difficult riddles) on your PC and trying to solve a math problem:

- Both require to pay attention to words descriptions
- Both imply a trial and error process to find a solution
- Both require using abstract objects and tools 
- Both will result in an output (the game telling you if you solved the riddle, the math exercises book ""telling"" you if the answer is correct
- In both cases you can ask for help",2023-10-13T09:35:31+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",FrancescaGaeta,"Watching a movie and attending a course.
- in both you have to pay attention, but it might happen that you get lost in your thoughts.
- you decide to do both of the activity because you have an interest in those subjects (or maybe not, you can also be forced to do them actually)
- in both you have to analyze the events/rules, to apply them in your real life
- you have to sit and be focused, without further distractions
- you may still be thinking about the lesson/movie afterwords, if they have a big impact on you.",2023-10-13T10:03:21+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",rufferbaraldi,"Eating and charging smartphone:

Both are necessary for the well working of its body;
Both activities depend on an energy source;
Both activities involve energy transfer;
Both require time;
Both should be done daily (or almost)",2023-10-15T08:52:41+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",giulia282,"Brushing teeth and driving

- in both you use hands;
- for both activities you have to use a device;
- there is a specific sequence of actions to follow;
- in both spaces where the activity takes place there are mirrors;
- in both activities the devices are perishable;
- these activities help you to get closer to others;
- both require a minimum investment of time.",2023-10-16T07:16:20+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",VirginiaDa00,"a walk and a painting
•	Both let people think
•	Both are made through human limbs
•	In both people can observe and get in touch with new things
•	Both relax
•	Both are colorful
",2023-10-17T16:38:58+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",Kaosaier,"Van Gogh and Gauguin
Both artists were influenced by the Impressionist movement
Both artists spent significant periods of their artistic careers in France
Both artists were known for their bold and innovative use of color
Both artists explored symbolism and expression in their work
",2023-10-19T18:57:50+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",Theengwar,"watching a movie and reading a storybook:
The audience can follow the characters' internal or external adventures in both activities. 
The audience of both has vivid images in their mind by the end of the story.
The plot and character development in both of these can affect the everyday life of the audience and their viewpoint towards life.
",2023-10-20T19:31:28+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 3",Alice-Ant,"**Writing a thesis and creating a painting**

- require a theme
- one must do a research on the chosen subject
- one must follow specific steps to achieve the desired result
- it is possible to make changes but one will have to be careful with those as not to create contradictions
- one can get some amount of help to achieve better results
- reviewing and rest will improve one's comprehension and will give respective
- there will be meaning in the final work for those, who conducted it",2023-10-27T13:46:41+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",elena2notti,13,2023-10-11T08:59:56+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",vattelalberto,13,2023-10-11T09:16:44+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",katyakrsn,13,2023-10-11T10:34:16+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",qwindici,13,2023-10-11T11:06:44+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",saramadonia,"13  
",2023-10-11T11:12:57+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",MariaFrancesca6,13,2023-10-11T13:46:48+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",enricabruno,13,2023-10-11T14:05:38+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",Chiaramartina,13,2023-10-11T14:15:38+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",teresam2,13,2023-10-11T15:53:02+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",CarlaMenegat,13,2023-10-11T17:31:51+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",ThIheb,13,2023-10-11T18:13:41+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",Asemica-me,"_""The function for calculating the nth Fibonacci number takes as input an integer “n”. If “n” is less than or equal to 0, then 0 is returned as a result. Otherwise, if “n” is equal to 1, then 1 is returned. Otherwise, return the sum of the same function with “n-1” as input and still the same function with “n-2” as input.""_

The following function is implemented by using the concept of recursion, which is also stated by the formula:
**_Fn = Fn-1 + Fn-2_**


n = 7 > 0
F0 ≤ 0
F1 = 1
Fn = Fn-1 + Fn-2 ------> because n > 0
? = F7

F7 = F6 + F5 =
= F5 + F4 + F4 + F3 =
= F4 + F3 + F3 + F2 + F3 + F2 + F2 + F1 =
= F3 + F2 + F2 + F1 + F2 + F1 + F1 + F0 + F2 + F1 + F1 + F0 + F1 + F0 + 1 =
= F2 + F1 + F1 + F0 + F1 + F0 + 1 + F1 + F0 + 1 + 1 + 0 + F1 + F0 + 1 + 1 + 0 +1 + 0 + 1 =
= F1 + F0 + 1 + 1 + 0 + 1 + 0 + 1 + 1 + 0 + 1 + 1 + 0 + 1 + 0 + 1 + 1 + 0 +1 + 0 + 1 =
= 1 + 0 + 1 + 1 + 0 + 1 + 0 + 1 + 1 + 0 + 1 + 1 + 0 + 1 + 0 + 1 + 1 + 0 +1 + 0 + 1 =
= 13",2023-10-12T12:51:37+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",valetedd,"Fibonacci numbers : Fib = [...]
F(n) = function returning a number at position n in Fib

if n <=  0: 
    F(n) = 0

if n = 1:
    F(n) = 1

else:
    F(n) = F(n-1) + F(n+1)

n=7

F(7) = F(6) + F(5)
= F(5) + F(4) + F(4) + F(3)
= F(4) + F(3) + F(3) + F(3) + F(2) + F(2) + F(2) + F(1)               (omitting every resulting F(0) from now on; therefore, F(2) = 1)
= F(3) + F(2) +  F(2) + F(1) + F(2) + F(1) + F(2) + F(1) + 1 + 1 + 1 + 1    
= F(2) + F(1) +1+1+1+1+1+1+1+ 4
= 1 + 1 + 7 + 4
= 13
",2023-10-12T15:51:25+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",Sergpoipoip,13,2023-10-12T16:37:07+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",alicepiazzi,13,2023-10-12T16:50:51+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",FranciscoWu,13,2023-10-12T17:51:10+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",BeatriceBucci,13,2023-10-12T17:55:28+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",Liber-R,13,2023-10-12T18:05:24+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",matildepassafaro,13,2023-10-12T18:44:24+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",colakogluezgi00,13,2023-10-12T19:41:30+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",annapasetto0,"a --> 1
b --> 1
c --> a + b (2) 
if n <= 3 --> c

IF NOT 
a --> b  1		2	3	5	
b --> c   2	3	5	8
C -->     3	5	8	13
And decrease the value of “n” by 1 
N -->    6		5	4	3

=13
",2023-10-12T20:18:56+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",giulia282,"if n = 1 --> F(n) = 1
if n <= 0 --> F(n) = 0 

F(n) = F(n-1) + F(n-2)
F(7) = F(6) + F(5)

F(6) = 8
F(5) = 5
= .... 13
",2023-10-12T21:25:25+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",simocasaz,"""The function for calculating the nth Fibonacci number takes as input an integer “n”. If “n” is less than or equal to 0, then 0 is returned as a result. Otherwise, if “n” is equal to 1, then 1 is returned. _Otherwise, return the sum of the same function with “n-1” as input and still the same function with “n-2” as input_"".

I'm not sure if I've grasped the meaning of the sentence I put in Italic. In particular, I have doubts about ""the same function"". As far as I understood, it refers to the function described in the first natural language definition. Therefore, I proceeded in this way:

Given 7 as an imput
7 > 0
7 > 1
So the first two condition (n <= 0 v n = 1) are false

At this point, I calculated the result of the function expressed in the first natural language definition with 6 as an input (6 = 7 - 1)

(assign 1 to the two distinct variables a and b)
a = 1
b = 1
c = a + b
if n <= 3, the result is c
Otherwise, assign to a the value of b and to b the value of c
Subtract 1 to the integer input
Repeat this operations until a value is returned

Calculations with 6 as input:
n = 6
a = 1
b = 1
c = 1 + 1 = 2
n != 3
a = 1
b = 2
n = 6 -1 = 5

Repeat the operations:
n = 5
a = 1
b = 2
c = 2 + 1 = 3
n != 3
a = 2
b = 3
n = 5 - 1 = 4

Repeat the operations:
n = 4
a = 2
b = 3
c = 2 + 3 = 5
n != 3
a = 3
b = 5
n = 4 - 1 = 3

Repeat the operations:
n = 3
a = 3
b = 5
c = 5 + 3 = 8
n = 3, so the result is c
c = 8

The result is 8. Now let's use the same function with the starting imput n-2 = 7 -2 = 5

Calculations with 5 as input:
n = 5
a = 1
b = 1
c = 1 + 1 = 2
n != 3
a = 1
b = 2
n = 5 -1 = 4

Repeat the operations:
n = 4
a = 1
b = 2
c = 2 + 1 = 3
n != 3
a = 2
b = 3
n = 4 - 1 = 3

Repeat the operations:
n = 3
a = 2
b = 3
c = 2 + 3 = 5
n = 3, so the result is c
c = 5

Now I can add up the two results obtained by using the same function with the two different inputs (n - 1 and n - 2):
F7 = F(7 - 1) + F(6 - 1) = F6 + F5 = 8 + 5 = 13

The answer is 13.




 

",2023-10-13T09:09:50+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",essepuntato,"@annapasetto0 and @simocasaz, you applied the first natural language definition, not the second one. Indeed, in the second one, there is no mention of ""a"", ""b"", and ""c"". BTW, the result is correct anyway.",2023-10-13T09:20:28+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",alichpova,13,2023-10-13T10:15:33+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",rufferbaraldi,"If n <= 0 : F(n)= 0
If n = 1 : F(n)=1
If n > 1 : F(n-1) + F(n-2)

If n = 7: F6 + F5
            F5 + F4 + F4 + F3
            F4 + F3 + F3 + F2 + F3 + F2 + F2 + 1
            F3 + F2 + F2 + 1 + F2 + 1 + 1 + 0 + F2+ 1 + 1 + 0 + 1 + 0 + 1
            F2 + 1 + 1 + 0 +1 + 0 +1 +1 +0 + 1 + 1 + 0 + 1 + 0 + 1 + 1 +0 +1 + 0 + 1
            1 + 0 + 1 + 1 + 0 +1 + 0 +1 +1 +0 + 1 + 1 + 0 + 1 + 0 + 1 + 1 +0 +1 + 0 + 1 
            = 13",2023-10-15T08:40:28+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",Kaosaier,13,2023-10-19T18:52:16+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",Theengwar,"_The function for calculating the nth Fibonacci number takes as input
an integer “n”. If “n” is less than or equal to 0, then 0 is returned
as a result. Otherwise, if “n” is equal to 1, then 1 is returned.
Otherwise, return the sum of the same function with “n-1” as input
and still the same function with “n-2” as input._       
n=7   7>0    F7=F6+F5= ... ( We continue the same process with all the rest until we reach F1 and F0 where we can sum up the final numbers  1 + 0 + 1 + 1 + 0 +1 + 0 +1 +1 +0 + 1 + 1 + 0 + 1 + 0 + 1 + 1 +0 +1 + 0 + 1 = 13",2023-10-20T15:42:46+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 2",Alice-Ant,"_The following function is implemented by using the concept of recursion, which is also stated by the formula:
Fn = Fn-1 + Fn-2_

_n = 7 > 0
F0 ≤ 0
F1 = 1
Fn = Fn-1 + Fn-2 ------> because n > 0
? = F7_

**If n = 7, 7>0 => return the sum of the same function with ""n-1"" as input**

F7 = F6 + F5

F6 = (F5 + F4) + F5 = (F4 + F3) 

F5 = (F4 + F3) + F4 = (F3 + F2) + F4 = (F3 + F2) + F3 = (F2 + F1)

F4 = (F3 + F2) + F3 = (F2 + F1) + F3 = (F2 + F1) + F2 = (F1 + F0) +  F3 = (F2 + F1) + F2 = (F1 + F0) + F2 = (F1 + F0 + 1)

(F2 + F1) + (F1 + F0) + (F1 + F0 + 1) + (F1 + F0 + 1) + (1 + 0) + (F1 + F0) + (1 + 1 + 0 +1 + 0 + 1)

F1 + F0 + 1 + 1 + 0 + 1 + 0 + 1 + 1 + 0 + 1 + 1 + 0 + 1 + 0 + 1 + 1 + 0 +1 + 0 + 1

1 + 0 + 1 + 1 + 0 + 1 + 0 + 1 + 1 + 0 + 1 + 1 + 0 + 1 + 0 + 1 + 1 + 0 +1 + 0 + 1

13 =>

F7 = 13",2023-10-27T13:36:32+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",vattelalberto,"- I write
- I read
- You write
- You read",2023-10-11T08:10:12+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",Asemica-me,"I write
I read
You write
You read",2023-10-11T09:56:48+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",elena2notti,"	•	I write
	•	I read
	•	You write
	•	You read",2023-10-11T10:04:57+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",katyakrsn,"I write
I read
you write
you read",2023-10-11T10:28:22+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",saramadonia,"I write
You write
I read
You read",2023-10-11T10:29:33+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",MariaFrancesca6,"I write. 
You write.
I read.
You read. ",2023-10-11T12:41:30+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",enricabruno,"- I write
- You write
- I read
- You read",2023-10-11T13:52:19+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",Chiaramartina,"I write
I read
You write
You read",2023-10-11T14:15:14+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",teresam2,"- I write
- I read
- You write
- You read",2023-10-11T15:21:26+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",CarlaMenegat,"I write 
you write
I read
you read",2023-10-11T16:24:13+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",ThIheb,"- I write
- You write
- I read
- You read",2023-10-11T18:02:12+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",simocasaz,"I write
You write
I read
You read",2023-10-12T09:25:24+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",alicepiazzi,"I write
you write
I read
you read
",2023-10-12T12:28:54+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",Sergpoipoip,"I write, I read, you write, you read",2023-10-12T16:26:46+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",FranciscoWu,"I write
I read
you write
you read",2023-10-12T17:50:30+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",BeatriceBucci,I write; I read; You write; You read,2023-10-12T17:54:45+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",Liber-R,"1. I write
2. You write
3. I read
4. You read",2023-10-12T17:58:35+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",matildepassafaro,"I write 
I read 
You write 
You read",2023-10-12T18:42:02+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",colakogluezgi00,I write - You write - I read - You read,2023-10-12T19:37:55+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",giulia282,"- I write
- You write
- I read
- You read",2023-10-12T19:41:47+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",annapasetto0,"I write - I read
You write - You read 

",2023-10-12T19:47:23+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",FrancescaGaeta,"I write
I read
You write 
You read",2023-10-12T22:44:05+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",alichpova,"I write
I read
You write 
You read",2023-10-13T10:14:18+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",rufferbaraldi,"I write
I read
You write
You read",2023-10-15T08:20:50+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",VirginiaDa00,"I write 
I read
You write 
You read",2023-10-17T15:54:18+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",Kaosaier,"I write
I read
You write
You rea",2023-10-19T18:50:54+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",Theengwar,           [pronoun]  [verb]  :   I write    You write   I read     You read,2023-10-20T15:45:52+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",Alice-Ant,"I write
You Write
I read
You read",2023-10-27T13:05:38+00:00
comp-think/2023-2024,"Lecture ""Introduction to Computational Thinking"", exercise 1",alichpova,"I write 
I read
You write
You read",2023-11-08T18:20:26+00:00
