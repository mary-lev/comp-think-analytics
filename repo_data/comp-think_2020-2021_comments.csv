repo_name,issue_title,comment_user,comment_text,comment_datetime
comp-think/2020-2021,"Lecture ""Greedy algorithms"", exercise 2",diegochillo,"```
def select_activities(set_of_activities):
    activities=list(set_of_activities)
    activities.sort()
    activities=list(enumerate(activities))
    lastend=0
    for index, activity in activities:
        if activity[0]<activity[1]:
            if activity[0]<lastend:
                activities[index]=(index,""DEL"")
            else:
                lastend=activity[1]
        else:
            activities[index] = (index, ""DEL"")

    result=[activity for index, activity in activities if activity!='DEL']
    return result


def test_select_activities(set_of_activities, expected):
    result=select_activities(set_of_activities)
    return result==expected


# TEST CASES:

activities={(6, 8), (7, 9), (9, 13), (14, 18), (15, 17), (18, 20), (20, 24), (21, 23), (20, 23), (23,24)}
expected=[(6, 8), (9, 13), (14, 18), (18, 20), (20, 23), (23, 24)]
print (test_select_activities(activities, expected))

activities={(1, 4), (3, 5), (4, 6), (6, 9), (9, 12), (11, 13), (16, 18), (17, 19), (18, 22), (21,24)}
expected=[(1, 4), (4, 6), (6, 9), (9, 12), (16, 18), (18, 22)]
print (test_select_activities(activities, expected))

activities={(22, 24), (7, 9), (16, 20), (16, 22), (13, 17), (11, 14), (20, 22)}
expected=[(7, 9), (11, 14), (16, 20), (20, 22), (22, 24)]
print (test_select_activities(activities, expected))

activities={(24, 22), (7, 9), (16, 20), (16, 22), (13, 17), (11, 14), (20, 22)}
expected=[(7, 9), (11, 14), (16, 20), (20, 22)]
print (test_select_activities(activities, expected))
```
",2021-01-05T13:59:11+00:00
comp-think/2020-2021,"Lecture ""Greedy algorithms"", exercise 1",dbrembilla,"I am not really sure why, but while trying to run this function it considered change_value, which was 0, bigger than 0. Is there some problem (maybe with the type float) that might do that?
```
def coins_for_change(money_to_change):
    change_value = money_to_change
    dict_change = dict()
    while change_value - 0.01 >= 0:
        if change_value >= 2:
            if ""2â‚¬"" not in dict_change:
                dict_change[""2â‚¬""] = 1
                change_value -= 2
            else:
                dict_change[""2â‚¬""] += 1
                change_value -= 2
        elif change_value >= 1:
            if ""1â‚¬"" not in dict_change:
                dict_change[""1â‚¬""] = 1
                change_value -= 1
            else:
                dict_change[""1â‚¬""] += 1
                change_value -= 1
        elif change_value >= 0.5:
            if ""0,50â‚¬"" not in dict_change:
                dict_change[""0,50â‚¬""] = 1
                change_value -= 0.5
            else:
                dict_change[""0,50â‚¬""] += 1
                change_value -= 0.5
        elif change_value >= 0.2:
            if ""0,20â‚¬"" not in dict_change:
                dict_change[""0,20â‚¬""] = 1
                change_value -= 0.2
            else:
                dict_change[""0,20â‚¬""] += 1
                change_value -= 0.2
        elif change_value >= 0.1:
            if ""0,10â‚¬"" not in dict_change:
                dict_change[""0,10â‚¬""] = 1
                change_value -= 0.1
            else:
                dict_change[""0,10â‚¬""] += 1
                change_value -= 0.1
        elif change_value >= 0.05:
            if ""0,05â‚¬"" not in dict_change:
                dict_change[""0,05â‚¬""] = 1
                change_value -= 0.05
            else:
                dict_change[""0,05â‚¬""] += 1
                change_value -= 0.05
        elif change_value >= 0.02:
            if ""0,02â‚¬"" not in dict_change:
                dict_change[""0,02â‚¬""] = 1
                change_value -= 0.02
            else:
                dict_change[""0,02â‚¬""] += 1
                change_value -= 0.02
        else:
            if ""0,01â‚¬"" not in dict_change:
                dict_change[""0,01â‚¬""] = 1
                change_value -= 0.01
            else:
                dict_change[""0,01â‚¬""] += 1
                change_value -= 0.01
    result = set(dict_change.items())
    return result

def test(money_to_change, expected_set):
    result= coins_for_change(money_to_change).difference(expected_set)
    print(result)
    return result == set()
print(test(1.36, {('0,10â‚¬', 1), ('0,01â‚¬', 1), ('0,05â‚¬', 1), ('0,20â‚¬', 1), ('1â‚¬', 1)}))
print(test(2.63, {('2â‚¬', 1), ('0,50â‚¬', 1), ('0,10â‚¬', 1), ('0,02â‚¬', 1), (""0,01"", 1)}))
print(test(3.72, {('0,50â‚¬', 1), ('0,02â‚¬', 1), ('0,20â‚¬', 1), ('1â‚¬', 1), ('2â‚¬', 1)}))
```",2020-12-16T18:27:17+00:00
comp-think/2020-2021,"Lecture ""Greedy algorithms"", exercise 1",ChiaraCati,"```
def test_coin_change(coins_list, total, given, expected):
    t_result = coin_change(coins_list, total, given)
    if t_result== expected:
        return True
    else:
        return False


def coin_change(coins_list, total, payed):  
    coins_d = dict()
    change = payed - total
    secure = change + 0.001
    tot_amount = 0
    if total >= payed:
        return None

    for coin in coins_list:
        amount = int(secure // coin)
        if amount > 0 and change > 0.001:
            coins_d[coin] = int(amount)
            tot_amount += int(amount)
            change -= (int(amount) * coin)
            secure -= (int(amount) * coin)

    return tot_amount


eu_coins = [2.0, 1.0, 0.50, 0.20, 0.10, 0.05, 0.02, 0.01]

print(test_coin_change(eu_coins, 20, 12.95, None))
print(test_coin_change(eu_coins, 20, 20, None))
print(test_coin_change(eu_coins, 15.36, 20, 6))
print(test_coin_change(eu_coins, 15, 20, 3))
print(test_coin_change(eu_coins, 15.91, 20, 5))
print(test_coin_change(eu_coins, 15.9, 20, 3))
print(test_coin_change(eu_coins, 15.99, 20, 3))
print(test_coin_change(eu_coins, 15.95, 20, 3))
print(test_coin_change(eu_coins, 12.95, 20, 5))

```",2020-12-17T14:04:43+00:00
comp-think/2020-2021,"Lecture ""Greedy algorithms"", exercise 1",fcagnola,"I know the instructions were to only return the _amount_ of the change, but I thought it would be useful to see if the function actually worked in real-life situations. I opted for returning a tuple with the list of coins to give back as change and the value of the change in euros.
```
def test_2_parameter(function, p1, p2, expected):
    result = function(p1, p2)
    return result == expected


def greedy_coin_change(amount, paid):
    coin_types = [2, 1, 0.5, 0.2, 0.1, 0.02, 0.01]  # this list contains all coin types decrementally ordered
    coins = []     # this list will contain the result, with all coins used as change
    if paid == amount:
        return None
    else:
        for coin in coin_types:  # loops through coins
            if amount + coin <= paid:
                while amount + coin <= paid:  # continue adding change until the paid sum is reached
                    amount += coin
                    coins.append(coin)  # add each coin to the result list
    return coins, sum(coins)

print(test_2_parameter(greedy_coin_change, 13, 20, ([2,2,2,1], 7))) # returns True
print(test_2_parameter(greedy_coin_change, 16.73, 20, ([2, 1, 0.2, 0.02, 0.02, 0.02, 0.01], 3.27))) # returns True
print(test_2_parameter(greedy_coin_change, 20, 20, None)) # returns True

```",2020-12-17T15:27:48+00:00
comp-think/2020-2021,"Lecture ""Greedy algorithms"", exercise 1",AleRosae,"Since it is supposed to be a greedy algorithm I tried not only to return a collection of coins needed to reach a specific change, but also the ""best"" set of coins avoiding as much as possible small coins. This code apparently works, but for reasons I cannot understand sometimes it skips an if statement (I have checked that on python tutor), thus returning a different list from the one expected. Can someone explain to me why?


```
def test_greedy_coins(amount, price, expected):
    if greedy_coins(amount, price) == expected:
        return True
    else:
        return False


def greedy_coins(amount, price):

    change = abs(price - amount) #calculate the change value
    result = list() #create the list of coins to return
    while change != 0: #iterate until there is no charge left
        if (change - 2) >= 0:
            result.append(""2â‚¬"")
            change = change - 2
        else:
            if (change - 1) >= 0:
                    result.append(""1â‚¬"")
                    change = change - 1
            else:
                if (change - 0.50) >= 0:
                        result.append(""0,50â‚¬"")
                        change = change - 0.50
                else:
                    if (change - 0.20) >= 0:
                            result.append(""0,20â‚¬"")
                            change = change - 0.20
                    else:
                        if (change - 0.10) >= 0:
                                result.append(""0,10â‚¬"")
                                change = change - 0.10
                        else:
                            if (change - 0.05) >= 0:
                                    result.append(""0,05â‚¬"")
                                    change = change - 0.05
                            else:
                                if (change - 0.02) >= 0:
                                        result.append(""0,02â‚¬"")
                                        change = change - 0.02
                                else:
                                    if (change - 0.01) >= 0:
                                            result.append(""0,01â‚¬"")
                                            change = change - 0.01
                                    else:
                                        result.append(""0,01â‚¬"")
                                        change = 0


    return result


print(test_greedy_coins(20,16,[""2â‚¬"", ""2â‚¬""]))
print(test_greedy_coins(20,15.50,[""2â‚¬"", ""2â‚¬"", ""0,50â‚¬""]))
print(test_greedy_coins(20,13.64,[""2â‚¬"", ""2â‚¬"", ""2â‚¬"", ""1â‚¬"", ""0,20â‚¬"", ""0,10â‚¬"", ""0,05â‚¬"", ""0,01â‚¬""]))
print(test_greedy_coins(20,13.38,['2â‚¬', '2â‚¬', '2â‚¬', '1â‚¬', '0,50â‚¬', '0,10â‚¬', '0,02â‚¬'])) # returns false because the output is ['2â‚¬', '2â‚¬', '2â‚¬', '1â‚¬', '0,50â‚¬', '0,10â‚¬', '0,01â‚¬', '0,01â‚¬']


```",2020-12-19T16:42:20+00:00
comp-think/2020-2021,"Lecture ""Greedy algorithms"", exercise 1",yunglong28,"Not as precise as @essepuntato's solution for sure but I think this reflects at least the greedy algorithm logic:

```
   def test_money_change(amount_to_change, coins_list, expected):
    if money_change(amount_to_change, coins_list) == expected:
        return True
    else:
        return False

def money_change(amount_to_change, coins_list):
    change = []
    
    for coin in coins_list:
        still_to_add = amount_to_change
        maximal = max(coins_list)
        change.append(maximal)  #being greedy: always append the max value
        coins_list.remove(maximal)
        still_to_add -= sum(change)
        if still_to_add > 0:
            if still_to_add in coins_list:  #if I have the exact other value I go with that
                idx = coins_list.index(still_to_add)
                change.append(coins_list[idx])
                still_to_add -= coins_list[idx]
                if still_to_add == 0:
                    return change
        elif still_to_add < 0:
            change.clear()
            still_to_add = 0
        elif still_to_add == 0:
            return change
    return []



print(test_money_change(0.5, [2, 2, 0.5, 0.5, 0.2, 0.5, 1], [0.5]))  #True
print(test_money_change(5, [2, 2, 0.5, 0.5, 0.2, 0.5, 1], [2, 2, 1]))  #True
print(test_money_change(3, [2, 2, 0.5, 0.5, 0.2, 0.5, 1], [2, 1])) #True 
` ",2021-01-28T14:10:52+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 2",AleRosae,"```
import matplotlib.pyplot as plt
import networkx as nx

kino_graph = nx.MultiDiGraph()

kino_graph.add_node(""Ocean's Twelve"")
kino_graph.add_node(""Fight Club"")
kino_graph.add_node(""Dark Shadows"")

kino_graph.add_node(""Brad Pitt"")
kino_graph.add_node(""Eva Green"")
kino_graph.add_node(""George Clooney"")
kino_graph.add_node(""Catherine Zeta-Jones"")
kino_graph.add_node(""Johnny Depp"")
kino_graph.add_node(""Helena Bonham Carter"")

kino_graph.add_edge(""Ocean's Twelve"", ""George Clooney"")
kino_graph.add_edge(""Ocean's Twelve"", ""Brad Pitt"")
kino_graph.add_edge(""Ocean's Twelve"", ""Catherine Zeta-Jones"")
kino_graph.add_edge(""Fight Club"", ""Brad Pitt"")
kino_graph.add_edge(""Fight Club"", ""Helena Bonham Carter"")
kino_graph.add_edge(""Dark Shadows"", ""Johnny Depp"")
kino_graph.add_edge(""Dark Shadows"", ""Helena Bonham Carter"")
kino_graph.add_edge(""Dark Shadows"", ""Eva Green"")

color_map = []
for node in kino_graph:
    if node == ""Ocean's Twelve"" or node == ""Fight Club"" or node == ""Dark Shadows"":
        color_map.append('blue')
    else:
        color_map.append('green')


nx.draw_networkx(kino_graph, node_color=color_map, with_labels=True)
ax = plt.gca()
ax.margins(0.20)
plt.axis(""off"")
plt.show()
```
![Figure_1](https://user-images.githubusercontent.com/72870813/101671968-8a308980-3a55-11eb-815e-411a60b67e31.png)
",2020-12-09T18:34:43+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 2",edoardodalborgo,"```
from networkx import DiGraph

films_actors_graph = DiGraph()

films_actors_graph.add_node(""Brad Pitt"")
films_actors_graph.add_node(""Eva Green"")
films_actors_graph.add_node(""George Clooney"")
films_actors_graph.add_node(""Catherine Zeta-Jones"")
films_actors_graph.add_node(""Johnny Depp"")
films_actors_graph.add_node(""Helena Bonham Carter"")
films_actors_graph.add_node(""Ocean's Twelve"")
films_actors_graph.add_node(""Fight Club"")
films_actors_graph.add_node(""Dark Shadows"")

films_actors_graph.add_edge(""Ocean's Twelve"", ""Brad Pitt"")
films_actors_graph.add_edge(""Ocean's Twelve"", ""George Clooney"")
films_actors_graph.add_edge(""Ocean's Twelve"", ""Catherine Zeta-Jones"")
films_actors_graph.add_edge(""Fight Club"", ""Brad Pitt"")
films_actors_graph.add_edge(""Fight Club"", ""Helena Bonham Carter"")
films_actors_graph.add_edge(""Dark Shadows"", ""Johnny Depp"")
films_actors_graph.add_edge(""Dark Shadows"", ""Helena Bonham Carter"")
films_actors_graph.add_edge(""Dark Shadows"", ""Eva Green"")

print(films_actors_graph.edges())

```",2020-12-09T18:36:00+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 2",diegochillo,"```
from networkx import DiGraph

# Actors:
A_BP = ""Brad Pitt""
A_EG = ""Eva Green""
A_GC = ""George Clooney""
A_CZJ = ""Catherine Zeta-Jones""
A_JD = ""Johnny Depp""
A_HBC = ""Helena Bonham Carter""

# Movies:
M_OT = ""Ocean's Twelve""
M_FC = ""Fight Club""      # Sorry for breaking the first two rules
M_DS = ""Dark Shadows""

ActorsToMovies=DiGraph()

ActorsToMovies.add_edge(A_BP,M_OT)
ActorsToMovies.add_edge(A_BP,M_FC)
ActorsToMovies.add_edge(A_EG,M_DS)
ActorsToMovies.add_edge(A_GC,M_OT)
ActorsToMovies.add_edge(A_CZJ,M_OT)
ActorsToMovies.add_edge(A_JD,M_DS)
ActorsToMovies.add_edge(A_HBC,M_FC)
ActorsToMovies.add_edge(A_HBC,M_DS)

print(ActorsToMovies.nodes)
print(ActorsToMovies.edges)

```",2020-12-10T15:53:40+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 2",gabrielefiorenza,"```
from networkx import DiGraph

my_digraph = DiGraph()
my_digraph.add_node(""Brad Pitt"")
my_digraph.add_node(""Eva Green"")
my_digraph.add_node(""George Clooney"")
my_digraph.add_node(""Catherine Zeta-Jhones"")
my_digraph.add_node(""Johnny Depp"")
my_digraph.add_node(""Helena Bonham Carter"")
my_digraph.add_node(""Ocean's Twelve"")
my_digraph.add_node(""Fight Club"")
my_digraph.add_node(""Dark Shadows"")
my_digraph.add_edge(""Brad Pitt"", ""Fight Club"")
my_digraph.add_edge(""Helena Bonham Carter"", ""Fight Club"")
my_digraph.add_edge(""Brad Pitt"", ""Ocean's Twelve"")
my_digraph.add_edge(""George Clooney"", ""Ocean's Twelve"")
my_digraph.add_edge(""Catherine Zeta-Jhones"", ""Ocean's Twelve"")
my_digraph.add_edge(""Johnny Depp"", ""Dark Shadows"")
my_digraph.add_edge(""Eva Green"", ""Dark Shadows"")
```",2020-12-10T18:11:20+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 2",samuelespotti,"from networkx import DiGraph

actors_graph = DiGraph()

actors_graph.add_node(""Brad Pitt"")
actors_graph.add_node(""Eva Green"")
actors_graph.add_node(""George Clooney"")
actors_graph.add_node(""Catherine Zeta-Jones"")
actors_graph.add_node(""Johnny Depp"")
actors_graph.add_node(""Helena Bonham Carter"")
actors_graph.add_node(""Ocean's Twelve"")
actors_graph.add_node(""Fight Club"")
actors_graph.add_node(""Dark Shadows"")

actors_graph.add_edge(""Brad Pitt"", ""Ocean's Twelve"")
actors_graph.add_edge(""George Clooney"", ""Ocean's Twelve"")
actors_graph.add_edge(""Catherine Zeta-Jones"", ""Ocean's Twelve"")
actors_graph.add_edge(""Brad Pitt"", ""Fight Club"")
actors_graph.add_edge(""Helena Bonham Carter"", ""Fight Club"")
actors_graph.add_edge(""Johnny Depp"", ""Dark Shadows"")
actors_graph.add_edge(""Helena Bonham Carter"", ""Dark Shadows"")
actors_graph.add_edge(""Eva Green"", ""Dark Shadows"")

print(actors_graph.edges())
",2020-12-10T18:14:31+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 2",AlessandraFa,"```
from networkx import DiGraph


movies_actors = DiGraph()
movies_actors.add_node(""Fight Club"")
movies_actors.add_node(""Ocean's Twelve"")
movies_actors.add_node(""Dark Shadows"")
movies_actors.add_node(""Brad Pitt"")
movies_actors.add_node(""Eva Green"")
movies_actors.add_node(""George Clooney"")
movies_actors.add_node(""Catherine Zeta Jones"")
movies_actors.add_node(""Johnny Depp"")
movies_actors.add_node(""Helena Bonham Carter"")

movies_actors.add_edge(""Brad Pitt"", ""Fight Club"")
movies_actors.add_edge(""Helena Bonham Carter"", ""Fight Club"")
movies_actors.add_edge(""Brad Pitt"", ""Ocean's Twelve"")
movies_actors.add_edge(""George Clooney"", ""Ocean's Twelve"")
movies_actors.add_edge(""Catherine Zeta Jones"", ""Ocean's Twelve"")
movies_actors.add_edge(""Johnny Depp"", ""Dark Shadows"")
movies_actors.add_edge(""Helena Bonham Carter"", ""Dark Shadows"")
movies_actors.add_edge(""Eva Green"", ""Dark Shadows"")

```",2020-12-11T14:57:59+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 2",yunglong28,"```
from networkx import DiGraph
movies_graph = Graph()

#nodes
movies_graph.add_node(""Johnny Depp"")
movies_graph.add_node(""Brad Pitt"")
movies_graph.add_node(""Eva Green"")
movies_graph.add_node(""George Clooney"")
movies_graph.add_node(""Helena Bonham Carter"")
movies_graph.add_node(""Catherine Zeta-Jones"")
movies_graph.add_node(""Fight Club"")
movies_graph.add_node(""Dark Shadows"")
movies_graph.add_node(""Ocean's Twelve"")

#edges
movies_graph.add_edge(""Brad Pitt"", ""Ocean's Twelve"")
movies_graph.add_edge(""George Clooney"", ""Ocean's Twelve"")
movies_graph.add_edge(""Catherine Zeta-Jones"", ""Ocean's Twelve"")
movies_graph.add_edge(""Brad Pitt"", ""Fight Club"")
movies_graph.add_edge(""Helena Bonham Carter"", ""Fight Club"")
movies_graph.add_edge(""Johnny Depp"",""Dark Shadows"")
movies_graph.add_edge(""Eva Green"", ""Dark Shadows"")
movies_graph.add_edge(""Helena Bonham Carter"", ""Dark Shadows"")

```",2020-12-11T17:21:24+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 2",fcagnola,"```
from networkx import DiGraph

movies = DiGraph()

movies.add_node(""Helena Bonham Carter"")
movies.add_node(""Brad Pitt"")
movies.add_node(""Eva Green"")
movies.add_node(""George Clooney"")
movies.add_node(""Catherine Zeta-Jones"")
movies.add_node(""Johnny Depp"")

movies.add_node(""Ocean's Twelve"")
movies.add_node(""Fight Club"")
movies.add_node(""Dark Shadows"")

movies.add_edge(""Helena Bonham Carter"", ""Fight Club"")
movies.add_edge(""Brad Pitt"", ""Fight Club"")
movies.add_edge(""Johnny Depp"", ""Dark Shadows"")
movies.add_edge(""Eva Green"", ""Dark Shadows"")
movies.add_edge(""Helena Bonham Carter"", ""Dark Shadows"")
movies.add_edge(""George Clooney"", ""Ocean's Twelve"")
movies.add_edge(""Catherine Zeta-Jones"", ""Ocean's Twelve"")
movies.add_edge(""Brad Pitt"", ""Ocean's Twelve"")

print(movies.edges())
```",2020-12-12T14:53:17+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 2",giorgiasampo,"````
from networkx import MultiDiGraph

my_graph=MultiDiGraph()

my_graph.add_node('Brad Pitt')
my_graph.add_node('Eva Green')
my_graph.add_node('George Clooney')
my_graph.add_node('Catherine Zeta Jones')
my_graph.add_node('Johnny Depp')
my_graph.add_node('Helena Bonham Carter')

my_graph.add_node('Oceans Twelve')
my_graph.add_node('Fight Club')
my_graph.add_node('Dark Shadows')

my_graph.add_edge('Brad Pitt','Oceans Twelve')
my_graph.add_edge('Brad Pitt','Fight Club')
my_graph.add_edge('George Clooney','Oceans Twelve')
my_graph.add_edge('Johnny Depp','Dark Shadows')
my_graph.add_edge('Helena Bonham Carter','Fight Club')
my_graph.add_edge('Helena Bonham Carter','Dark Shadows')

print(my_graph.adj)

````",2020-12-13T11:15:23+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 2",vanessabonanno,"```
import networkx as ntx

actors_movies = ntx.DiGraph()

actors_movies.add_node(""Brad Pitt"")
actors_movies.add_node(""Eva Green"")
actors_movies.add_node(""George Clooney"")
actors_movies.add_node(""Catherine Zeta-Jones"")
actors_movies.add_node(""Johnny Depp"")
actors_movies.add_node(""Helena Bonham Carter"")

actors_movies.add_node(""Ocean's Twelve"")
actors_movies.add_node(""Fight Club"")
actors_movies.add_node(""Dark Shadows"")

actors_movies.add_edge(""Brad Pitt"", ""Ocean's Twelve"")
actors_movies.add_edge(""Brad Pitt"", ""Fight Club"")
actors_movies.add_edge(""Eva Green"", ""Dark Shadows"")
actors_movies.add_edge(""George Clooney"", ""Ocean's Twelve"")
actors_movies.add_edge(""Catherine Zeta-Jones"", ""Ocean's Twelve"")
actors_movies.add_edge(""Johnny Depp"", ""Dark Shadows"")
actors_movies.add_edge(""Helena Bonham Carter"", ""Fight Club"")
actors_movies.add_edge(""Helena Bonham Carter"", ""Dark Shadows"")
```",2020-12-13T13:17:45+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 2",laurentfintoni,"```
BP = ""Brad Pitt""
EG = ""Eva Green""
GC = ""George Clooney""
CZJ = ""Catherine Zeta-Jones""
JD = ""Johnny Depp""
HBC = ""Helena Bonham Carter""
OT = ""Ocean's Twelve""
FC = ""Fight Club""
DS = ""Dark Shadows""

film_graph = nx.MultiDiGraph()

film_graph.add_node(BP)
film_graph.add_node(EG)
film_graph.add_node(GC)
film_graph.add_node(CZJ)
film_graph.add_node(JD)
film_graph.add_node(HBC)
film_graph.add_edge(BP, OT)
film_graph.add_edge(CZJ, OT)
film_graph.add_edge(GC, OT)
film_graph.add_edge(BP, FC)
film_graph.add_edge(HBC, FC)
film_graph.add_edge(JD, DS)
film_graph.add_edge(HBC, DS)
film_graph.add_edge(EG, DS)

print(film_graph.edges())
nx.draw_circular(film_graph, with_labels=True)
plt.show()
#plt.savefig(""film_graph.png"")
```",2020-12-13T15:41:18+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 2",ChiaraCati,"```

from networkx import MultiDiGraph

actors_graph = MultiDiGraph()

actors_graph.add_node(""Brad Pitt"")
actors_graph.add_node(""Eva Green"")
actors_graph.add_node(""George Clooney"")
actors_graph.add_node(""Catherine Zeta-Jones"")
actors_graph.add_node(""Johnny Depp"")
actors_graph.add_node(""Helena Bonham Carter"")
actors_graph.add_node(""Ocean's Twelve"")
actors_graph.add_node(""Fight Club"")
actors_graph.add_node(""Dark Shadows"")

actors_graph.add_edge(""Brad Pitt"", ""Ocean's Twelve"")
actors_graph.add_edge(""Brad Pitt"",""Fight Club"")
actors_graph.add_edge(""Eva Green"", ""Dark Shadows"")
actors_graph.add_edge(""George Clooney"", ""Ocean's Twelve"")
actors_graph.add_edge(""Catherine Zeta-Jones"", ""Ocean's Twelve"")
actors_graph.add_edge(""Johnny Depp"", ""Dark Shadows"")
actors_graph.add_edge(""Helena Bonham Carter"", ""Fight Club"")
actors_graph.add_edge(""Helena Bonham Carter"", ""Dark Shadows"")
```",2020-12-13T20:39:18+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 2",SofiBar,"```
from networkx import DiGraph

act = DiGraph()
act.add_node(""Brad Pitt"", link=""https://www.imdb.com/name/nm0000093/"")
act.add_node(""Eva Green"", link=""https://www.imdb.com/name/nm1200692/"")
act.add_node(""George Clooney"", link=""https://www.imdb.com/name/nm0000123/"")
act.add_node(""Helena Bonham Carter"", link=""https://www.imdb.com/name/nm0000307/"")
act.add_node(""Catherine Zeta-Jones"", link=""https://www.imdb.com/name/nm0001876/"")
act.add_node(""Johnny Depp"", link=""https://www.imdb.com/name/nm0000136/"")

act.add_node(""Ocean's Twelve"", link=""https://www.imdb.com/title/tt0349903/"")
act.add_node(""Fight Club"", link=""https://www.imdb.com/title/tt0137523/"")
act.add_node(""Dark Shadows"", link=""https://www.imdb.com/title/tt1077368/"")


act.add_edge(""Brad Pitt"", ""Ocean's Twelve"", type=""acted in"")
act.add_edge(""Brad Pitt"", ""Fight Club"", type=""acted in"")
act.add_edge(""Eva Green"", ""Dark Shadows"", type=""acted in"")
act.add_edge(""George Clooney"", ""Ocean's Twelve"", type=""acted in"")
act.add_edge(""Catherine Zeta-Jones"", ""Ocean's Twelve"", type=""acted in"")
act.add_edge(""Johnny Depp"", ""Dark Shadows"", type=""acted in"")
act.add_edge(""Helena Bonham Carter"", ""Fight Club"", type=""acted in"")
act.add_edge(""Helena Bonham Carter"", ""Dark Shadows"", type=""acted in"")

```",2020-12-15T11:26:01+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 2",GiuliaMenna,"```
# actors: Brad Pitt, Eva Green, George Clooney, Catherine Zeta-Jones, Johnny Depp, and Helena Bonham Carter
# movies: Ocean's Twelve, Fight Club, Dark Shadows

from networkx import DiGraph

list_actors = DiGraph()
list_actors.add_node(""Brad Pitt"")
list_actors.add_node(""Eva Green"")
list_actors.add_node(""George Clooney"")
list_actors.add_node(""Catherine Zeta-Jones"")
list_actors.add_node(""Johnny Depp"")
list_actors.add_node(""Helena Bonham Carter"")

list_actors.add_edge(""Brad Pitt"",""Ocean's Twelve"")
list_actors.add_edge(""Brad Pitt"",""Fight Club"")
list_actors.add_edge(""Eva Green"",""Dark Shadows"")
list_actors.add_edge(""George Clooney"",""Ocean's Twelve"")
list_actors.add_edge(""Catherine Zeta-Jones"",""Ocean's Twelve"")
list_actors.add_edge(""Johnny Depp"",""Dark Shadows"")
list_actors.add_edge(""Helena Bonham Carter"",""Fight Club"")
list_actors.add_edge(""Helena Bonham Carter"", ""Dark shadows"")
```",2020-12-15T18:10:15+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 1",dbrembilla,"```
from networkx import Graph

Tim_Berners_Lee_Collaborations= Graph()
Tim_Berners_Lee_Collaborations.add_node(""Tim Berners Lee"")
Tim_Berners_Lee_Collaborations.add_node(""Tom Heath"")
Tim_Berners_Lee_Collaborations.add_node(""Christian Bizer"")
Tim_Berners_Lee_Collaborations.add_node(""SÃ¶ren Auer"")
Tim_Berners_Lee_Collaborations.add_node(""Lalana Kagal"")
Tim_Berners_Lee_Collaborations.add_node(""James A. Hendler"")

Tim_Berners_Lee_Collaborations.add_edge(""Tim Berners Lee"", ""Tom Heath"", weight = 18)
Tim_Berners_Lee_Collaborations.add_edge(""Tim Berners Lee"", ""Christian Bizer"", weight = 18)
Tim_Berners_Lee_Collaborations.add_edge(""Tim Berners Lee"", ""SÃ¶ren Auer"", weight = 10)
Tim_Berners_Lee_Collaborations.add_edge(""Tim Berners Lee"", ""Lalana Kagal"", weight = 9)
Tim_Berners_Lee_Collaborations.add_edge(""Tim Berners Lee"", ""James A. Hendler"", weight = 8)
```",2020-12-09T17:21:18+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 1",AleRosae,"I was looking at the networkx documentation in order to  also have some kind of visualization of the graphs. I discovered a very simple way, which requires an additional package and which uses a different way to import the networkx package, but I think that being able to visualize what is actually happening in the code may be useful.

```
import matplotlib.pyplot as plt
import networkx as nx

Tim_BS = nx.Graph()


Tim_BS.add_edge(""Tim Berners-Lee"", ""Tom Heath"", weight= 18)
Tim_BS.add_edge(""Tim Berners-Lee"", ""Christian Bizer"", weight= 18)
Tim_BS.add_edge(""Tim Berners-Lee"", ""SÃ¶ren Auerr"", weight= 10)
Tim_BS.add_edge(""Tim Berners-Lee"", ""Lalana Kaga"", weight= 9)
Tim_BS.add_edge(""Tim Berners-Lee"", ""James A.Hendler"", weight= 8)


nx.draw_networkx(Tim_BS)
ax = plt.gca()
ax.margins(0.20)
plt.axis(""off"")
plt.show()
```
This is the final result with the most basic settings, but there are thousands of options to customize its appereance.
![graph Tim BS](https://user-images.githubusercontent.com/72870813/101667121-3cb11e00-3a4f-11eb-9717-305f8721419b.png)",2020-12-09T17:55:48+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 1",edoardodalborgo,"```
from networkx import Graph

TBL_graph = Graph()

TBL_graph.add_node(""Tim Berners-Lee"")
TBL_graph.add_node(""Tom Heath"")
TBL_graph.add_node(""Christian Bizer"")
TBL_graph.add_node(""SÃ¶ren Auer"")
TBL_graph.add_node(""Lalana Kagal"")
TBL_graph.add_node(""James A. Hendler"")

TBL_graph.add_edge(""Tim Berners-Lee"", ""Tom Heath"", weight=18)
TBL_graph.add_edge(""Tim Berners-Lee"", ""Christian Bizer"", weight=18)
TBL_graph.add_edge(""Tim Berners-Lee"", ""SÃ¶ren Auer"", weight=10)
TBL_graph.add_edge(""Tim Berners-Lee"", ""Lalana Kagal"", weight=9)
TBL_graph.add_edge(""Tim Berners-Lee"", ""James A. Hendler"", weight=8)

print(TBL_graph.edges(data=True))

```",2020-12-09T18:18:21+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 1",diegochillo,"```
from networkx import Graph

TBL=""Tim Berners-Lee""

TBL_coauthors=Graph()

TBL_coauthors.add_node(TBL)
TBL_coauthors.add_edge(TBL,""Tom Heath"", weight=18)
TBL_coauthors.add_edge(TBL,""Christian Bizer"", weight=18)
TBL_coauthors.add_edge(TBL,""SÃ¶ren Auer"", weight=10)
TBL_coauthors.add_edge(TBL,""Lalana Kagal"", weight=9)
TBL_coauthors.add_edge(TBL,""James A. Hendler"", weight=8)

print(TBL_coauthors.edges(data=True))
```",2020-12-10T15:13:18+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 1",gabrielefiorenza,"```
from networkx import Graph


mygraph= Graph()
mygraph.add_node(""Tim Berners Lee"")
mygraph.add_node(""Tom Heath"")
mygraph.add_node(""Christian Bizer"")
mygraph.add_node(""Soren Auer"")
mygraph.add_node(""Lalana Kagal"")
mygraph.add_node(""James A.Hendler"")
mygraph.add_edge(""Tim Berners Lee"", ""Tom Heath"",weight=18)
mygraph.add_edge(""Tim Berners Lee"",""Christian Bizer"" ,weight=18)
mygraph.add_edge(""Tim Berners Lee"", ""Soren Auer"",weight=10)
mygraph.add_edge(""Tim Berners Lee"", ""Lalana Kagal"",weight=9)
mygraph.add_edge(""Tim Berners Lee"", ""James A.Hendler"",weight=8)
```",2020-12-10T18:09:56+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 1",samuelespotti,"from networkx import MultiGraph
from networkx import Graph

my_graph = Graph()

my_graph.add_node(""Tim Berners-Lee"")
my_graph.add_node(""Tom Heath"")
my_graph.add_node(""Christian Bizer"")
my_graph.add_node(""SÃ¶ren Auer"")
my_graph.add_node(""Lalana Kagal"")
my_graph.add_node(""James Hendler"")

my_graph.add_edge(""Tim Berners-Lee"", ""Tom Heath"", weight=18)
my_graph.add_edge(""Tim Berners-Lee"", ""Christian Bizer"", weight=18)
my_graph.add_edge(""Tim Berners-Lee"", ""SÃ¶ren Auer"", weight=10)
my_graph.add_edge(""Tim Berners-Lee"", ""Lalana Kagal"", weight=9)
my_graph.add_edge(""Tim Berners-Lee"", ""James A. Hendler"", weight=8)



",2020-12-10T18:16:05+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 1",AlessandraFa,"```
from networkx import Graph

tbl_graph = Graph()
tbl_graph.add_node(""Tim Berners Lee"")
tbl_graph.add_node(""Tom Heath"")
tbl_graph.add_node(""Christian Bizer"")
tbl_graph.add_node(""SÃ¶ren Auer"")
tbl_graph.add_node(""Lalana Kagal"")
tbl_graph.add_node(""James A. Hendler"")

tbl_graph.add_edge(""Tim Berners Lee"", ""Tom Heath"", weight=18)
tbl_graph.add_edge(""Tim Berners Lee"", ""Christian Bizer"", weight=18)
tbl_graph.add_edge(""Tim Berners Lee"", ""SÃ¶ren Auer"", weight=10)
tbl_graph.add_edge(""Tim Berners Lee"", ""Lalana Kagal"", weight=9)
tbl_graph.add_edge(""Tim Berners Lee"", ""James A. Hendler"", weight=8)

```",2020-12-11T14:49:01+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 1",yunglong28,"```
import networkx as nx
from networkx import Graph
import matplotlib.pyplot as plt
mygraph = Graph()
# central node
mygraph.add_node(""Tim Berners Lee"")
#other nodes
mygraph.add_node(""Tom Heath"")   #18
mygraph.add_node(""Christian Bizer"")  #18
mygraph.add_node(""SÃ¶ren Auer"")  #10
mygraph.add_node(""Lalana Kagal"")  #9
mygraph.add_node(""James A. Hendler"")  #8
#relations
mygraph.add_edge(""Tim Berners Lee"", ""Tom Heath"", weight = 18)
mygraph.add_edge(""Tim Berners Lee"", ""Christian Bizer"", weight = 18)
mygraph.add_edge(""Tim Berners Lee"", ""SÃ¶ren Auer"", weight = 10)
mygraph.add_edge(""Tim Berners Lee"", ""Lalana Kagal"", weight = 9)
mygraph.add_edge(""Tim Berners Lee"", ""James A. Hendler"", weight = 8)

#visualize
nx.draw_networkx(mygraph)
ax = plt.gca()
ax.margins(0.20)
plt.axis(""off"")
plt.show()

```

tnx to @AleRosae for the visualizing method!",2020-12-11T15:41:24+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 1",fcagnola,"I spent some time perfecting my list scraping just to find out that we were supposed to only add the first 5 co-authors... I'll paste all the code I used to clean the list and create the whole graph anyway ðŸ¤¦ðŸ»â€â™‚ï¸
```
co_authors = '''
Tom Heath (18)
Christian Bizer (18)
SÃ¶ren Auer (10)
Lalana Kagal (9)
James A. Hendler (8)
Daniel J. Weitzner (8)
Nigel Shadbolt (7)
Sarven Capadisli (6)
Roy T. Fielding (6)
Dan Connolly (6)
Wendy Hall (6)
Michael Hausenblas (5)
Henrik Frystyk Nielsen (5)
Kingsley Idehen (4)
Krzysztof Janowicz (4)
Larry Masinter (4)
Robert Cailliau (4)
M. C. schraefel (4)
Ruben Verborgh (3)
Kieron O'Hara (3)
Jean-FranÃ§ois Groff (3)
Jens Lehmann 0001 (3)
Gerald J. Sussman (3)
Andrei Vlad Sambra (3)
Yosi Scharf (3)
Ashraf Aboulnaga (2)
Jeffrey C. Mogul (2)
Aidan Hogan (2)
Eric Prud'hommeaux (2)
Bernd Pollermann (2)
Chris Hanson (2)
James Gettys (2)
Sandro Hawke (2)
Harold Abelson (2)
Amy Guy (2)
Christoph Lange 0002 (2)
Nicholas Gibbins (2)
Peter Szolovits (1)
J. Hollenbach (1)
Raf Buyle (1)
Robert Jacobs (1)
Arthur Secret (1)
Claire Hart (1)
Ruben Taelman (1)
Ryen W. White (1)
Stefan Dietze (1)
Sunny Consolvo (1)
Tobias Kuhn (1)
Tope Omitola (1)
John Domingue (1)
V. Richard Benjamins (1)
Yang Yang (1)
Ben Shneiderman (1)
Desney S. Tan (1)
Kanghao Lu (1)
Anastasia Dimou (1)
Katrien Mostaert (1)
Erik Mannens (1)
Paul J. Leach (1)
Isaac S. Kohane (1)
Christos L. Koumenides (1)
J. Presbrey (1)
Essam Mansour (1)
Lena Mamykina (1)
Gary Marsden (1)
Luis-Daniel IbÃ¡ (1)
Maged Zereba (1)
Manuel Salvadores (1)
Maria-Esther Vidal (1)
Geroen Joris (1)
Maribel Acosta (1)
Mark Fischetti (1)
Mark P. McCahill (1)
Martin Szomszor (1)
Joan Feigenbaum (1)
Deborah L. McGuinness (1)
Hugh Glaser (1)
K. Krasnow Waterman (1)
Oshani Seneviratne (1)
Abdurrahman Ghanem (1)
Amrapali Zaveri (1)
Ari Luotonen (1)
Christopher A. Le Dantec (1)
Igor O. Popov (1)
Paul AndrÃ© (1)
'''
authors_list = co_authors.split(""\n"")
for i in authors_list:
    if i == '':
        authors_list.remove(i)
print(authors_list)


from networkx import Graph

g = Graph()
g.add_node(""Tim Berners-Lee"")
for i in authors_list:
    if i[-3] == ""("":
        g.add_node(i[:-4])
        g.add_edge(""Tim Berners-Lee"", i[:-4], weight=i[-2])
    elif i[-4] == ""("":
        g.add_node(i[:-5])
        g.add_edge(""Tim Berners-Lee"", i[:-5], weight=i[-3:-1])
print(g.edges(data=True))
print(g.nodes(data=True))

```",2020-12-12T13:00:45+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 1",giorgiasampo,"````
from networkx import MultiGraph

my_graph=MultiGraph()

my_graph.add_node('Tim Berners Lee')
my_graph.add_node('Tom Heath')
my_graph.add_node('Christian Bizer')
my_graph.add_node('Soren Auer')
my_graph.add_node('Lalana Kagal')
my_graph.add_node('James A.Hendler')

my_graph.add_edge('Tim Berners Lee','Tom Heath', weight=18)
my_graph.add_edge('Tim Berners Lee','Christian Bizer', weight=18)
my_graph.add_edge('Tim Berners Lee','Soren Auer', weight=10)
my_graph.add_edge('Tim Berners Lee','Lalana Kagal', weight=9)
my_graph.add_edge('Tim Berners Lee','James A.Hendler', weight=8)

print(my_graph.adj['Tim Berners Lee'])

````",2020-12-13T11:07:54+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 1",vanessabonanno,"```
from networkx import Graph

my_node = Graph()

my_node.add_node(""Tim Berners Lee"")

my_node.add_node(""Tom Heath"")
my_node.add_node(""Christian Bizes"")
my_node.add_node(""SÃ¶ren Auer"")
my_node.add_node(""Lalana Kagal"")
my_node.add_node(""James A. Hendler"")

my_node.add_edge(""Tim Berners Lee"", ""Tom Heath"", weight=18)
my_node.add_edge(""Tim Berners Lee"", ""Christian Bizes"", weight=18)
my_node.add_edge(""Tim Berners Lee"", ""SÃ¶ren Auer"", weight=10)
my_node.add_edge(""Tim Berners Lee"", ""Lalana Kagal"", weight=9)
my_node.add_edge(""Tim Berners Lee"", ""James A. Hendler"", weight=8)


z = my_node.edges(data=True)
print(z)
# OUTPUT: [('Tim Berners Lee', 'Tom Heath', {'weight': 18}),
# ('Tim Berners Lee', 'Christian Bizes', {'weight': 18}),
# ('Tim Berners Lee', 'SÃ¶ren Auer', {'weight': 10}),
# ('Tim Berners Lee', 'Lalana Kagal', {'weight': 9}),
# ('Tim Berners Lee', 'James A. Hendler', {'weight': 8})]
```",2020-12-13T11:17:58+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 1",laurentfintoni,"using matplotlib to create a visualization (saved as a file in this case). 
One thing i can't seem to figure out tho is how to visualize the weights. I've spent some time looking around and playing with some of the nx.draw options but it seems to require pos values and I can't figure them out for the life of me. Best I managed was creating a linear plot which is not really what I want. 

```
import networkx as nx
import matplotlib.pyplot as plt

TBL_graph = nx.Graph()

TBL_graph.add_node(""Tim Berners-Lee"")
TBL_graph.add_node(""Tom Heath"")
TBL_graph.add_node(""Christian Bizer"")
TBL_graph.add_node(""SÃ¶ren Auer"")
TBL_graph.add_node(""Lalana Kagal"")
TBL_graph.add_node(""James A. Hendler"")

TBL_graph.add_edge(""Tim Berners-Lee"", ""Tom Heath"", weight=18)
TBL_graph.add_edge(""Tim Berners-Lee"", ""Christian Bizer"", weight=18)
TBL_graph.add_edge(""Tim Berners-Lee"", ""SÃ¶ren Auer"", weight=10)
TBL_graph.add_edge(""Tim Berners-Lee"", ""Lalana Kagal"", weight=9)
TBL_graph.add_edge(""Tim Berners-Lee"", ""James A. Hendler"", weight=8)

print(TBL_graph.adj[""Tim Berners-Lee""])
nx.draw(TBL_graph, with_labels=True)
plt.savefig(""TBL_graph.png"")
```",2020-12-13T14:47:39+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 1",ChiaraCati,"```

from networkx import Graph

Tim_bib = Graph()

Tim_bib.add_node(""Tim Berners-Lee"")
Tim_bib.add_node(""Tom Heath"")
Tim_bib.add_node(""Christian Bizer"")
Tim_bib.add_node(""SÃ¶ren Auer"")
Tim_bib.add_node(""Lalana Kagal"")
Tim_bib.add_node(""James A. Hendler"")

Tim_bib.add_edge(""Tim Berners-Lee"", ""Tom Heath"", weight=18)
Tim_bib.add_edge(""Tim Berners-Lee"", ""Christian Bizer"", weight=18)
Tim_bib.add_edge(""Tim Berners-Lee"", ""SÃ¶ren Auer"", weight=10)
Tim_bib.add_edge(""Tim Berners-Lee"", ""Lalana Kagal"", weight=9)
Tim_bib.add_edge(""Tim Berners-Lee"", ""James A. Hendler"", weight=8)

```",2020-12-13T20:16:31+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 1",SofiBar,"Is it possible to print both nodes and edges attributes in the same result? 
```
from networkx import Graph

tim_graph = Graph()
tim_graph.add_node(1, name=""Tim"", surname=""Berners Lee"")
tim_graph.add_node(2, name=""Tom"", surname=""Heath"")
tim_graph.add_node(3, name=""Christian"", surname=""Bizer"")
tim_graph.add_node(4, name=""SÃ¶ren"", surname=""Auer"")
tim_graph.add_node(5, name=""Lalana"", surname=""Kagal"")
tim_graph.add_node(6, name=""James A."", surname=""Hendler"")
tim_graph.add_edge(1, 2, weight=18)
tim_graph.add_edge(1, 3, weight=18)
tim_graph.add_edge(1, 4, weight=10)
tim_graph.add_edge(1, 5, weight=9)
tim_graph.add_edge(1, 6, weight=8)

print(tim_graph.nodes(data=True))
print(tim_graph.adj[1])
```",2020-12-15T10:39:04+00:00
comp-think/2020-2021,"Lecture ""Organising information: graphs"", exercise 1",GiuliaMenna,"
```
#Tom Heath (18)
#Christian Bizer (18)
#SÃ¶ren Auer (10)
#Lalana Kagal (9)
#James A. Hendler (8)


from networkx import Graph

list_TBL = Graph()
list_TBL.add_node(""Tim Berners Lee"")
list_TBL.add_node(""Tom Heath"")
list_TBL.add_node(""Christian Bizer"")
list_TBL.add_node(""SÃ¶ren Auer"")
list_TBL.add_node(""Lalana Kagal"")
list_TBL.add_node(""James A. Hendler"")

list_TBL.add_edge(""Tim Berners Lee"",""Tom Heath"", weight = 18)
list_TBL.add_edge(""Tim Berners Lee"",""Christian Bizer"", weight = 18)
list_TBL.add_edge(""Tim Berners Lee"",""SÃ¶ren Auer"", weight = 10)
list_TBL.add_edge(""Tim Berners Lee"",""Lalana Kagal"", weight = 9)
list_TBL.add_edge(""Tim Berners Lee"",""James A. Hendler"", weight = 8)




```",2020-12-15T15:44:18+00:00
comp-think/2020-2021,"Lecture ""Backtracking algorithms"", exercise 2",dbrembilla,"This function won't find the fastest route but it returns the first it finds.
```
from anytree import Node
from collections import deque

#test
def test(paths, entrance, exit, last_move, expected):
    result = solve_labyrinth(paths, entrance, exit, last_move)
    return result.name[""back""] == expected


bad_moves = set()

def solve_labyrinth(paths, entrance, exit, last_move):
    result = None
    if last_move not in bad_moves:
        if entrance == exit:
            result = last_move
        else:
            last_move.children = possible_paths(entrance, paths)
            if len(last_move.children) == 0:
                if [last_move.siblings] != []:
                    bad_moves.add(last_move)
                    undo_move(last_move, paths)
            else:
                move_stack = deque(last_move.children)
                while result == None and len(move_stack) > 0:
                    current_move = move_stack.pop()
                    new_pos = make_move(current_move, paths)[0]
                    new_path = make_move(current_move, paths)[1]
                    result = solve_labyrinth(new_path, new_pos, exit, current_move)
                if result == None:
                    bad_moves.add(last_move)
                    undo_move(last_move, paths)
    else:
        undo_move(last_move, paths)
    return result

#create labyrinth
def create_labyrinth():
    begin = (2,3) #begin mayn not be in labyrinth, but end has to be!
    end = (5, 2)
    all_path = {(1, 0), (3, 0), (4, 0), (5, 0),
                    (0, 1), (1, 1), (2, 1), (3, 1), (5, 1),
                    (0, 2), (2, 2), (4, 2), (5, 2),
                    (0, 3), (2, 3), (3, 3), (5, 3),
                    (0, 4), (4, 4),
                    (0, 5), (1, 5), (2, 5), (3, 5), (4, 5)}
    return all_path, begin, end

def make_move(node, pth):
    move= node.name
    new_pos = move.get(""move"")
    old_pos = move.get(""back"")
    if old_pos in pth:
        pth.remove(old_pos)
    return new_pos, pth #returns tuple!!!!!!!!!

def undo_move(node, pth):
    move = node.name
    old_pos = move.get(""back"")
    pth.add(old_pos)

#check possible paths
def possible_paths(entr, pth):
    result = list()
    x = entr[0]
    y = entr[1]
    if (x+1, y) in pth:
        result.append(Node({""move"": (x+1, y), ""back"": (x,y)}))
    if (x-1, y) in pth:
        result.append(Node({""move"": (x-1, y), ""back"": (x,y)}))
    if (x, y+1) in pth:
        result.append(Node({""move"": (x, y+1), ""back"": (x,y)}))
    if (x, y-1) in pth:
        result.append(Node({""move"": (x, y-1), ""back"": (x,y)}))
    return result

path, entrance, exit = create_labyrinth()

print(test(path, entrance, exit, Node(""start""), (3,5))) # True
```
I tried putting `begin = (2,3)` and `end = (5,2)`:
`print(test(path, entrance, exit, Node(""start""), (5,1))) # True`
",2020-12-03T17:21:50+00:00
comp-think/2020-2021,"Lecture ""Backtracking algorithms"", exercise 2",gabrielefiorenza,"I  have replaced your ""last_move"" with ""previous_position"". At the end the algorithm returns the position occupied before finding the exit.
```
from anytree import Node
from collections import deque

paths = [
            (1, 0),         (3, 0), (4, 0), (5, 0),
    (0, 1), (1, 1), (2, 1), (3, 1),         (5, 1),
    (0, 2),         (2, 2),         (4, 2), (5, 2),
    (0, 3),         (2, 3), (3, 3),         (5, 3),
    (0, 4),                         (4, 4),
    (0, 5), (1, 5), (2, 5), (3, 5), (4, 5)
]


def test_solve_labyrinth(paths, entrance, exit, previous_position,expected):
    result = solve_labyrinth(paths,entrance,exit,previous_position)
    return result==expected

def solve_labyrinth(paths, entrance, exit, previous_position):
    result = None
    entrance.children = valid_moves(paths, entrance, previous_position)  # generate children
    possible_moves = deque(entrance.children)
    if len(entrance.children) > 0:
        if entrance.name != exit:  # keep moving
            while result == None and len(possible_moves) > 0:
                current_move = possible_moves.pop()
                result = solve_labyrinth(paths, current_move, exit, entrance)   # recursion
        else:                                                                             # win, provided that you are in the exit box
            result = previous_position.name
        return result
    elif len(entrance.children) <= 0 and entrance.name != exit:  # leaf-node lose
        return result                                         # backtracking
    elif len(entrance.children) <= 0 and entrance.name == exit:   # leaf-node win
        result = previous_position.name
        return result


def valid_moves(paths, current_position, previous_position):
    result = list()
    x = current_position.name[0]
    y = current_position.name[1]
    if (x + 1, y) in paths and (x + 1, y) != previous_position.name:
        result.append(Node((x + 1, y)))
    if (x - 1, y) in paths and (x - 1, y) != previous_position.name:
        result.append(Node((x - 1, y)))
    if (x, y + 1) in paths and (x, y + 1) != previous_position.name:
        result.append(Node((x, y + 1)))
    if (x, y - 1) in paths and (x, y - 1) != previous_position.name:
        result.append(Node((x, y - 1)))
    return result


none_node = Node(None)   # previous position of the start position
print(test_solve_labyrinth(paths, Node((2, 3)), (4, 4), none_node,(4,5))) # returns True
print(test_solve_labyrinth(paths, Node((0, 1)), (5, 3), none_node,(5,2))) # returns True
print(test_solve_labyrinth(paths, Node((2, 1)), (4, 2), none_node,(5,2))) # returns True
print(test_solve_labyrinth(paths, Node((2, 1)), (5, 5), none_node,None)) # returns True
```",2020-12-04T21:39:08+00:00
comp-think/2020-2021,"Lecture ""Backtracking algorithms"", exercise 2",diegochillo,"```
from anytree import Node
from collections import deque


# Test case for the algorithm
def test_solve_labirynth(paths,entrance,exit,last_move,expected):
    result = solve_labirynth(paths,entrance,exit,last_move)
    if (expected==result==None):
        return True
    elif result!=None:
        return (expected == result.name[""to""])
    else:
        return False


def create_labirynth():

    paths = set([
        (1, 0),(3, 0),(4, 0),(5, 0),
        (0, 1),(1, 1),(2, 1),(3, 1),(5, 1),
        (0, 2),(2, 2),(4, 2),(5, 2),
        (0, 3),(2, 3),(3, 3),(5, 3),
        (0, 4),(4, 4),
        (0, 5),(1, 5),(2, 5),(3, 5), (4, 5)
    ])

    return paths


def valid_moves(paths,cell):
    result = list()
    pos_x=cell[0]
    pos_y=cell[1]

    if (pos_x-1, pos_y) in paths:
        result.append(Node({""from"": (pos_x, pos_y), ""to"": (pos_x-1, pos_y)}))
    if (pos_x+1, pos_y) in paths:
        result.append(Node({""from"": (pos_x, pos_y), ""to"": (pos_x+1, pos_y)}))
    if (pos_x, pos_y-1) in paths:
        result.append(Node({""from"": (pos_x, pos_y), ""to"": (pos_x, pos_y-1)}))
    if (pos_x, pos_y+1) in paths:
        result.append(Node({""from"": (pos_x, pos_y), ""to"": (pos_x, pos_y+1)}))

    return result


def apply_move(node, paths):
    move = node.name
    prev_pos = move.get(""from"")

    paths.remove(prev_pos)


def undo_move(node, paths):
    move = node.name
    curr_pos = move.get(""to"")
    prev_pos = move.get(""from"")

    paths.remove(curr_pos)
    paths.add(prev_pos)


def solve_labirynth(paths,entrance,exit,last_move):
    result = None

    if (exit not in paths): return None

    if (entrance==exit):  # leaf-win base case
        result = last_move
    else:
        last_move.children = valid_moves(paths,entrance)

        if len(last_move.children) == 0:  # leaf-lose base case
            undo_move(last_move, paths)  # backtracking
        else:  # recursive step
            possible_moves = deque(last_move.children)

            while result is None and len(possible_moves) > 0:
                current_move = possible_moves.pop()
                apply_move(current_move, paths)
                result = solve_labirynth(paths, current_move.name.get(""to""),exit, current_move)

            if (result is None) and (last_move!=last_move.root):  # If the last_move is back to the root, it means the exit has not been found after trying all the paths
                undo_move(last_move, paths)  # backtracking

    return result


# TEST 1: solvable labirynth
paths=create_labirynth()
entrance=(5,3)
exit=(4,4)
print(test_solve_labirynth(paths,entrance,exit,Node('Start'),exit))


# TEST 2: same labirynth but exit out of paths
entrance=(5,3)
exit=(5,5)
print(test_solve_labirynth(paths,entrance,exit,Node('Start'),None))


# TEST 3: existent but unreachable exit
paths=set([
        (1, 0),(3, 0),(4, 0),(5, 0),
        (0, 1),(1, 1),(2, 1),(3, 1),(5, 1),
        (0, 2),(2, 2),(4, 2),(5, 2),
        (0, 3),(2, 3),(3, 3),(5, 3),
        (0, 4),(4, 4),
        (0, 5),(1, 5),(2, 5),(3, 5)
    ])
entrance=(5,3)
exit=(4,4)
print(test_solve_labirynth(paths,entrance,exit,Node('Start'),None))

```",2020-12-05T20:55:11+00:00
comp-think/2020-2021,"Lecture ""Backtracking algorithms"", exercise 2",AlessandroBertozzi,"```
from anytree import Node
from collections import deque
from time import sleep


# Test case for the algorithm
def test_solve_labyrinth(paths, entrance, exit, last_move, expected):
    result = solve_labyrinth(paths, entrance, exit, last_move)
    if expected == result:
        return True
    else:
        return False


def solve_labyrinth(paths, entrance, exit, last_move):
    result = None

    if last_move.name[""new_position""] == exit:  # leaf-win base case
        result = last_move.name[""old_position""]

    else:
        if entrance == last_move:  # only first case
            last_move.children = valid_moves(entrance, paths)
            move = last_move.name
            street.append(move[""new_position""])
            paths.remove(move[""new_position""])
        else:
            last_move.children = valid_moves(last_move, paths)

        possible_moves = deque(last_move.children)

        while result is None and len(possible_moves) > 0:
            current_position = possible_moves.pop()
            apply_move(current_position, paths)
            result = solve_labyrinth(paths, entrance, exit, current_position)

    return result


def create_board():
    entrance = Node({""new_position"": (int(input(""starting_x: "")), int(input(""starting_y: ""))) , ""old_position"": (None, None)})

    paths = {(1, 0), (3, 0), (4, 0), (5, 0), (0, 1), (1, 1), (2, 1), (3, 1), (5, 1),
             (0, 2), (2, 2), (4, 2), (5, 2), (0, 3), (2, 3), (3, 3), (5, 3), (0, 4), (4, 4),
             (0, 5), (1, 5), (2, 5), (3, 5), (4, 5)}

    exit = (int(input(""finishing_x: "")), int(input(""finishing_y: "")))
    return paths, entrance, exit


def valid_moves(last_move, paths):
    result = list()
    move = last_move.name
    x, y = move[""new_position""]
    if (x - 1, y) in paths:
        result.append(Node({""new_position"": (x - 1, y), ""old_position"": (x, y)}))
    if (x + 1, y) in paths:
        result.append(Node({""new_position"": (x + 1, y), ""old_position"": (x, y)}))
    if (x, y - 1) in paths:
        result.append(Node({""new_position"": (x, y - 1), ""old_position"": (x, y)}))
    if (x, y + 1) in paths:
        result.append(Node({""new_position"": (x, y + 1), ""old_position"": (x, y)}))
    return result


def apply_move(current_positon, paths):
    move = current_positon.name
    new_pos = move.get(""new_position"")

    paths.remove(new_pos)


# pegs, holes = create_6x6_square_board()
paths, entrance, exit = create_board()
print(test_solve_labyrinth(paths, entrance, exit, entrance, (5, 0)))
```",2020-12-08T09:48:19+00:00
comp-think/2020-2021,"Lecture ""Backtracking algorithms"", exercise 2",AlessandraFa,"```
from anytree import Node
from collections import deque


def test_solve_labyrinth(paths, entrance, exit, last_move, expected):
    return solve_labyrinth(paths, entrance, exit, last_move) == expected


def valid_moves(entrance, paths):
    result = []
    x = entrance[0]
    y = entrance[1]
    if (x,y) in paths:
        if (x + 1, y) in paths:
            result.append(Node({""move from"": (x, y), ""to"": (x + 1, y)}))
        if (x - 1, y) in paths:
            result.append(Node({""move from"": (x, y), ""to"": (x - 1, y)}))
        if (x, y + 1) in paths:
            result.append(Node({""move from"": (x, y), ""to"": (x, y + 1)}))
        if (x, y - 1) in paths:
            result.append(Node({""move from"": (x, y), ""to"": (x, y - 1)}))
    return result


def apply_move(node, paths):
    move = node.name
    old_pos = move.get(""move from"")
    entrance = move.get(""to"")
    if old_pos in paths:
        paths.remove(old_pos)
    return entrance, paths, old_pos


def undo_move(node, paths):
    move = node.name
    old_pos = move.get(""move from"")
    paths.add(old_pos)


def solve_labyrinth(paths, entrance, exit, last_move):
    result = None
    initial_paths = set()
    initial_paths.update(paths)
    if entrance not in paths:
        return ""No access to labyrinth""
    if exit not in paths:
        return result
    if entrance == exit:
        result = last_move.name
    else:
        last_move.children = valid_moves(entrance, paths)
        if len(last_move.children) == 0:
            undo_move(last_move, paths)
        else:
            possible_moves = deque(last_move.children)
            while result is None and len(possible_moves) > 0:
                cur_move = possible_moves.pop()
                new_entr = apply_move(cur_move, paths)[0]
                paths_updated = apply_move(cur_move, paths)[1]
                result = solve_labyrinth(paths_updated, new_entr, exit, cur_move)
            if result is None:
                undo_move(last_move, paths)
    paths.update(initial_paths)
    return result


cells = {(1,0), (3,0), (4,0), (5,0),
         (0,1), (1,1), (2,1), (3,1), (5,1),
         (0,2), (2,2), (4,2), (5,2),
         (0,3), (2,3), (3,3), (5,3),
         (0,4), (4,4),
         (0,5), (1,5), (2,5), (3,5), (4,5)}


print(test_solve_labyrinth(cells, (1,0), (3,3), Node(""Start""), {'move from': (2, 3), 'to': (3, 3)}))   # True
print(test_solve_labyrinth(cells, (4,4), (5,3), Node(""Start""), {'move from': (5, 2), 'to': (5, 3)}))   # True
print(test_solve_labyrinth(cells, (0,0), (4,4), Node(""Start""), ""No access to labyrinth""))   # True 
print(test_solve_labyrinth(cells, (2,1), (3,6), Node(""Start""), None))   # True

```",2020-12-08T17:43:17+00:00
comp-think/2020-2021,"Lecture ""Backtracking algorithms"", exercise 1 ",dbrembilla,"I created a bad moves dictionary in order to store the wrong cases, and the test runs True. However,  I'm not sure that it improved the algorithm's efficiency, is there a way I can measure that? Here I paste the new `solve `function? I used the given test function and it returns True
```
#badmoves_dict
bad_moves=set()

# Code of the algorithm
def solve(pegs, holes, last_move, d):
    result = None
    if last_move not in d:
        if len(pegs)== 1 and (5, 1) in pegs:  # leaf-win base case; there is one peg left and it is in the right place
            result = last_move
        else:
            last_move.children = valid_moves(pegs, holes) #create valid moves

            if len(last_move.children) == 0:  # leaf-lose base case; no more moves left and not in win case
                bad_moves.add(last_move)
                undo_move(last_move, pegs, holes)  # backtracking
            else:  # recursive step
                possible_moves = deque(last_move.children)

                while result is None and len(possible_moves) > 0:
                    current_move = possible_moves.pop()
                    apply_move(current_move, pegs, holes)
                    result = solve(pegs, holes, current_move, d)

                if result is None:
                    bad_move.add(last_move)
                    undo_move(last_move, pegs, holes)  # backtracking
    else:
        undo_move(last_move, pegs, holes)
    return result
```",2020-12-02T15:19:30+00:00
comp-think/2020-2021,"Lecture ""Backtracking algorithms"", exercise 1 ",fcagnola,"```
import time
from pprint import pprint
from anytree import Node
from collections import deque


# Test case for the algorithm
def test_solve(pegs, holes, last_move, expected):
    result = solve(pegs, holes, last_move)
    if expected == result.name[""in""] and len(pegs) == 1:
        return True
    else:
        return False


# Code of the algorithm
def solve(pegs, holes, last_move):
    result = None
    if last_move not in bad_moves:
        if len(pegs) == 1 and (5, 1) in pegs:  # leaf-win base case
            result = last_move

        else:
            last_move.children = valid_moves(pegs, holes)  # set valid moves given current state as children of last move

            if len(last_move.children) == 0:  # leaf-lose base case
                bad_moves.add(last_move)  # improving the process of computing results
                undo_move(last_move, pegs, holes)  # backtracking

            else:  # recursive step
                possible_moves = deque(last_move.children)

                for i in possible_moves:  # improving the process of computing results
                    if i in bad_moves:
                        possible_moves.remove(i)

                while result is None and len(possible_moves) > 0:
                    current_move = possible_moves.pop()
                    apply_move(current_move, pegs, holes)
                    result = solve(pegs, holes, current_move)

                if result is None:
                    bad_moves.add(last_move)  # improving the process of computing results
                    undo_move(last_move, pegs, holes)  # backtracking
    else:
        undo_move(last_move, pegs, holes)
    return result


pegs, holes = create_board()
bad_moves = set()
start_time = time.time()
print(test_solve(pegs, holes, Node(""start""), (5, 1)))
print(""--- %s seconds ---"" % (time.time() - start_time))
# time with set: 0.1843252182006836 seconds
# time without set: 0.18454599380493164 seconds
```",2020-12-02T18:28:50+00:00
comp-think/2020-2021,"Lecture ""Backtracking algorithms"", exercise 1 ",AlessandroBertozzi,"Gabriele Fiorenza, Samuele Spotti and I reached this solution together.
```
# Code of the algorithm
def solve(pegs, holes, last_move, error_list):
    result = None
    if len(pegs) == 1 and (5, 1) in pegs:  # leaf-win base case
        result = last_move
    else:
        if list(pegs) not in error_list:
            last_move.children = valid_moves(pegs, holes)

            if len(last_move.children) == 0:  # leaf-lose base case
                a = list(pegs)
                error_list.append(a)
                undo_move(last_move, pegs, holes)  # backtracking
            else:  # recursive step
                possible_moves = deque(last_move.children)

                while result is None and len(possible_moves) > 0:
                    current_move = possible_moves.pop()
                    apply_move(current_move, pegs, holes)
                    result = solve(pegs, holes, current_move, error_list)

                if result is None:
                    a = list(pegs)
                    error_list.append(a)
                    undo_move(last_move, pegs, holes)  # backtracking
        else:
            undo_move(last_move, pegs, holes)
    return result
```",2020-12-03T16:10:50+00:00
comp-think/2020-2021,"Lecture ""Backtracking algorithms"", exercise 1 ",ConstiDami,"```
wrong_moves = set()


def solve(pegs, holes, last_move):
    result = None

    if len(pegs) == 1 and (5, 1) in pegs:  # leaf-win base case
        result = last_move
    else:
        last_move.children = valid_moves(pegs, holes)

        if len(last_move.children) == 0:  # leaf-lose base case
            wrong_moves.add(last_move)
            undo_move(last_move, pegs, holes)  # backtracking
        else:  # recursive step
            possible_moves = deque(last_move.children)

            for child in last_move.children:
                if child in wrong_moves:
                    break
                else:
                    while result is None and len(possible_moves) > 0:
                        current_move = possible_moves.pop()
                        apply_move(current_move, pegs, holes)
                        result = solve(pegs, holes, current_move)
                    if result is None:
                        wrong_moves.add(last_move)
                        undo_move(last_move, pegs, holes)  # backtracking
    return result

```",2020-12-05T14:24:48+00:00
comp-think/2020-2021,"Lecture ""Backtracking algorithms"", exercise 1 ",diegochillo,"Without dynamic check, the recursion happens 7832 times.
With the preliminary dynamic check of the wrong moves, the recursion happens only 767 times.

```
from anytree import Node
from collections import deque


# Test case for the algorithm
def test_solve(pegs, holes, last_move, wrong_conf, expected):
    result = solve(pegs, holes, last_move, wrong_conf)
    if expected == result.name[""in""] and len(pegs) == 1:
        return True
    else:
        return False


# Code of the algorithm
def solve(pegs, holes, last_move, wrong_conf):
    global counter              # To store the number of times the function has been called

    result = None
    counter+=1
    # del wrong_conf[:]         # Uncomment to bypass the dynamic check again and see the difference in counter

    if pegs not in wrong_conf:

        if len(pegs) == 1 and (5, 1) in pegs:  # leaf-win base case
            result = last_move
        else:
            last_move.children = valid_moves(pegs, holes)

            if len(last_move.children) == 0:  # leaf-lose base case
                wrong_conf.append(set(pegs))
                undo_move(last_move, pegs, holes)  # backtracking
            else:  # recursive step
                possible_moves = deque(last_move.children)

                while result is None and len(possible_moves) > 0:
                    current_move = possible_moves.pop()
                    apply_move(current_move, pegs, holes)
                    result = solve(pegs, holes, current_move,wrong_conf)

                if result is None:
                    wrong_conf.append(set(pegs))
                    undo_move(last_move, pegs, holes)  # backtracking

    else:
        
        undo_move(last_move, pegs, holes)  # backtracking

    return result


# pegs, holes = create_6x6_square_board()
pegs, holes = create_board()

wrong_conf=list()      # List of the peg sets that lead to leaf-lose cases
counter=0              # Counter of the recursion times (global variable)

print(test_solve(pegs, holes, Node(""start""), wrong_conf, (5, 1)))
print(""Solve function called "" + str(counter) + "" times."")

```",2020-12-05T15:15:09+00:00
comp-think/2020-2021,"Lecture ""Backtracking algorithms"", exercise 1 ",AlessandraFa,"```
# test case function
def test_solve(pegs, holes, last_move, failed_moves, expected):
    return solve(pegs,holes,last_move,failed_moves) == expected

# function:
def solve(pegs, holes, last_move, failed_moves):
    result = None
    if len(pegs) == 1 and (5, 1) in pegs:  # leaf-win base case
        result = last_move
    else:
        if tuple(pegs) in failed_moves:
            undo_move(last_move, pegs, holes)  # backtracking
        else:
            last_move.children = valid_moves(pegs, holes)
            if len(last_move.children) == 0:  # leaf-lose base case
                failed_moves[tuple(pegs)] = []
                undo_move(last_move, pegs, holes)  # backtracking
            else:  # recursive step
                possible_moves = deque(last_move.children)
                while result is None and len(possible_moves) > 0:
                    current_move = possible_moves.pop()
                    apply_move(current_move, pegs, holes)
                    result = solve(pegs, holes, current_move, failed_moves)
                if result is None:
                    failed_moves[tuple(pegs)] = []
                    undo_move(last_move, pegs, holes)  # backtracking
    return result

```",2020-12-06T08:15:47+00:00
comp-think/2020-2021,Bonus exercise (AtariGo),AlessandroBertozzi,"I don't really understand how to teach the machine to get the best solution. Nevertheless, my function return randomly one of the possibile position near to the opposite colour. The logic is to close the enemy stone.
```
import random


def place_stone(colour, black, white):
    if colour == ""black"":
        place = random.choice(possible_move(""black"", black, white))
        return place
    elif colour == ""white"":
        place = random.choice(possible_move(""white"", black, white))
        return place


def possible_move(colour, black, white): # check the free position near the opposite color
    if colour == ""black"":
        movement_list = []
        for position in white:
            list_single_move = single_stone(position, black, white)
            movement_list.extend(list_single_move)
        return movement_list
    elif colour == ""white"":
        movement_list = []
        for position in black:
            list_single_move = single_stone(position, black, white)
            movement_list.extend(list_single_move)
        return movement_list


def single_stone(position, black, white): # check the free position near the stone and return a list of free position
    list_movement = []
    if (position[0] - 1, position[1]) not in black and (position[0] - 1, position[1]) not in white and position[0] - 1 <= 6:
        list_movement.append((position[0] - 1, position[1]))
    if (position[0] + 1, position[1]) not in black and (position[0] + 1, position[1]) not in white and position[0] + 1 <= 6:
        list_movement.append((position[0] + 1, position[1]))
    if (position[0], position[1] - 1) not in black and (position[0], position[1] - 1) not in white and position[1] - 1 <= 6:
        list_movement.append((position[0], position[1] - 1))
    if (position[0], position[1] + 1) not in black and (position[0], position[1] + 1) not in white and position[1] + 1 <= 6:
        list_movement.append((position[0], position[1] + 1))
    return list_movement


print(place_stone(""white"", {(1, 5), (1, 4), (2, 6)}, {(2, 5), (2, 4)}))
```",2020-12-02T00:23:32+00:00
comp-think/2020-2021,Bonus exercise (AtariGo),diegochillo,"This function classifies all the free points on the board in these categories:
- positions that expand current color's liberties;
- positions that limit opponent's liberties;
- positions that do both things;
- neutral positions (others).

Then, to select the right move to return, it privileges:
1. The first position that limits opponents and expand the current color, if one is found;
2. Else, the first position that expands current color's liberties, if one is found;
3. Else, the first position that limits opponent's liberties, if one is found;
4. Else, a position that is not adjacent to anything.
Otherwise there are no free positions to return. 

Not a great strategy, but a lot of thoughts about liberties and groups and others and what is better to pursue.

```
def place_stone(color,black,white):
  
  if len(black & white)==0:     # Check that black and white sets don't have common elements
  
    range_x=range(7)            # Maximum number of columns
    range_y=range(7)            # Maximum number of rows
    occupied=black.union(white) # Defines a set with all the occupied cells regardless of the color
    
    expanding=list()  # Prepares the list of moves that expand the liberties
    limiting=list()   # Prepares the list of moves that limit opponent's liberties 
    others=list()     # Prepres the list of all other positions
    
    # Gets rid of the black/white dialectics and switches to current/opponent
    if color==""white"":
      current=white
      opponent=black
    else:
      current=black
      opponent=white
    
    # Cycles all the positions of the board:
    for x in range_x:
      for y in range_y:
        
        if ((x,y) not in occupied): # if position is empty
          
          if check_neighbors(x,y,opponent): # if position limits opponent liberties
            limiting.append((x,y))
          if check_neighbors(x,y,current):  # if position expands current color liberties
            expanding.append((x,y))
          if ((x,y) not in limiting) and ((x,y) not in expanding): # if position has no neighbor stones
            others.append((x,y))
            
    bestpos=set(limiting) & set(expanding) # Finds the positons limiting the opponent and expanding the current group
    
    if len(bestpos)>0:
      return(list(bestpos)[0]) # Returns the first result that expand your liberty and limits the opponent
          
    if len(limiting)>0:
      return(limiting[0])      # Else returns the first result that limits the opponent
              
    if len(expanding)>0:
      return expanding[0]      # Else returns the first result that expands your liberties
            
    if len(others)>0:
      return (others[0])       # Else returns the first free position 
          
    return ""No position available""  # Else no move can be done
    
  else:   
    return ""Each point admits only one stone!""

# This ancillary function only returns if x,y position is adjacent to something in checking set
def check_neighbors(x,y,checking):
  return ((x-1,y) in checking) or ((x+1,y) in checking) or ((x,y-1) in checking) or ((x,y+1) in checking)


# TEST CASES  
  
color=""white""
black={(2,2),(2,3),(2,4),(2,5)}
white={(2,1),(3,2),(3,3)}
print (place_stone(color,black,white)) # Answers (3,4)

color=""black""
black={(4,3),(4,4),(4,5),(5,3),(5,5),(6,3),(6,5)}
white={(5,4)}
print (place_stone(color,black,white)) # Answers (6,4)... My boy!

color=""black""
black={(4,3),(4,4),(4,5),(5,3),(5,5),(6,3),(6,5)}
white={(4,3)}
print (place_stone(color,black,white)) # Returns an error

```",2020-12-02T23:10:29+00:00
comp-think/2020-2021,"Lecture ""Organising information: trees"", exercise 2",diegochillo,"```
from anytree import Node


def test_breadth_iter(root_node, expected):
    result = breadth_iter(root_node)
    return result == expected


def breadth_iter(root_node):
    breadth_result = [root_node]
    levellist = [root_node]
    totalsons = []

    while levellist != []:  # Repeats until there are levels

        del totalsons[:]
        for thisnode in levellist:  # Cycles all the elements of the tree level
            nodesons = thisnode.children
            totalsons.extend(nodesons)  # Puts all the children of sibling nodes in the same list

        breadth_result.extend(totalsons)  # Adds brothers and cousins to the result list

        del levellist[:]
        levellist.extend(totalsons)  # Repeats with the list of brothers and cousins, if not empty

    return breadth_result


############### TEST CASES ##################

# My tree definition and test
mytree = Node(""mytree"")
branch1 = Node(""branch1"", mytree)
sprig11 = Node(""sprig11"", branch1)
leaf111 = Node(""leaf111"", sprig11)
sprig12 = Node(""sprig12"", branch1)
branch2 = Node(""branch2"", mytree)
sprig21 = Node(""sprig21"", branch2)
sprig22 = Node(""sprig22"", branch2)
branch3 = Node(""branch3"", mytree)
sprig23 = Node(""sprig23"", branch2)
sprig31 = Node(""sprig31"", branch3)
leaf311 = Node(""leaf311"", sprig31)
leaf312 = Node(""leaf312"", sprig31)
sprig32 = Node(""sprig32"", branch3)

print(test_breadth_iter(mytree,
                        [mytree, branch1, branch2, branch3, sprig11, sprig12, sprig21, sprig22, sprig23, sprig31,
                         sprig32, leaf111, leaf311, leaf312]))


# Peroni's tree definition and test
book = Node(""book"")
chapter_1 = Node(""chapter"", book)
chapter_2 = Node(""chapter"", book)
paragraph_1 = Node(""paragraph"", chapter_1)
text_1 = Node(""Alice was beginning to get very tired of sitting by ""
              ""her sister on the bank, and of having nothing to do: ""
              ""once or twice she had peeped into the book her sister ""
              ""was reading, but it had no pictures or conversations ""
              ""in it, "", paragraph_1)
quotation_1 = Node(""quotation"", paragraph_1)
text_2 = Node(""â€œand what is the use of a book,â€"", quotation_1)
text_3 = Node("" thought Alice, "", paragraph_1)
quotation_2 = Node(""quotation"", paragraph_1)
text_4 = Node(""â€œwithout pictures or conversations?â€"", quotation_2)
paragraph_2 = Node(""paragraph"", chapter_1)
text_5 = Node(""So she was considering in her own mind, (as well as ""
              ""she could, for the hot day made her feel very sleepy ""
              ""and stupid,) whether the pleasure of making a ""
              ""daisy-chain would be worth the trouble of getting up ""
              ""and picking the daisies, when suddenly a white rabbit ""
              ""with pink eyes ran close by her."", paragraph_2)
paragraph_3 = Node(""paragraph"", chapter_1)
text_6 = Node(""..."", paragraph_3)
text_7 = Node(""..."", chapter_2)
text_8 = Node(""..."", book)

print(test_breadth_iter(book,
                        [book, chapter_1, chapter_2, text_8, paragraph_1, paragraph_2, paragraph_3, text_7, text_1,
                         quotation_1, text_3, quotation_2, text_5, text_6, text_2, text_4]))

```",2020-11-28T10:44:44+00:00
comp-think/2020-2021,"Lecture ""Organising information: trees"", exercise 2",dbrembilla,"```
'''
The node tree looks like this:
ROOT: forest
Children: pine1, pine2, birch1, birch2,birch3, fallen_branch
Grandchildren(pine1): branch1, branch2, branch3
Grandchildren(pine2): branch4, branch5
Grandchildren(birch1): branch6
Grandchildren(birch2): branch7, branch8
Grandchildren(birch3): branch9, branch10, branch11
Grandgrandchildren(branch6): leaf1
'''
from anytree import Node
from collections import deque


expected_result = [""forest"", ""pine1"", ""pine2"", ""birch1"", ""birch2"", ""birch3"", ""fallenbranch"", ""branch1"", ""branch2"", ""branch3"", ""branch4"", ""branch5"", ""branch6"", ""branch7"", ""branch8"", ""branch9"", ""branch10"", ""branch11"", ""leaf1""]

forest = Node(""forest"")
pine1 = Node(""pine1"", forest)
pine2 = Node(""pine2"", forest)
birch1 = Node(""birch1"", forest)
birch2 = Node(""birch2"", forest)
birch3 = Node(""birch3"", forest)
fallen_branch = Node(""fallenbranch"", forest)
branch1= Node(""branch1"", pine1)
branch2= Node(""branch2"", pine1)
branch3= Node(""branch3"", pine1)
branch4= Node(""branch4"", pine2)
branch5= Node(""branch5"", pine2)
branch6= Node(""branch6"", birch1)
branch7= Node(""branch7"", birch2)
branch8= Node(""branch8"", birch2)
branch9= Node(""branch9"", birch3)
branch10= Node(""branch10"", birch3)
branch11=Node(""branch11"", birch3)
leaf1=Node(""leaf1"", branch6)

def test_node(root_element, expected):
    return breadth_first_visit(root_element) ==expected

def breadth_first_visit(root_node):
    result = []
    to_add = deque() #queue
    to_add.append(root_node)
    while len(to_add) != 0 :
        child= to_add.popleft()
        result.append(child.name)
        to_add.extend(child.children)
    return result
print(test_node(forest, expected_result))
```",2020-11-29T10:33:41+00:00
comp-think/2020-2021,"Lecture ""Organising information: trees"", exercise 2",ConstiDami,"    from anytree import Node
    from collections import deque
    
    # the list is used to store the final result,
    # the deque makes sure to add the children in the right order (breadth first approach)
    tree_list = []
    tree_deque = deque()
    
    
    def breadth_first_visit(root_node):
        # this if statement clears the global variables, to start over at every call of the function with a different tree
        if root_node == root_node.root:
            tree_list.clear()
            tree_deque.clear()
            #This time the deque has to have an element in it in order to go into the while looop
            tree_list.append(root_node)
            tree_deque.append(root_node)
    
        while len(tree_deque) > 0:
            #erasing the root element from the deque, otherwise the firsts childs will be added to the list twice
            if root_node == root_node.root:
                tree_deque.clear()
            if root_node.children != ():
                tree_list.extend(root_node.children)
                tree_deque.extend(root_node.children)
            root_node = tree_deque.popleft()
    
        return tree_list
    
    
    def test_breadth_first_visit(root_node, expected):
        return expected == breadth_first_visit(root_node)
    
    
    ###Test cases
    
    book = Node(""book"")
    chapter_1 = Node(""chapter"", book)
    chapter_2 = Node(""chapter"", book)
    paragraph_1 = Node(""paragraph"", chapter_1)
    text_1 = Node(""Alice was beginning to get very tired of sitting by ""
              ""her sister on the bank, and of having nothing to do: ""
              ""once or twice she had peeped into the book her sister ""
              ""was reading, but it had no pictures or conversations ""
              ""in it, "", paragraph_1)
    quotation_1 = Node(""quotation"", paragraph_1)
    text_2 = Node(""â€œand what is the use of a book,â€"", quotation_1)
    text_3 = Node("" thought Alice, "", paragraph_1)
    quotation_2 = Node(""quotation"", paragraph_1)
    text_4 = Node(""â€œwithout pictures or conversations?â€"", quotation_2)
    paragraph_2 = Node(""paragraph"", chapter_1)
    text_5 = Node(""So she was considering in her own mind, (as well as ""
              ""she could, for the hot day made her feel very sleepy ""
              ""and stupid,) whether the pleasure of making a ""
              ""daisy-chain would be worth the trouble of getting up ""
              ""and picking the daisies, when suddenly a white rabbit ""
              ""with pink eyes ran close by her."", paragraph_2)
    paragraph_3 = Node(""paragraph"", chapter_1)
    text_6 = Node(""..."", paragraph_3)
    text_7 = Node(""..."", chapter_2)
    text_8 = Node(""..."", book)
    
    print(test_breadth_first_visit(book, [book, chapter_1, chapter_2, text_8, paragraph_1, paragraph_2, paragraph_3, text_7,
                                      text_1, quotation_1, text_3, quotation_2, text_5, text_6, text_2, text_4]))
    
    grandma = Node(""Nonna"")
    uncle = Node(""Davide"", grandma)
    mum = Node(""Elisabetta"", grandma)
    brother_1 = Node(""Hadrien"", mum)
    brother_2 = Node(""ClÃ©ment"", mum)
    sister = Node(""Constance"", mum)
    cousin_1 = Node(""Nicola"", uncle)
    cousin_2 = Node(""Benoit"", uncle)
    cousin_3 = Node(""Quentin"", uncle)
    
    print(test_breadth_first_visit(grandma,
                               [grandma, uncle, mum, cousin_1, cousin_2, cousin_3, brother_1, brother_2, sister]))
    
",2020-11-29T22:13:22+00:00
comp-think/2020-2021,"Lecture ""Organising information: trees"", exercise 2",giorgiasampo,"````
from anytree import Node, RenderTree

book = Node(""book"")
chapter_1 = Node(""chapter"", book)
chapter_2 = Node(""chapter"", book)

paragraph_1 = Node(""paragraph"", chapter_1)
text_1 = Node(""Alice was beginning to get very tired of sitting by ""
              ""her sister on the bank, and of having nothing to do: ""
              ""once or twice she had peeped into the book her sister ""
              ""was reading, but it had no pictures or conversations ""
              ""in it, "", paragraph_1)
quotation_1 = Node(""quotation"", paragraph_1)
text_2 = Node(""â€œand what is the use of a book,â€"", quotation_1)
text_3 = Node("" thought Alice, "", paragraph_1)
quotation_2 = Node(""quotation"", paragraph_1)
text_4 = Node(""â€œwithout pictures or conversations?â€"", quotation_2)

print(RenderTree(book))

def breadth_first_visit(root_node):
    result=list()
    for item in reversed(root_node.descendants):
        if item != root_node and item not in result:
            result.append(item.name)
            for item1 in item.siblings:
                result.append(item1.name)
    final = list()
    for item in reversed(result):
        final.append(item)
    return final

print(breadth_first_visit(book))
````

I think it does what it is supposed to do: underlining the 'I think' and 'supposed' in the previous sentence.",2020-12-01T17:09:45+00:00
comp-think/2020-2021,"Lecture ""Organising information: trees"", exercise 2",fcagnola,"```
from testing_functions import test_1_parameter
from collections import deque
from anytree import Node, RenderTree

betty = Node(""betty"")
donald = Node(""donald"", betty)
bill = Node(""bill"", betty)
gerry = Node(""gerry"", betty)
sally = Node(""sally"", donald)
bobby = Node(""bobby"", donald)
joan = Node(""joan"", bill)
peggy = Node(""peggy"", bill)
kenny = Node(""kenny"", gerry)
pete = Node(""pete"", gerry)
terry = Node(""terry"", sally)
gina = Node(""gina"", joan)
bert = Node(""bert"", joan)
lane = Node(""lane"", kenny)
harry = Node(""harry"", bert)
roger = Node(""roger"", Pete)

def traversal_level_iterative(node):
    result = []  # empty variable result
    q = deque()
    q.append(node)

    while len(q) > 0:
        child = q.popleft()
        result.append(child.name)
        q.extend(child.children)

    return result

print(traversal_level_iterative(betty))

print(test_1_parameter(traversal_level_iterative, betty, ['betty', 'donald', 'bill', 'gerry', 'sally', 'bobby', 'joan', 'peggy', 'kenny', 'pete', 'terry', 'gina', 'bert', 'lane', 'roger', 'harry']))
```",2020-12-02T14:08:16+00:00
comp-think/2020-2021,"Lecture ""Organising information: trees"", exercise 2",AlessandraFa,"```
from anytree import Node


def test_iterative_bfv(root, expected):
    return iterative_bfv(root) == expected


def iterative_bfv(root):
    result = []
    current_level = [root]
    while True:
        for node in current_level:
            result.append(node.name)    # appends nodes currently stored in current_level to result list
        tmp = []                        # initialises empty temporary list
        for node in current_level:      # iterates on elements in list current_level
            for child in childr(node):  # function childr(node) returns a list of children for each node in current_level
                tmp.append(child)       # each child node in the list of children is appended to the temporary list
        if len(tmp) == 0:               # stops iteration if node is a leaf node
            break
        else:
            current_level = tmp         # stores tmp's items in the list current_level for new iteration
    return result


def childr(node):
    ch_list = []
    for n in node.children:
        ch_list.append(n)
    return ch_list


book = Node(""book"")
chapter_1 = Node(""chapter"", book)
chapter_2 = Node(""chapter"", book)

paragraph_1 = Node(""paragraph"", chapter_1)
text_1 = Node(""Alice was beginning to get very tired of sitting by ""
              ""her sister on the bank, and of having nothing to do: ""
              ""once or twice she had peeped into the book her sister ""
              ""was reading, but it had no pictures or conversations ""
              ""in it, "", paragraph_1)
quotation_1 = Node(""quotation"", paragraph_1)
text_2 = Node(""â€œand what is the use of a book,â€"", quotation_1)
text_3 = Node("" thought Alice, "", paragraph_1)
quotation_2 = Node(""quotation"", paragraph_1)
text_4 = Node(""â€œwithout pictures or conversations?â€"", quotation_2)

paragraph_2 = Node(""paragraph"", chapter_1)
text_5 = Node(""So she was considering in her own mind, (as well as ""
              ""she could, for the hot day made her feel very sleepy ""
              ""and stupid,) whether the pleasure of making a ""
              ""daisy-chain would be worth the trouble of getting up ""
              ""and picking the daisies, when suddenly a white rabbit ""
              ""with pink eyes ran close by her."", paragraph_2)

paragraph_3 = Node(""paragraph"", chapter_1)
text_6 = Node(""..."", paragraph_3)
text_7 = Node(""..."", chapter_2)
text_8 = Node(""..."", book)



print(test_iterative_bfv(book, ['book', 'chapter', 'chapter', '...', 'paragraph', 'paragraph', 'paragraph', '...', 'Alice was beginning to get very tired of sitting by her sister on the bank, and of having nothing to do: once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it, ', 'quotation', ' thought Alice, ', 'quotation', 'So she was considering in her own mind, (as well as she could, for the hot day made her feel very sleepy and stupid,) whether the pleasure of making a daisy-chain would be worth the trouble of getting up and picking the daisies, when suddenly a white rabbit with pink eyes ran close by her.', '...', 'â€œand what is the use of a book,â€', 'â€œwithout pictures or conversations?â€']))

```",2020-12-03T19:46:30+00:00
comp-think/2020-2021,"Lecture ""Organising information: trees"", exercise 2",yunglong28,"I have used a method that it's part of the anytree package: I hope this doesn't look like cheating, I've been through a lot of tests and reading before finding this. Being breadth-first a way of sorting according to the level of depth of nodes, this method was effective. Let me know if it could be considered correct. 

```
from anytree import Node
from anytree import RenderTree
from anytree import LevelOrderIter

def iterative_breadt_first_search(root_node):
    result = []
    result = [node for node in LevelOrderIter(root_node)]
    return result


def test_iterative_breadt_first_search(root_node, expected):
    result = iterative_breadt_first_search(root_node)
    if result == expected:
        return True
    else:
        return False

#test
#mytree
#Root, L = 0
Socrate = Node('Socrate')

#Childrens, L = 1
Platone = Node('Plato', parent= Socrate)
Aristotele  = Node('Aristotele', parent = Socrate)

#Grandchildren, L = 2
StAg = Node('Agostino', parent= Platone)
Marsilio = Node('Marsilio Ficino', parent=Platone)
StThom = Node('San Tommaso', parent= Aristotele)
Avicenna = Node('Avicenna', parent=Aristotele)

#Descendants, L = 3
Scoto = Node('Scoto Eriugena', parent=StThom)
Dante = Node('Dante Alighieri', parent=StThom)

print(test_iterative_breadt_first_search(Socrate, [Socrate, Platone, Aristotele, StAg, Marsilio, StThom, Avicenna, Scoto, Dante])) #returns True

#test with Professor's tree
print(test_iterative_breadt_first_search(book, [book, chapter_1, chapter_2, text_8, paragraph_1, paragraph_2, paragraph_3, text_7, text_1, quotation_1, text_3, quotation_2, text_5, text_6, text_2, text_4]))  #returns True


```",2020-12-11T08:51:12+00:00
comp-think/2020-2021,"Lecture ""Organising information: trees"", exercise 1",diegochillo,"I feed the recursive function with the items of a list compiled by the function itself.

```
from anytree import Node


def test_breadth_first_visit(root_node, expected):
    result = breadth_first_visit(root_node)
    return result == expected


# Service lists:
finallist = []
indexrec = []


def breadth_first_visit(root_node):

    if root_node == root_node.root:  # Cleans up service lists and puts in the root node at first
        del finallist[:]
        del indexrec[:]
        finallist.append(root_node)

    if len(indexrec) != len(root_node.root.descendants) - 1:  # if it hasn't finished checking nodes
        finallist.extend(root_node.children)
        indexrec.append(1)
        breadth_first_visit(finallist[len(indexrec)])

    return finallist


############### TEST CASES ##################

# My tree definition and test
mytree = Node(""mytree"")
branch1 = Node(""branch1"", mytree)
sprig11 = Node(""sprig11"", branch1)
leaf111 = Node(""leaf111"", sprig11)
sprig12 = Node(""sprig12"", branch1)
branch2 = Node(""branch2"", mytree)
sprig21 = Node(""sprig21"", branch2)
sprig22 = Node(""sprig22"", branch2)
branch3 = Node(""branch3"", mytree)
sprig23 = Node(""sprig23"", branch2)
sprig31 = Node(""sprig31"", branch3)
leaf311 = Node(""leaf311"", sprig31)
leaf312 = Node(""leaf312"", sprig31)
sprig32 = Node(""sprig32"", branch3)

print(test_breadth_first_visit(mytree,
                               [mytree, branch1, branch2, branch3, sprig11, sprig12, sprig21, sprig22, sprig23, sprig31,
                                sprig32, leaf111, leaf311, leaf312]))


# Peroni's tree definition and test
book = Node(""book"")
chapter_1 = Node(""chapter"", book)
chapter_2 = Node(""chapter"", book)
paragraph_1 = Node(""paragraph"", chapter_1)
text_1 = Node(""Alice was beginning to get very tired of sitting by ""
              ""her sister on the bank, and of having nothing to do: ""
              ""once or twice she had peeped into the book her sister ""
              ""was reading, but it had no pictures or conversations ""
              ""in it, "", paragraph_1)
quotation_1 = Node(""quotation"", paragraph_1)
text_2 = Node(""â€œand what is the use of a book,â€"", quotation_1)
text_3 = Node("" thought Alice, "", paragraph_1)
quotation_2 = Node(""quotation"", paragraph_1)
text_4 = Node(""â€œwithout pictures or conversations?â€"", quotation_2)
paragraph_2 = Node(""paragraph"", chapter_1)
text_5 = Node(""So she was considering in her own mind, (as well as ""
              ""she could, for the hot day made her feel very sleepy ""
              ""and stupid,) whether the pleasure of making a ""
              ""daisy-chain would be worth the trouble of getting up ""
              ""and picking the daisies, when suddenly a white rabbit ""
              ""with pink eyes ran close by her."", paragraph_2)
paragraph_3 = Node(""paragraph"", chapter_1)
text_6 = Node(""..."", paragraph_3)
text_7 = Node(""..."", chapter_2)
text_8 = Node(""..."", book)

print(test_breadth_first_visit(book, [book, chapter_1, chapter_2, text_8, paragraph_1, paragraph_2, paragraph_3, text_7,
                                      text_1, quotation_1, text_3, quotation_2, text_5, text_6, text_2, text_4]))
```
",2020-11-28T10:43:16+00:00
comp-think/2020-2021,"Lecture ""Organising information: trees"", exercise 1",dbrembilla,"I tried my best to solve this exercise, but I keep getting recursion errors that should not happen and I don't understand why. This is what I came up with.
```
'''
The node tree looks like this:
ROOT: forest
Children: pine1, pine2, birch1, birch2,birch3, fallen_branch
Grandchildren(pine1): branch1, branch2, branch3
Grandchildren(pine2): branch4, branch5
Grandchildren(birch1): branch6
Grandchildren(birch2): branch7, branch8
Grandchildren(birch3): branch9, branch10, branch11
Grandgrandchildren(branch6): leaf1
'''
from anytree import Node
from collections import deque


expected_result = [""forest"", ""pine1"", ""pine2"", ""birch1"", ""birch2"", ""birch3"", ""fallenbranch"", ""branch1"", ""branch2"", ""branch3"", ""branch4"", ""branch5"", ""branch6"", ""branch7"", ""branch8"", ""branch9"", ""branch10"", ""branch11"", ""leaf1""]

forest = Node(""forest"")
pine1 = Node(""pine1"", forest)
pine2 = Node(""pine2"", forest)
birch1 = Node(""birch1"", forest)
birch2 = Node(""birch2"", forest)
birch3 = Node(""birch3"", forest)
fallen_branch = Node(""fallenbranch"", forest)
branch1= Node(""branch1"", pine1)
branch2= Node(""branch2"", pine1)
branch3= Node(""branch3"", pine1)
branch4= Node(""branch4"", pine2)
branch5= Node(""branch5"", pine2)
branch6= Node(""branch6"", birch1)
branch7= Node(""branch7"", birch2)
branch8= Node(""branch8"", birch2)
branch9= Node(""branch9"", birch3)
branch10= Node(""branch10"", birch3)
branch11=Node(""branch11"", birch3)
leaf1=Node(""leaf1"", branch6)

#temporary lists
tmp_ancestors = [] #used to distinguish the first run from the others
tmp_siblings = deque() #used as a queue to popleft each element
tmp_sibling_children = [] #used to gather all the children elements for the next level

#conditions
has_no_ancestors = len(tmp_ancestors) == 0
has_no_siblings = len(tmp_siblings) <= 1
has_sibling_children = len(tmp_sibling_children) != 0

def breadth_first_visit(root_node):
    result = []
    if (not has_no_ancestors) and has_no_siblings and (not has_sibling_children):
        result.append(root_node.name)
        return result
    elif has_no_ancestors and has_no_siblings and (not has_sibling_children): #1st run
        tmp_ancestors.append(root_node)
        tmp_siblings.extend(root_node.children)
        result.append(root_node.name)
        next_item = [breadth_first_visit(tmp_siblings[0])]
        return result.extend(next_item)
    elif has_no_siblings and has_no_ancestors and has_sibling_children:
        tmp_sibling_children.extend(root_node.children)
        tmp_sibling_children.clear()
        tmp_siblings.popleft()
        tmp_siblings.extend(tmp_sibling_children)
        result.append(root_node.name)
        return result.extend(breadth_first_visit(tmp_siblings[0]))
    elif not has_no_siblings:
        tmp_sibling_children.extend(root_node.children)
        tmp_siblings.popleft()
        result.append(root_node.name)
        return result.extend(breadth_first_visit(tmp_siblings[0]))

def test_tree(root_test, expected):
    return breadth_first_visit(root_test) == expected

print(test_tree(forest, expected_result))
```",2020-11-29T09:38:43+00:00
comp-think/2020-2021,"Lecture ""Organising information: trees"", exercise 1",ConstiDami,"Both tests return True. 
It took me a very long time to figure out how to proceed... After a lot of tests I found that the deque was a good solution!
     


    from anytree import Node
    from collections import deque
    
    #the list is used to store the final result,
    #the deque makes sure to add the children in the right order (breadth first approach)
    tree_list = []
    tree_deque = deque()
    
    def breadth_first_visit(root_node):
    
        #this if statement clears the global variables, to start over at every call of the function with a different tree
        if root_node == root_node.root:
            tree_list.clear()
            tree_deque.clear()
            # only the list takes the root node, because the deque has to call the function with the first child
            # and not the root a second time
            tree_list.append(root_node)
    
        #Adding the children if they exist, otherwise calling the function with the next element in the deque
        if root_node.children != ():
            tree_list.extend(root_node.children)
            tree_deque.extend(root_node.children)
            breadth_first_visit(tree_deque.popleft())
        elif len(tree_deque) != 0:
            breadth_first_visit(tree_deque.popleft())
    
        #if there are no more elements in the deque => if we have reached all the descendants of the root,
        #returning the list
        if len(tree_deque) == 0:
            return tree_list
    
        #return statement for all the other times the function is called
        else:
            return
    
    def test_breadth_first_visit(root_node, expected):
        return expected == breadth_first_visit(root_node)
    
    ###Test cases
    
    book = Node(""book"")
    chapter_1 = Node(""chapter"", book)
    chapter_2 = Node(""chapter"", book)
    paragraph_1 = Node(""paragraph"", chapter_1)
    text_1 = Node(""Alice was beginning to get very tired of sitting by ""
                  ""her sister on the bank, and of having nothing to do: ""
                  ""once or twice she had peeped into the book her sister ""
                  ""was reading, but it had no pictures or conversations ""
                  ""in it, "", paragraph_1)
    quotation_1 = Node(""quotation"", paragraph_1)
    text_2 = Node(""â€œand what is the use of a book,â€"", quotation_1)
    text_3 = Node("" thought Alice, "", paragraph_1)
    quotation_2 = Node(""quotation"", paragraph_1)
    text_4 = Node(""â€œwithout pictures or conversations?â€"", quotation_2)
    paragraph_2 = Node(""paragraph"", chapter_1)
    text_5 = Node(""So she was considering in her own mind, (as well as ""
                  ""she could, for the hot day made her feel very sleepy ""
                  ""and stupid,) whether the pleasure of making a ""
                  ""daisy-chain would be worth the trouble of getting up ""
                  ""and picking the daisies, when suddenly a white rabbit "" 
                  ""with pink eyes ran close by her."", paragraph_2)
    paragraph_3 = Node(""paragraph"", chapter_1)
    text_6 = Node(""..."", paragraph_3)
    text_7 = Node(""..."", chapter_2)
    text_8 = Node(""..."", book)
    
    print(test_breadth_first_visit(book, [book, chapter_1, chapter_2, text_8, paragraph_1, paragraph_2, paragraph_3, text_7, text_1, quotation_1, text_3, quotation_2, text_5, text_6, text_2, text_4]))
    
    grandma = Node(""Nonna"")
    uncle = Node(""Davide"", grandma)
    mum = Node(""Elisabetta"", grandma)
    brother_1 = Node(""Hadrien"", mum)
    brother_2 = Node(""ClÃ©ment"", mum)
    sister = Node(""Constance"", mum)
    cousin_1 = Node(""Nicola"", uncle)
    cousin_2 = Node(""Benoit"", uncle)
    cousin_3 = Node(""Quentin"", uncle)
    
    print(test_breadth_first_visit(grandma, [grandma, uncle, mum, cousin_1, cousin_2, cousin_3, brother_1, brother_2, sister]))
    
",2020-11-29T21:50:22+00:00
comp-think/2020-2021,"Lecture ""Organising information: trees"", exercise 1",AlessandroBertozzi,"My function run as a depth first-visit function (development exercise) and order all the nodes by the len of their ancestors: from the shorter node (root node) to the longest ones.
```
from anytree import Node, RenderTree

# Tree
book = Node(""book"")
chapter_1 = Node(""chapter"", book)
chapter_2 = Node(""chapter"", book)
paragraph_1 = Node(""paragraph"", chapter_1)
text_1 = Node(""Alice was beginning to get very tired of sitting by ""
              ""her sister on the bank, and of having nothing to do: ""
              ""once or twice she had peeped into the book her sister ""
              ""was reading, but it had no pictures or conversations ""
              ""in it, "", paragraph_1)
quotation_1 = Node(""quotation"", paragraph_1)
text_2 = Node(""â€œand what is the use of a book,â€"", quotation_1)
text_3 = Node("" thought Alice, "", paragraph_1)
quotation_2 = Node(""quotation"", paragraph_1)
text_4 = Node(""â€œwithout pictures or conversations?â€"", quotation_2)
paragraph_2 = Node(""paragraph"", chapter_1)
text_5 = Node(""So she was considering in her own mind, (as well as ""
              ""she could, for the hot day made her feel very sleepy ""
              ""and stupid,) whether the pleasure of making a ""
              ""daisy-chain would be worth the trouble of getting up ""
              ""and picking the daisies, when suddenly a white rabbit "" 
              ""with pink eyes ran close by her."", paragraph_2)
paragraph_3 = Node(""paragraph"", chapter_1)
text_6 = Node(""..."", paragraph_3)
text_7 = Node(""..."", chapter_2)
text_8 = Node(""..."", book)


# Test case for the algorithm
def test_breadth_first_visit(node, expected):
    result = breadth_first_visit(node)
    if expected == result:
        return True
    else:
        return False


# Algorithm
def breadth_first_visit(node):
    result = list()
    breadth_first_visit_recursive(node, result)
    return result


def breadth_first_visit_recursive(node, list):
    if node == node.root:
        list.append(node)
    else:
        for nodes in reversed(list):
            if len(nodes.ancestors) <= len(node.ancestors):
                position = list.index(nodes)
                list.insert(position + 1, node)
                break
    for child in node.children:
        breadth_first_visit_recursive(child, list)

print(breadth_first_visit(book))
print(test_breadth_first_visit(book, [book, chapter_1, chapter_2, text_8, paragraph_1, paragraph_2,
                                      paragraph_3, text_7,
                                      text_1, quotation_1, text_3, quotation_2, text_5,
                                      text_6, text_2, text_4]))
```",2020-11-30T23:09:14+00:00
comp-think/2020-2021,"Lecture ""Organising information: trees"", exercise 1",fcagnola,"It took me so much time that when it finally returned True I couldn't believe it, and ran a thousand additional tests. I pasted just the first one because trees take up quite a lot of space

```
# Write in Python a recursive function def breadth_first_visit(root_node). This function takes the root node of a tree
# and returns a list containing all the nodes of the tree according to a breadth-first order. The breadth-first order
# considers all the nodes of the first level, then those ones of the second level, and so forth. For instance,
# considering the nodes created in Listing 2, the function called on the node book should return the following list:
# [book, chapter_1, chapter_2, text_8, paragraph_1, paragraph_2, paragraph_3, text_7, text_1, quotation_1, text_3,
# quotation_2, text_5, text_6, text_2, text_4]. Accompany the implementation of the function with the appropriate test
# cases.

from testing_functions import test_1_parameter
from collections import deque
from anytree import Node, RenderTree

queue = deque()

def traversal_level(node):
    result = []  # empty variable result

    if node.name not in result:  # if the node passed as input is not in the result list, add it immediately
        result.append(node.name)

    if node.children != ():  # additionally, if the node has children, add these to the queue
        for n in node.children:
            queue.append(n)

    while len(queue) > 0:  # while the queue is not empty, run the function recursively with the queue's elements as input
        result.extend(traversal_level(queue.popleft()))

    return result  # finally (and for each recursive call) return the list generated

betty = Node(""betty"")
donald = Node(""donald"", betty)
bill = Node(""bill"", betty)
gerry = Node(""gerry"", betty)
sally = Node(""sally"", donald)
bobby = Node(""bobby"", donald)
joan = Node(""joan"", bill)
peggy = Node(""peggy"", bill)
kenny = Node(""kenny"", gerry)
pete = Node(""pete"", gerry)
terry = Node(""terry"", sally)
gina = Node(""gina"", joan)
bert = Node(""bert"", joan)
lane = Node(""lane"", kenny)
harry = Node(""harry"", bert)
roger = Node(""roger"", pete)
r = RenderTree(betty)
print(r)
print(test_1_parameter(traversal_level, betty, ['betty', 'donald', 'bill', 'gerry', 'sally', 'bobby', 'joan', 'peggy', 'kenny', 'pete', 'terry', 'gina', 'bert', 'lane', 'roger', 'harry'])) # returns True
```
",2020-12-01T16:46:00+00:00
comp-think/2020-2021,"Lecture ""Organising information: trees"", exercise 1",giorgiasampo,"````
from anytree import Node, RenderTree


book = Node(""book"")
chapter_1 = Node(""chapter"", book)
chapter_2 = Node(""chapter"", book)

paragraph_1 = Node(""paragraph"", chapter_1)
text_1 = Node(""Alice was beginning to get very tired of sitting by ""
              ""her sister on the bank, and of having nothing to do: ""
              ""once or twice she had peeped into the book her sister ""
              ""was reading, but it had no pictures or conversations ""
              ""in it, "", paragraph_1)
quotation_1 = Node(""quotation"", paragraph_1)
text_2 = Node(""â€œand what is the use of a book,â€"", quotation_1)
text_3 = Node("" thought Alice, "", paragraph_1)
quotation_2 = Node(""quotation"", paragraph_1)
text_4 = Node(""â€œwithout pictures or conversations?â€"", quotation_2)

print(RenderTree(book))


def breadth_first_visit(root_node):
    result=list()
    result.append(root_node)
    result.append(root_node.children)
    child_list = list()
    for item in root_node.descendants:
        if item.children != ():
            for element in item.children:
                child_list.append(element.name)
                breadth_first_visit(element)
                if child_list not in result:
                    result.append(child_list)
    return result


print(breadth_first_visit(book))

````
I think it works but I got a bit lost on it...",2020-12-01T18:16:52+00:00
comp-think/2020-2021,"Lecture ""Organising information: trees"", exercise 1",laurentfintoni,"I'm confused about something @essepuntato - in your exercise description you say that the resulting list for the nodes from Listing 2 should be [book, chapter_1, chapter_2, text_8, paragraph_1, paragraph_2, paragraph_3, text_7, text_1, quotation_1, text_3, quotation_2, text_5, text_6, text_2, text_4]. But when I use the solution you gave and print the function (not the test) I get [Node('/book'), Node('/book/chapter1'), Node('/book/chapter2'), Node('/book/text8'), Node('/book/chapter1/paragraph1'), Node('/book/chapter1/paragraph2'), Node('/book/chapter1/paragraph3'), Node('/book/chapter2/text7'), Node('/book/chapter1/paragraph1/text1'), Node('/book/chapter1/paragraph1/quotation1'), Node('/book/chapter1/paragraph1/text3'), Node('/book/chapter1/paragraph1/quotation2'), Node('/book/chapter1/paragraph2/text5'), Node('/book/chapter1/paragraph3/text6'), Node('/book/chapter1/paragraph1/quotation1/text2'), Node('/book/chapter1/paragraph1/quotation2/text4')]

What's confusing me is that based on how you wrote the exercise description I was expecting that running the function should print the list exactly how you have it in the description. But if I understand correctly that's not possible and instead it will always print with Node('node_name'), but those node values are equivalent to their titles (hence why it matches the bfv value you use in your solution)? 

I hope that makes sense? I've spent the past two weeks trying to understand how to get python to print the node's value name only because the way you formatted the description totally threw me off. 

lmk thanks ",2020-12-11T16:20:51+00:00
comp-think/2020-2021,"Lecture ""Organising information: trees"", exercise 1",laurentfintoni,"actually I also just realized that the elements of Listing 2 needed renaming, i've been using them as they are in the tree_instructions.py file and that has totally thrown me off as well. ",2020-12-11T16:33:15+00:00
comp-think/2020-2021,"Lecture ""Organising information: trees"", exercise 1",LuisAmmi,"I finally succeeded! I do not deny that I also viewed the solutions shared by others (especially the code written by Constance), but they helped me so much to get the sense. I know that it is missing the test, but I'll complete it in the next days. For now, I'm quite satisfied :')
I tried to use my family tree as example, in order to check if with many branches it still works.
```

from collections import deque
from anytree import Node, RenderTree


tree_queue = deque()
result = list()

def breadth_first_visit(root_node):

    if len(root_node.ancestors) == 0:  # That means we're dealing with the root-node (It happens only one time)
        tree_queue.clear()   #we need to clean our queue and list, beacuse they're outside the function, so
        result.clear()       # if we want to re-call the function with different data, it will continue printing the first tree
        result.append(root_node)
    if root_node.children != ():       # if we're not in the leaf condition
        result.extend(root_node.children)
        tree_queue.extend(root_node.children)
        breadth_first_visit(tree_queue.popleft())
    elif len(tree_queue) != 0:                    # we need this condition to complete the sequence of leafs
        breadth_first_visit(tree_queue.popleft())
    return result




grandpa = Node(""Nonno Giuseppe"")
aunt_Antonietta = Node(""Antonietta"", grandpa)
uncle_Filippo = Node(""Filippo"", grandpa)
aunt_Catia = Node(""Caterina"", grandpa)
uncle_Enrico = Node(""Enrico"", grandpa)
dad = Node(""Adriano"", grandpa)
Pietro = Node(""Pietro"", aunt_Antonietta)
Roberto = Node(""Roberto"", aunt_Antonietta)
Giuseppe = Node(""Giuseppe"", uncle_Filippo)
Arianna = Node(""Arianna"", uncle_Enrico)
Raffaele = Node(""Raffaele"", aunt_Catia)
Antonella = Node(""Antonella"", aunt_Catia)
Rossana = Node(""Rossana"", uncle_Enrico)
Anna = Node(""Anna"", aunt_Catia)
Annapaola = Node(""Annapaola"", uncle_Filippo)
Peppe = Node(""Peppe"", uncle_Enrico)
Anna_sister = Node(""Anna"", dad)
Me = Node(""Luisa"", dad)
Ilaria = Node(""Ilaria"", Giuseppe)
Chiara = Node(""Chiara"", Giuseppe)
Giuseppe_junior = Node(""Giuseppe_junior"", Roberto)
Fatima = Node(""Fatima"", Raffaele)
Naima = Node(""Naima"", Antonella)
Chico = Node(""Chico"", Rossana)
Mattias = Node(""Mattias"", Antonella)
Antonio = Node(""Antonio"", Raffaele)



print(breadth_first_visit(grandpa))
render = RenderTree(grandpa)
print(render)
",2020-12-13T10:11:35+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",SarahTew,"I did the exponent algorithm from a previous set of exercises.  I made two different programs, one that can only handle positive exponents and another one which can handle positive and negative exponents.

Positive Exponents Only:
````
def exponent_dict(base_number, exponent, dictionary):
    key_pair = (base_number, exponent)
    if exponent < 0:
        return (""Positive Exponents Only!"")
    elif key_pair not in dictionary:
        if exponent == 0:
            return 1
        else:
            dictionary[key_pair] = base_number * exponent_dict(base_number, exponent - 1, dictionary)
    return dictionary[key_pair]
my_dict = {}
print(exponent_dict(2,2,my_dict))
print(exponent_dict(3,3, my_dict))
print(exponent_dict(5,-2, my_dict))
print(exponent_dict(2, 0, my_dict))

def test_exponent_dict(base_number,exponent, dictionary, expected):
    result = exponent_dict(base_number, exponent, dictionary)
    if result == expected:
       return True
    else: 
        return False
        
print(test_exponent_dict(2,2,my_dict,4))
print(test_exponent_dict(2,1,my_dict,2))
print(test_exponent_dict(50,0, my_dict,1))
print(test_exponent_dict(3, -2, my_dict, ""Positive Exponents Only!""))
````
    
Negative Exponents:
I kept getting an arithmetic error similar to what is happening here [https://stackoverflow.com/questions/45071158/arithmetic-error-python-is-incorrectly-dividing-variables](url). In my code I have added rounding in order to get around this issue for large negative numbers. It rounds to the 17th place after the decimal point so that means it doesn't work correctly for very small negative exponents. I left a comment within the code if you want to see how it behaves without the rounding.

I understand why I'm getting the arithmetic error but I don't understand how to correct in this particular case. If anyone knows, please tell me.
````
def exponent2(base_number, exponent, dictionary):
    key_pair = (base_number, exponent)
    if key_pair not in dictionary:
        if exponent == 0:
            return 1
        elif exponent <= 0:
            dictionary[key_pair] = round(1 / base_number * exponent2(base_number, exponent + 1, dictionary),17)
            #change the above line to see arithmetic error:
            #dictionary[key_pair] = 1 / base_number * exponent2(base_number, exponent + 1, dictionary)
        else: 
            dictionary[key_pair] = base_number * exponent2(base_number, exponent - 1, dictionary)
            
    return dictionary[key_pair]
my_dict = {}
print(exponent2(2,2,my_dict))
print(exponent2(2,-1,my_dict))
print(exponent2(5,-3,my_dict))
print(exponent2(10, -8, my_dict))

def test_exponent2(base_number, exponent, dictionary, expected):
    result = exponent2(base_number, exponent, dictionary)
    if result == expected:
        return True
    else:
        return False
print(test_exponent2(2,2,my_dict, 4))
print(test_exponent2(2,-1,my_dict, 0.5))
print(test_exponent2(5,-3,my_dict, 0.008))
````",2020-11-23T12:48:46+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",diegochillo,"Debug print instruction here too, to check when results are taken from the dictionary.
```
def exponentiation(base_number,exponent,d):
  tpl=(base_number, exponent)

  if tpl not in d:
     if exponent == 0:
       d[tpl]=1
     elif exponent>0:
       d[tpl]=base_number * exponentiation(base_number, exponent - 1,d) 
     else:
       d[tpl]=(1 / base_number) * exponentiation(base_number, exponent+1,d)
  else:
     print (""DEBUG Found "" + str(d[tpl]))

  return d[tpl]
    
def test_exponentiation(base_number,exponent,d,expected):
  result=exponentiation(base_number,exponent,d)
  return result==expected

# Test cases
sd=dict()
print(test_exponentiation(17, 1, sd, 17)) 
print(test_exponentiation(2, 0, sd, 1))
print(test_exponentiation(3, 4, sd, 81)) 
print(test_exponentiation(3, 6, sd, 729)) 
print(test_exponentiation(3, 9, sd, 19683))

print(test_exponentiation(2, -4, sd, 0.0625))
print(test_exponentiation(2, -5, sd, 0.03125))
print(test_exponentiation(3, -3, sd, 0.037037037037037035))

```",2020-11-23T22:00:00+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",giorgiasampo,"````

def test_exponentiation(base, exp, solution_dict, expected):
    result = exponentiation(base, exp, solution_dict)
    return result==expected

def exponentiation(base, exp, solution_dict):
    if base == 0:
        solution_dict[base]= ""Impossible""
    elif exp == 0:
        solution_dict[base]=1
    elif exp == 1:
        solution_dict[base] = base
    else:
        solution_dict[base] = base * exponentiation(base, exp - 1, solution_dict)
    return solution_dict[base]

print(test_exponentiation(2,5,dict(),32))
print(test_exponentiation(2,0,dict(),1))
print(test_exponentiation(2,1,dict(),2))
print(test_exponentiation(0,5,dict(),""Impossible""))

````",2020-11-24T15:56:23+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",dbrembilla,"```
def exponentiation(base, exponent, sol_dict):
    if base == 0 and exponent == 0:
        return ""Impossible""
    elif base != 0 and exponent == 0:
        return 1
    elif  exponent > 0 :
        if base == 0:
              return 0:
        else:    
              sol_dict[(base, exponent)] = base * exponentiation(base, exponent-1, sol_dict)
    elif exponent < 0: # rounded up to the 5th decimal
         if base == 0:
                return ""Infinity""
         else:
                sol_dict[(base, exponent)] = round(1 / base * exponentiation(base, exponent+1, sol_dict), 5)
    return sol_dict[(base, exponent)]

def test(base, exponent, sol_dict, expected):
    return exponentiation(base, exponent, sol_dict) == expected
print(test(4,2,{}, 16)) #returns True
print(test(9,3, {}, 729))#returns True
print(test(4,-2,{},0.0625)) #True
print(test(0,0, {}, ""Impossible""))#True 
print(test(4,-5, {}, 0.00098))#True
```",2020-11-24T16:57:18+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",AleRosae,"```
def test_exp(base_number, exponent, sol_dict, expected):
    return expected == exponentiation(base_number, exponent, sol_dict)

def exponentiation (base_number, exponent, sol_dict):
    if base_number not in sol_dict:
        if exponent == 0 and base_number == 0:
            return ""No!""
        elif exponent == 0:
            sol_dict[base_number] = 1
        elif exponent == 1:
            sol_dict[base_number] = base_number
        elif exponent < 0:
            sol_dict[base_number] = 1 / (base_number) * (exponentiation(base_number, exponent + 1, sol_dict))
        else:
            sol_dict[base_number] = base_number * exponentiation(base_number, exponent-1, sol_dict)

    return sol_dict.get(base_number)

print(exponentiation(3,5,dict()))
print(test_exp(3,4, dict(), 81))
print(test_exp(17,1,dict(),17))
print(test_exp(2,0,dict(),1))
print(test_exp(2,-4,dict(),0.0625))
print(test_exp(0,0,dict(),""No!""))
```",2020-11-24T17:52:34+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",LuisAmmi,"```
def test_exponentiation(base_n, exp, dictionary, expected):
    result = exponentiation(base_n, exp, dictionary)
    if result == expected:
        return True
    else:
        return False
        

def exponentiation(base_n, exp, dictionary):
    if (base_n, exp) not in dictionary:
        if exp == 0:
           dictionary[(base_n, exp)] = 1 # base case
        elif exp == 1:
            dictionary[(base_n, exp)] = base_n  # base case 2
        else:
           dictionary[(base_n, exp)] = base_n * exponentiation(base_n, exp - 1, dictionary)
    return dictionary.get((base_n, exp))

print(test_exponentiation(3, 4, {}, 81)) # true
print(test_exponentiation(17, 1, {}, 17))
print(test_exponentiation(2, 0, {}, 1))",2020-11-24T17:56:51+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",GiuliaMenna,"```
def test_exp(base_number, exponent, dictionary, expected):
    result = exp(base_number, exponent, dictionary)
    if expected == result:
        return True
    else:
        return False

def exp(base_number, exponent, dictionary):
    if (base_number, exponent) not in dictionary:
        if exponent == 0:
            dictionary[(base_number, exponent)] = 1 #base case
        else:
            dictionary[(base_number, exponent)] = base_number * exp(base_number, exponent - 1, dictionary)

    return dictionary.get((base_number, exponent))

print(test_exp(7,4, {}, 2401))
print(test_exp(28,1, {}, 28))
print(test_exp(9,0, {}, 1))
```",2020-11-24T17:57:14+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",ChiaraCati,"```
def test_exp(base, exponent, solution_dict, expected):
    result = exponential(base, exponent, solution_dict)
    if result == expected:
        return True
    else:
        return False


def exponential(base, exponent, solution_dict):
    if exponent >= 0:  # for exponent
        if exponent == 0:
            solution_dict[exponent] = 1
        elif exponent == 1:
            solution_dict[exponent] = base
        else:
            solution_dict[exponent] = base * exponential(base, exponent - 1, solution_dict)
    else:
        n= 1 / base
        if exponent == -1:
            solution_dict[exponent] = n
        else:
            solution_dict[exponent] = round(n * exponential(base, exponent + 1, solution_dict), 2)

    return solution_dict[exponent]

print(exponential(4, 2, dict()))
print(test_exp(3, 4, dict(), 81))
print(test_exp(17, 1, dict(), 17))
print(test_exp(2, 0, dict(), 1))
print(test_exp(4, -2, dict(), 0.06))

```",2020-11-24T18:07:12+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",gabrielefiorenza,"```
def test_binary_search(item, ordered_list, start, end,sd,expected):
    result =binary_search(item, ordered_list, start, end,sd)
    return expected == result

def binary_search(item, ordered_list, start, end,sd):
    if item not in sd:
        if item not in ordered_list:
            sd[item]=None
        else:
            middle = (end-start)//2
            if ordered_list[middle] == item:
                sd[item] = middle+start
            elif ordered_list[middle] < item:
                 sd[item]=binary_search(item,ordered_list,end-middle,end,sd)
            elif ordered_list[middle] >item:
                sd[item] = binary_search(item, ordered_list,start, start+middle,sd)
    return sd.get(item)

mylist=list([""tablet"", ""pc"", ""pen"",""pencil"",""room""])
print(test_binary_search(""pc"",mylist,0,4,dict(),1)) # returns True
```",2020-11-24T23:01:16+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",vanessabonanno,"```
# dynamic programming approach
def test_exponentiation(num, exp, solution_dict, expected):
    result = exponentiation(num, exp, solution_dict)
    if result == expected:
        return True
    else:
        return False


def exponentiation(num, exp, solution_dict):
    if (num, exp) not in solution_dict:
        if exp == 0:
            # return 1  # original code - base condition now doesn't return 1
            # but it adds elements to a dictionary:
            solution_dict[(num, exp)] = 1
        elif exp == 1:
            # return num # original code
            solution_dict[(num, exp)] = num
        elif exp > 0:
            # return num * exponentiation(num, exp - 1) # original code
            solution_dict[(num, exp)] = num * exponentiation(num, exp - 1, solution_dict)
        elif exp < 0:
            # return 1 / num * exponentiation(num, exp + 1) # original code
            solution_dict[(num, exp)] = 1 / num * exponentiation(num, exp + 1, solution_dict)

# I tried putting brackets before ""num"" and after ""solution_dict)"" above
# but somehow the result with a negative exponent was different (and wrong) than
# writing the division ""1 / num * exponentiation(num, exp + 1, solution_dict)""
# without brackets and I don't understand why...

        else:
            return ""Wrong input""
    # at the end algorithm returns the value related to that key:
    return solution_dict.get((num, exp))


my_dict = {}

print(exponentiation(3, 0, my_dict))   # output: 1
print(exponentiation(3, 2, my_dict))   # output: 9
print(exponentiation(3, 3, my_dict))   # output: 27
print(exponentiation(3, -3, my_dict))  # output: 0.037037037037037035

print(test_exponentiation(3, -3, my_dict, 0.037037037037037035))  # True
print(test_exponentiation(3, 0, my_dict, 0))                      # False

```",2020-11-25T16:38:59+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",fcagnola,"```
from test import test_5_parameter

# dynamic programming approach
def binary_search(item, ordered_list, start, end, solutions):

    if item in solutions: # base case for dynamic programming: if solution is in the dict, return that
        return solutions[item]

    mid = (start + end) // 2  # the middle of the section to be searched is stored in a variable

    if item == ordered_list[mid]:  # base case: if the item is found in the middle, return item and position
        solutions[item] = mid # store the solution in the dict
        return mid

    elif start == mid: # with this line python won't raise RecursionError, if start == middle it means value not in list
        return ""Value not in list""

    elif ordered_list[mid] < item:  # if item comes after middle re-run search in the second half of the list
        solutions[item] = binary_search(item, ordered_list, mid, end, solutions)  # store the solution in the dict
        return solutions[item]

    elif ordered_list[mid] > item:  # if item comes before middle re-run search in the first half of the list
        solutions[item] = binary_search(item, ordered_list, start, mid, solutions)  # store the solution in the dict
        return solutions[item]


ord_list = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'z']

print(test_5_parameter(binary_search, ""a"", ord_list, 0, len(ord_list)-1, f, 0))  # Returns True
print(test_5_parameter(binary_search, ""j"", ord_list, 0, len(ord_list)-1, f, ""Value not in list""))  # Returns True
print(test_5_parameter(binary_search, ""l"", ord_list, 0, len(ord_list)-1, f, 9))  # Returns True

for i in ""abcdefghijklmnopqrstuvwxyz"":
    print(binary_search(i, ord_list, 0, 21, d))
for i in ""jaoknfbwobpqwmnsdÃ¨nasjicubweovcpmdvowbjuvyvssca"":
    print(binary_search(i, ord_list, 0, len(ord_list)-1, d))
for i in ""bvhsfoiuqgbawÃ²odiaÃ¨pÃ Ã²dhsjvblÃ²oqÃ¨pwoiruytrhdsjalbcznm"":
    print(binary_search(i, ord_list, 0, len(ord_list) - 1, d))
print(d)
```",2020-11-25T16:51:37+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",AlessandraFa,"```
def test_new_exp(base_n, exp, exp_dict, expected):
    result = new_exp(base_n, exp, exp_dict)
    return result == expected


def new_exp(base_n, exp, exp_dic):
    if base_n < 0:
        return ""Please insert positive base.""
    if exp <= 0 and base_n == 0:
        return ""Not possible. Try again.""
    if (base_n, exp) not in exp_dic:
        if exp == 0:
            exp_dic[(base_n, exp)] = 1
        if exp < 0:
            exp_dic[(base_n, exp)] = 1/base_n * new_exp(base_n, exp + 1, exp_dic)
        else:
            exp_dic[(base_n, exp)] = base_n * new_exp(base_n, exp - 1, exp_dic)
    return exp_dic.get((base_n, exp))


dictionary = {}
print(test_new_exp(0, -2, dictionary, ""Not possible. Try again.""))
print(test_new_exp(2, 7, dictionary, 128))
print(test_new_exp(2, 3, dictionary, 8))
print(test_new_exp(-2, -4, dictionary, ""Please insert positive base.""))
print(test_new_exp(5, -1, dictionary, 1/5))
```",2020-11-26T21:06:06+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",SofiBar,"```
def exponentiation_dp(base_number, exponent, dic):
    tup = (base_number, exponent)

    if tup not in dic:
        if exponent == 1:
            dic[tup] = base_number
        elif exponent == 0:
            dic[tup] = 1
        elif exponent < 0:
            dic[tup] = 1/exponentiation_dp(base_number, -1*exponent, dic)
        else:
            dic[tup] = base_number*exponentiation_dp(base_number, exponent-1, dic)
    return dic.get(tup)

def test_exponentiation_dp(base_number, exponent, dic, expected):
    if exponentiation_dp(base_number, exponent, dic) == expected:
        return True
    else:
        return False
    
    
expo_dict = {}
print(test_exponentiation_dp(2, 4, expo_dict, 16))
print(test_exponentiation_dp(-3, 1, expo_dict, -3))
print(test_exponentiation_dp(5, 0, expo_dict, 1))
print(test_exponentiation_dp(0, 4, expo_dict, 0))
print(test_exponentiation_dp(3, -2, expo_dict, 0.1111111111111111))

```",2020-11-26T21:43:52+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",AlessandroBertozzi,"```
def test_binary_search(item, ordered_list, start, end, empty_dictionary, expected):
    result = binary_search(item, ordered_list, start, end, empty_dictionary)
    return result == expected


library = {}


def binary_search(item, ordered_list, start, end, empty_dictionary):
    my_list = ordered_list[start:end]
    position = len(my_list) // 2
    if item not in empty_dictionary:
        # Basic case
        if len(my_list) == 1 and item != my_list[position]:
            return None
        elif item == my_list[position]:
            empty_dictionary[my_list[position]] = position
            return position
        # Divide and conquer
        elif item < my_list[position]:
            empty_dictionary[my_list[position]] = position
            return binary_search(item, my_list, start, position, empty_dictionary)
        else:
            empty_dictionary[my_list[position]] = position
            return position + binary_search(item, my_list, position, end, empty_dictionary)
    else:
        return empty_dictionary.get(item)


print(test_binary_search(""Le metamorfosi"", [""Alice in Wonderland"", ""Il castello"", ""Le chiavi del regno"",
                                            ""Le metamorfosi"", ""Lolita"", ""Promessi sposi"", ""The Grapes of Wrath"",
                                            ""The Great Gatsby""], 0, 7, library, 3))

print(test_binary_search(""Le metamorfosi"", [""Alice in Wonderland"", ""Il castello"", ""Le chiavi del regno"",
                                            ""Le metamorfosi"", ""Lolita"", ""Promessi sposi"", ""The Grapes of Wrath"",
                                            ""The Great Gatsby""], 0, 7, library, 3))
print(test_binary_search(""Il castello"", [""Alice in Wonderland"", ""Il castello"", ""Le chiavi del regno"",
                                         ""Le metamorfosi"", ""Lolita"", ""Promessi sposi"", ""The Grapes of Wrath"",
                                         ""The Great Gatsby""], 0, 7, library, 1))
```
I define an external dictionary and then, every time I run my function, I check if input book is in my library (list) menawhile storing its position  in a dictionary for a future research.
",2020-11-26T23:53:37+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",essepuntato,"@fcagnola and @AlessandroBertozzi: I believe that your approach works only if I use exactly the same list for all the various calls, otherwise you may get an error in return, right?

@fcagnola: it is important to define the tests, as required by the text of the exercise. As far as I can see, you avoid doing that since you prefer to run several executions of the function. But this does not allow you to check if the result you obtain after each execution is correct or not. ",2020-11-27T10:43:40+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",fcagnola,"> @fcagnola and @AlessandroBertozzi: I believe that your approach works only if I use exactly the same list for all the various calls, otherwise you may get an error in return, right?
> 
> @fcagnola: it is important to define the tests, as required by the text of the exercise. As far as I can see, you avoid doing that since you prefer to run several executions of the function. But this does not allow you to check if the result you obtain after each execution is correct or not.

@essepuntato you are **right**, for both observations. I hadn't really though of that limit, but it is in fact the case. If I were to, in any way, alter the input list, the algorithm would not work. 
As for the test part, it was only laziness on my part, I had actually implemented the usual test function, I just hadn't copied it to the comment, I will edit the code and add it in now. thank you for taking the time to read all our code!
",2020-11-27T15:25:16+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",edoardodalborgo,"```
def test_pokemon_champion(input_list, i, dict, expected):
    return pokemon_champion(input_list, i, dict) == expected

def pokemon_champion(input_list, i, dict):
    if len(input_list) > 1:
        if i < len(input_list):
            left = input_list[i]
            right = input_list[i+1]
            if right > left:
                pair = (left, right)
            else:
                pair = (right, left)
            if pair not in dict:
                if left[1] > right[2]:
                    input_list.remove(right)
                    dict[pair] = left
                else:
                    input_list.remove(left)
                    dict[pair] = right
                i += 1
                pokemon_champion(input_list, i, dict)
        else:
            i = 0
            pokemon_champion(input_list, i, dict)
    return input_list[0]

i = 0
my_rec_dict = {}
pokemon_tournament = [(""Poliwag"",10,5), (""Charmander"",15,2), (""Abra"",8,7), (""Pidgey"",4,5), (""Goldeen"",6,8), (""Bulbasaur"",12,10), (""Charmeleon"",18,8), (""Psyduck"",3,4)]
print(test_pokemon_champion(pokemon_tournament, i, my_rec_dict, ('Bulbasaur', 12, 10)))
pokemon_tournament1 = [(""Poliwag"",10,5), (""Charmander"",15,2), (""Abra"",8,7), (""Pidgey"",4,5), (""Goldeen"",6,8), (""Charmeleon"",18,8), (""Psyduck"",3,4), (""Pidgey"",4,5)]
print(test_pokemon_champion(pokemon_tournament1, i, my_rec_dict, (""Poliwag"",10,5)))
```",2020-11-29T11:05:12+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",IlaRoss,"```
# tests
def test_exponentiation(base_number, exponent, solution_dictionary, expected):
    result = exponentiation(base_number, exponent, solution_dictionary)
    if result == expected:
        return True
    else:
        return False

# algorithm
def exponentiation(base_number, exponent, solution_dictionary):
    if base_number == 0:
        return 0
    else:
        if exponent == 0:
            return 1

        mykey = (base_number, exponent)
        if mykey in solution_dictionary.keys():
            return solution_dictionary[mykey]
        else:
            if exponent > 0:
                result = base_number * exponentiation(base_number, exponent-1, solution_dictionary)
                solution_dictionary[mykey] = result
            elif exponent < 0:
                result = 1 / base_number * (exponentiation(base_number, exponent + 1, solution_dictionary))
                solution_dictionary[mykey] = result
        return solution_dictionary[mykey]

# test runs
adict = {}
print(test_exponentiation(3, 4, adict, 81))
print(test_exponentiation(17, 1, adict, 17))
print(test_exponentiation(2, 0, adict, 1))
print(test_exponentiation(3, 2, adict, 9))
print(test_exponentiation(0, 5, adict, 0))
print(test_exponentiation(-2, 3, adict, -8))
print(test_exponentiation(3, 0, adict, 1))

#print(adict)
```",2020-11-29T22:07:26+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 2",yunglong28,"Sorry for not posting this before. I added the string to the already stored result option just to diversify the two outputs.


```
def dyamic_exponentiation (base, exponent, dict1):
 power = (base, exponent)
 if power not in dict1:
    if exponent == 0:
        dict1[power] = 1
    elif exponent > 0:
        dict1[power] = base * dyamic_exponentiation(base, exponent - 1, dict1)
    else:
        dict1[power]  = (1 / base) * dyamic_exponentiation(base, exponent + 1, dict1)
 else:
     return ""I stored the result already: "" + str(dict1.get(power))

 return dict1[power]

def test_dynamic_exponentiation (base, exponent, dict1, expected):
    result = dyamic_exponentiation(base, exponent, dict1)
    if result == expected:
        return True
    else:
        return False


dictio = {}
print(test_dynamic_exponentiation(1, 0, dictio, 1))  #True
print(test_dynamic_exponentiation(1, 0, dictio,'I stored the result already: 1'))  #True
print(test_dynamic_exponentiation(3,2, dictio, 9))  #True
print(test_dynamic_exponentiation(2, -2, dictio, 0.25))  #True

```",2020-12-10T10:28:05+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",SarahTew,"This one works for 2 positive numbers and when int_1 is negative and int_2 is positive.
````
def multiplication(int_1, int_2, solution_dict):
   
    if int_1 > int_2:
        key_pair = (int_1, int_2)
    else:
        key_pair = (int_2, int_1)
    
    if key_pair not in solution_dict:
        if int_1 == 0 or int_2 == 0:
            solution_dict[key_pair] = 0
        else:
            solution_dict[key_pair] = int_1 + multiplication(int_1, int_2 - 1, solution_dict)
    return my_dict[key_pair]

my_dict = {}
print(multiplication(2,3, my_dict))
print(multiplication(5,7, my_dict))
print(multiplication(-4, 2, my_dict))

def test_multiplication(int_1, int_2, solution_dict, expected):
    result = multiplication(int_1, int_2, solution_dict)
    if result == expected:
        return True
    else:
        return False
        
print(test_multiplication(2, 3, my_dict, 6))
print(test_multiplication(5, 7, my_dict, 35))
print(test_multiplication(-4, 2, my_dict, -8))
print(test_multiplication(0, 6, my_dict, 0))
print(test_multiplication(6, 0, my_dict, 0))
````",2020-11-23T16:03:34+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",dbrembilla,"Edited
```
def test(int_1, int_2, solution_dict, expected):
    return multiplication(int_1, int_2, solution_dict) == expected

def multiplication(int_1, int_2, solution_dict): #I stored the values using a tuple as key
    if (int_2, int_1) in solution_dict:
        return solution_dict[(int_2, int_1)]
    elif (int_1, int_2) or (int_2, int_1) not in solution_dict:
        if int_1 == 0 or int_2 == 0:
            return 0
        else:
            solution_dict[(int_1, int_2)] = int_1 + multiplication(int_1, int_2 -1, solution_dict)
    return solution_dict.get((int_1,int_2))

print(test(0,0,{},0)) #true
print(test(9,3,{(3,4):12}, 27))#true
print(test(7,6,{(6,6):36}, 42))#true
```
",2020-11-23T17:45:36+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",diegochillo,"I put some ""print"" to check if the program was fetching solutions from the dictionary or calculating them again.
I haven't worried about negative inputs because the original recursive function didn't take 'em in account.

```
def test_multiplication(int_1, int_2, d, expected):
     result = multiplication(int_1, int_2, d)
     return expected == result


def multiplication(int_1, int_2, d):
  
  si1=str(int_1); si2=str(int_2) # For debug purpose
  
  if int_1<=int_2:
    tpl=(int_1,int_2)
  else:
    tpl=(int_2,int_1)
  
  if tpl not in d:
     if (int_2 and int_1) == 0:
         d[tpl]=0
     else:
         d[tpl] = int_1 + multiplication(int_1, int_2 - 1,d)
         print (""DEBUG: Saved {} Ã— {} = {}"".format(si1,si2,str(d[tpl])))
  else:
     print (""DEBUG: Found {} Ã— {} = {}"".format(si1,si2,str(d[tpl])))
  
  return d[tpl]


# Test cases
solution_dict=dict()
print(test_multiplication(1, 8, solution_dict, 8)) 
print(test_multiplication(3, 7, solution_dict, 21))
print(test_multiplication(4, 5, solution_dict, 20))
print(test_multiplication(5, 4, solution_dict, 20))
print(test_multiplication(7, 3, solution_dict, 21))

print(test_multiplication(7, 5, solution_dict, 35))

print(test_multiplication(0, 6, solution_dict, 0))
print(test_multiplication(6, 0, solution_dict, 0))


```",2020-11-23T21:13:01+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",yunglong28,"```
def dyn_mul(int1, int2, dict1):
    factors = (int1, int2)
    if int1 == 0 or int2 == 0:  # base case 1
        dict1[factors] = 0
        return 0
    elif factors in dict1:  # base case 2
        return ('Already stored')
    else:
        dict1[factors] = int1 + dyn_mul(int1, int2 - 1, dict1)
    return dict1.get(factors)

def test_dyn_mul(int1, int2, dict1, expected):
    result = dyn_mul(int1, int2, dict1)
    if expected == result:
        return True
    else:
        return False

dictio2={}
print(test_dyn_mul (4, 2, dictio2, 8))  #True
print(test_dyn_mul(4, 2, dictio2, 'Already stored'))  #True
print(test_dyn_mul(-2, 3, dictio2, -6))  #True
print(test_dyn_mul(5, 6, dictio2, 30))  #True
```",2020-11-24T12:46:21+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",giorgiasampo,"
````
def test_multiplication(int_1, int_2, solution_dict, expected):
    result = multiplication(int_1, int_2, solution_dict)
    return result==expected

def multiplication(int_1, int_2, solution_dict):
    if int_2 == 0:
        solution_dict[int_2]=0
    else:
        solution_dict[int_2] = int_1 + multiplication(int_1, int_2 - 1,solution_dict)
    return solution_dict[int_2]

print(test_multiplication(5,4,dict(), 20))
print(test_multiplication(0,4,dict(), 0))
print(test_multiplication(5,0,dict(), 0))

````",2020-11-24T15:42:38+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",ChiaraCati,"```
def test_multiplication(int_1, int_2, solution_dict, expected):
    result = multiplication(int_1, int_2, solution_dict)
    if result == expected:
        return True
    else:
        return False


def multiplication(int_1, int_2, solution_dict):
    if int_2 == 0 or int_1 == 0:
        solution_dict[int_2] = 0

    else:
        solution_dict[int_2] = int_1 + multiplication(int_1, int_2 - 1, solution_dict)

    return solution_dict.get(int_2)


print(test_multiplication(3, 2, dict(), 6))
print(test_multiplication(-3, 2, dict(), -6))
print(test_multiplication(0, 5, dict(), 0))
print(test_multiplication(9, 0, dict(), 0))

```",2020-11-24T17:28:28+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",GiuliaMenna,"```
def test_multiplication(int1, int2, solution_dict, expected):
    result = multiplication(int1, int2, solution_dict)
    if expected == result:
        return True
    else:
        return False

def multiplication(int1, int2, solution_dict):
    if (int1, int2) not in solution_dict:
        if int1 == 0 or int2 == 0:
            return 0
        else:
            solution_dict[(int1,int2)] = int1 + multiplication(int1, int2 -1, solution_dict)
    return solution_dict.get((int1, int2))


print(test_multiplication(2,3,{},6))
print(test_multiplication(7,5,{},35))
print(test_multiplication(0,1,{},0))
```",2020-11-24T17:29:03+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",LuisAmmi,"```
def test_multiplication(int1, int2, dictionary, expected):
    result = multiplication(int1, int2, dictionary)
    if result == expected:
        return True
    else:
        return False

def multiplication(int1, int2, dictionary):
    if (int1, int2) not in dictionary:
        if int1 == 0 or int2 == 0: # base case 1
            dictionary[(int1, int2)] = 0
        else:
            dictionary[(int1, int2)] = int1 + multiplication(int1, int2 - 1, dictionary)
    return dictionary.get((int1, int2))

print(test_multiplication(3,0,{},0))  # True
print(test_multiplication(9,3,{}, 27)) # True
print(test_multiplication(7,6,{}, 42)) # True",2020-11-24T17:29:30+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",AleRosae,"```
def multiplication (int_1, int_2, solution_dict):
    if int_1 not in solution_dict:
        if int_2 == 0 or int_1 == 0:
            solution_dict[int_1] = 0
        elif int_1 == 1:
            solution_dict[int_1] = int_2
        else:
            solution_dict[int_1] = int_1 + multiplication(int_1, int_2 - 1, solution_dict)

    return solution_dict.get(int_1)

def test_multiplication (int_1, int_2, solution_dict, expected):
    return multiplication(int_1, int_2, solution_dict) == expected


print(test_multiplication(4,4,dict(), 16))
print(test_multiplication(3,5,dict(), 15))
print(test_multiplication(3,1,dict(), 3))
print(test_multiplication(214566,0,dict(), 0))
```",2020-11-24T17:34:22+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",gabrielefiorenza,"```
def test_multiplication(int_1,int_2,solution_dict,expected):
    result = multiplication(int_1,int_2,solution_dict)
    return result== expected

def multiplication(int_1, int_2,solution_dict):
    if (int_1,int_2) not in solution_dict:
        if int_2 == 0:
            solution_dict[(int_1, int_2)]=0
        else:
            solution_dict[(int_1, int_2)] = int_1 + multiplication(int_1, int_2 - 1,solution_dict)
    return solution_dict.get((int_1,int_2))

print(test_multiplication(4,7,dict(),28)) #it returns True
```",2020-11-24T23:02:26+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",AlessandroBertozzi,"I think this kind of programming approach is inefficient for this alghoritm. I don't reuse any element which I previously memorized in my dictionary.
![Nuovo Presentazione di Microsoft PowerPoint](https://user-images.githubusercontent.com/72964241/100165633-0b671880-2ebb-11eb-8a4a-321ecce735de.jpg)
",2020-11-25T00:31:15+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",diegochillo,"> 
> 
> > I think this kind of programming approach is inefficient for this alghoritm. I don't reuse any element which I previously memorized in my dictionary.
> > ![Nuovo Presentazione di Microsoft PowerPoint](https://user-images.githubusercontent.com/72964241/100165633-0b671880-2ebb-11eb-8a4a-321ecce735de.jpg)
> 
> It's efficient if you use **the same dictionary** for successive calls of the function: if after calculating 3x4 and storing the result in the dictionary, you call the function to calculate 3x9, the function will be faster because it'll find the solution of 3x4 in the dictionary and will not have to do again the recursions from 3x4 to 3x1.

",2020-11-25T10:01:50+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",AlessandroBertozzi,"> > > I think this kind of programming approach is inefficient for this alghoritm. I don't reuse any element which I previously memorized in my dictionary.
> > > ![Nuovo Presentazione di Microsoft PowerPoint](https://user-images.githubusercontent.com/72964241/100165633-0b671880-2ebb-11eb-8a4a-321ecce735de.jpg)
> > 
> > 
> > It's efficient if you use **the same dictionary** for successive calls of the function: if after calculating 3x4 and storing the result in the dictionary, you call the function to calculate 3x9, the function will be faster because it'll find the solution of 3x4 in the dictionary and will not have to do again the recursions from 3x4 to 3x1.

Yes, exactly. It is useful if you define a dictionary which is external to the function. Maybe another problem is that you can reuse the dictionary only with the same integer (int_1).",2020-11-25T14:26:44+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",diegochillo,"> 
> 
> > > > I think this kind of programming approach is inefficient for this alghoritm. I don't reuse any element which I previously memorized in my dictionary.
> > > > ![Nuovo Presentazione di Microsoft PowerPoint](https://user-images.githubusercontent.com/72964241/100165633-0b671880-2ebb-11eb-8a4a-321ecce735de.jpg)
> > > 
> > > 
> > > It's efficient if you use **the same dictionary** for successive calls of the function: if after calculating 3x4 and storing the result in the dictionary, you call the function to calculate 3x9, the function will be faster because it'll find the solution of 3x4 in the dictionary and will not have to do again the recursions from 3x4 to 3x1.
> 
> Yes, exactly. It is useful if you define a dictionary which is external to the function. Maybe another problem is that you can reuse the dictionary only with the same integer (int_1).

But if the key of your dictionary is the couple of factors (as a tuple), and if you always sort the couple in the same way before adding it to the dictionary and before looking for it, it's not important if the number you are reusing is int_1 or int_2.",2020-11-25T15:14:27+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",fcagnola,"```
d = dict()  # this dictionary will store the results of the multiplications in this form {""int1Xint2"":result}

def multiplication(int_1, int_2, solutions):

    if str(int_1)+""X""+str(int_2) in solutions:  # base case: result is in the dict, either ""int1Xint2"" or ""int2Xint1""
        return solutions[str(int_1)+""X""+str(int_2)]
    elif str(int_2)+""X""+str(int_1) in solutions:
        return solutions[str(int_2)+""X""+str(int_1)]

    else:
        if int_2 == 0:  # base case for the recursion, if the number is multiplied by 0, add result to dict and return 0
            solutions[str(int_1) + ""X"" + str(int_2)] = 0
            return 0
        else:  # otherwise compute the solution recursively, store it in the dictionary and return that entry
            solutions[str(int_1) + ""X"" + str(int_2)] = int_1 + multiplication(int_1, int_2 - 1, solutions)
            return solutions[str(int_1) + ""X"" + str(int_2)]

# test case, in this function I thought it would be useful to use many numbers in order to see the efficiency in action.
# printing the dict after computing all the results show how many computations have not been calculated twice thanks 
# to the dynamic programming approach
for one in [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]: 
    for two in [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]:
        print(multiplication(one, two, d))

print(d)
```",2020-11-25T16:36:33+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",AlessandroBertozzi,"> > > > > I think this kind of programming approach is inefficient for this alghoritm. I don't reuse any element which I previously memorized in my dictionary.
> > > > > ![Nuovo Presentazione di Microsoft PowerPoint](https://user-images.githubusercontent.com/72964241/100165633-0b671880-2ebb-11eb-8a4a-321ecce735de.jpg)
> > > > 
> > > > 
> > > > It's efficient if you use **the same dictionary** for successive calls of the function: if after calculating 3x4 and storing the result in the dictionary, you call the function to calculate 3x9, the function will be faster because it'll find the solution of 3x4 in the dictionary and will not have to do again the recursions from 3x4 to 3x1.
> > 
> > 
> > Yes, exactly. It is useful if you define a dictionary which is external to the function. Maybe another problem is that you can reuse the dictionary only with the same integer (int_1).
> 
> But if the key of your dictionary is the couple of factors (as a tuple), and if you always sort the couple in the same way before adding it to the dictionary and before looking for it, it's not important if the number you are reusing is int_1 or int_2.

Yeah, sorting can be a good solution for this problem.",2020-11-25T16:45:17+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",AlessandroBertozzi,"> ```
> d = dict()  # this dictionary will store the results of the multiplications in this form {""int1Xint2"":result}
> 
> def multiplication(int_1, int_2, solutions):
> 
>     if str(int_1)+""X""+str(int_2) in solutions:  # base case: result is in the dict, either ""int1Xint2"" or ""int2Xint1""
>         return solutions[str(int_1)+""X""+str(int_2)]
>     elif str(int_2)+""X""+str(int_1) in solutions:
>         return solutions[str(int_2)+""X""+str(int_1)]
> 
>     else:
>         if int_2 == 0:  # base case for the recursion, if the number is multiplied by 0, add result to dict and return 0
>             solutions[str(int_1) + ""X"" + str(int_2)] = 0
>             return 0
>         else:  # otherwise compute the solution recursively, store it in the dictionary and return that entry
>             solutions[str(int_1) + ""X"" + str(int_2)] = int_1 + multiplication(int_1, int_2 - 1, solutions)
>             return solutions[str(int_1) + ""X"" + str(int_2)]
> 
> # test case, in this function I thought it would be useful to use many numbers in order to see the efficiency in action.
> # printing the dict after computing all the results show how many computations have not been calculated twice thanks 
> # to the dynamic programming approach
> for one in [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]: 
>     for two in [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]:
>         print(multiplication(one, two, d))
> 
> print(d)
> ```
![Risposta fede github](https://user-images.githubusercontent.com/72964241/100356266-45d3d100-2ff3-11eb-8217-252d0b16e3be.png)
Yeah, in your case the function saved 45 passages. But if i change the number which are not very similar, the problem remain. More times you use this function with an external dict, more possibilites you have to save passages in the future multiplication.
",2020-11-26T13:32:07+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",AlessandraFa,"```
def test_multiplication(int_1, int_2, solution_dict, expected):
    result = multiplication(int_1, int_2, solution_dict)
    return result == expected


def multiplication(int_1, int_2, solution_dict):
    if int_1 >= int_2:
        mykey = (int_1, int_2)
    else:
        mykey = (int_2, int_1)
    if mykey not in solution_dict:
        if int_1 == 0 or int_2 == 0:
            solution_dict[mykey] = 0
        else:
            solution_dict[mykey] = int_1 + multiplication(int_1, int_2 - 1, solution_dict)
    return solution_dict.get(mykey)


my_dict = {}

print(test_multiplication(0, 0, my_dict, 0))
print(test_multiplication(12, 6, my_dict, 72))
print(test_multiplication(7, 5, my_dict, 35))
print(test_multiplication(5, 7, my_dict, 35))
print(test_multiplication(3, 7, my_dict, 21))
print(test_multiplication(3, 8, my_dict, 24))
print(test_multiplication(3, 3, my_dict, 9))
```",2020-11-26T21:04:41+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",SofiBar,"```
def test_multiplication_dp(int_1, int_2, dic, expected):
    if multiplication_dp(int_1, int_2, dic) == expected:
        return True
    else:
        return False

def multiplication_dp(int_1, int_2, dic):
    k = (int_1, int_2)

    if int_2 < 0:
        return ""parameter not valid""


    if k not in dic:
        if int_2 == 0:
            dic[k] = 0
        elif int_2 == 1:
            dic[k] = int_1
        else:
            dic[k] = int_1 + multiplication_dp(int_1, int_2 - 1, dic)
        return dic.get(k)

dict_n = {}
print(test_multiplication_dp(3, 4, dict_n, 12))
print(test_multiplication_dp(-3, 4, dict_n, -12))
print(test_multiplication_dp(-3, -4, dict_n, ""parameter not valid""))
print(test_multiplication_dp(0, 1, dict_n, 0))
```",2020-11-26T21:25:41+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",essepuntato,"@dbrembilla, just a suggestion: remind that the multiplication is commutative (i.e. `n1 * n2 == n2 * n1`), which means that if you already computed the solution of `n1 * n2`, then you have also the solution for `n2 * n1`.

About @yunglong28's code:

> return ('Already stored')

You should return the value, not `""Already stored""`.

**For all** (in case you did not do it): try to create just one dictionary before running the tests and then passing every time that dictionary as input of your executions. Does it work always as expected?

",2020-11-27T10:28:50+00:00
comp-think/2020-2021,"Lecture ""Dynamic programming algorithms"", exercise 1",IlaRoss,"```
# Test case for the algorithm
def test_multiplication(int_1, int_2, solution_dict, expected):
    result = multiplication(int_1, int_2, solution_dict)
    if expected == result:
        return True
    else:
        return False

# Algorithm
def multiplication(int_1, int_2, solution_dict):
    if int_1 == 0 or int_2 == 0:
        return 0

    if int_1 > int_2:
        mymult = [int_2, int_1]
        akey = tuple(mymult)
    else:
        mymult = [int_1, int_2]
        akey = tuple(mymult)

    if (akey) in solution_dict.keys():
        return solution_dict[akey]
    else:
        if mymult[1] == 0:
            return 0
        else:
            result = mymult[0] + multiplication(mymult[0], mymult[1]-1, solution_dict)
            mykey = tuple(mymult)
            solution_dict[(mykey)] = result

        return solution_dict[(mykey)]

# Some test runs
adict = {}
print(test_multiplication(3, 5, adict, 15))
print(test_multiplication(4, 4, adict, 16))
print(test_multiplication(3, 4, adict, 12))
print(test_multiplication(7, 6, adict, 42))
print(test_multiplication(0, 0, adict, 0))
print(test_multiplication(0, 3, adict, 0))
print(test_multiplication(6, 7, adict, 42))
print(test_multiplication(7, 5, adict, 35))

# print(adict)
```",2020-11-29T22:05:13+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 3",diegochillo,"```
def test_quicksort(input_list, start, end, expected):
    result = quicksort(input_list, start, end)
    return input_list == expected


def partition(input_list,start,end,pivot_position):
  
    outbefore = []
    outafter = []
    before = []
    after = []
    newindex = 0

    pivot_e=input_list[pivot_position]
    i=0

    for i in range(len(input_list)):

        if i<start:
           outbefore.append(input_list[i])
        elif i>end:
           outafter.append(input_list[i])
        else:
            if input_list[i]<pivot_e:
               before.append(input_list[i])
            elif input_list[i]>pivot_e:
               after.append(input_list[i])
               
    input_list.clear()
    
    input_list.extend(outbefore)
    input_list.extend(before)
    input_list.append(pivot_e)
    input_list.extend(after)
    input_list.extend(outafter)
    
    newindex=len(outbefore)+len(before)
    return newindex


def quicksort(input_list, start, end):
    # print(""DEBUG start:"" + str(start))
    # print(""DEBUG end:"" + str(end))

    diff = end - start

    if diff <= 0:
        # print(""DEBUG list "" + str(input_list))
        return 1
    else:
        position = partition(input_list, start, end, start)
        # print(""DEBUG arranged "" + str(input_list[position]))
        return quicksort(input_list, start, position-1) + quicksort(input_list, position + 1, end)


# Test cases
print (test_quicksort([7,2,4,1,8,6,3,5,9],0,8,[1, 2, 3, 4, 5, 6, 7, 8, 9]))
print (test_quicksort([""y"",""m"",""t"",""r"",""o""],0,4,[""m"", ""o"", ""r"", ""t"", ""y""]))
print (test_quicksort([],0,0,[]))
# Test case with working range shorter than the whole list:
print (test_quicksort([7,3,5,23,11,13,2,29,17,19],3,8,[7,3,5,2,11,13,17,23,29,19]))

```",2020-11-22T13:49:03+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 3",AlessandraFa,"```
def partition(input_list, start, end, pivot_position):
    list_temp = []
    pivot = input_list[pivot_position]
    position = 0
    for item in input_list[start:end]:
        if item < pivot:
            list_temp.insert(position, item)
            position += 1
        elif item > pivot:
            list_temp.append(item)
    list_temp.insert(position, pivot)
    input_list[start:end] = list_temp
    return input_list, position + start


def test_quicksort(input_list, start, end, expected):
    result = quicksort(input_list, start, end)
    return result == expected


def quicksort(input_list, start, end):
    if start < end:
        new_list, piv_pos = partition(input_list, start, end, start)
        quicksort(new_list, start, piv_pos)
        quicksort(new_list, piv_pos + 1, end)
        return new_list


print(test_quicksort([1,5,8,7,3,9,2,11], 0, 8, [1, 2, 3, 5, 7, 8, 9, 11]))
print(test_quicksort([""f"",""n"",""e"",""d"",""a"",""m""], 1, 5, [""f"",""a"",""d"",""e"",""n"",""m""]))
```",2020-11-22T23:49:01+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 3",fcagnola,"Nuntio vobis magno gaudio, I got to a working quicksort algorithm.
I kept getting problems but I finally (took me several days) squashed all bugs and what follows works like a charm
```
def swap(list, old_idx, new_idx):
    tmp = list[old_idx]
    list[old_idx] = list[new_idx]
    list[new_idx] = tmp


def partition(input_list, first_elem, last_elem, pivot_position):

    idx = first_elem - 1  # counter for elements smaller than pivot
    compare = first_elem  # selects element to be compared and, in case, swapped with idx

    pivot = input_list.pop(pivot_position)
    # remove the pivot from the list, in order for it not to be moved while re-arranging the list in place

    for i in range(first_elem, last_elem):  # loops through list from start to end, but
        # the list is actually shorter since the pivot was removed through the pop() operation

        if input_list[compare] >= pivot:  # if element is >= pivot, do nothing and compare the next

            compare += 1

        elif input_list[compare] < pivot:  # if element <pivot switch places to idx and compare

            idx += 1

            swap(input_list, compare, idx)

            compare += 1

    input_list.insert(idx+1, pivot)
    # the last step before returning the index of the pivot actually re-inserting the pivot at its correct index
    # print(""debug: input list {}"".format(input_list))
    return idx+1



def quicksort(input_list, start, end):
    length = len(input_list[start:end+1]) # compute list length in order to check base case

    if length <= 1:  # base case, if the list passed as input is len<=1 return the list itself
        return input_list

    else:
        pvt = (start+end) // 2

        pivot_pos = partition(input_list, start, end, pvt)  # pivot_pos stores the right position of the pivot value

        quicksort(input_list, start, pivot_pos-1)

        quicksort(input_list, pivot_pos+1, end)

    return input_list


list_a = [7, 2, 1, 8, 6, 3, 5, 4]
list_b = [3, 6, 7, 9, 12, 8, 23, 15, 83, 24, 16]
list_c = [0, 17, 34, 51, 68, 0, 21, 42, 63, 84, 105, 126]

print(quicksort(list_a, 0, 7))  # returns [1, 2, 3, 4, 5, 6, 7, 8]
print(quicksort(list_b, 0, 10))  # returns [3, 6, 7, 8, 9, 12, 15, 16, 23, 24, 83]
print(quicksort(list_c, 0, 11))  # returns [0, 0, 17, 21, 34, 42, 51, 63, 68, 84, 105, 126]
```",2020-11-24T18:49:08+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 3",edoardodalborgo,"```
def test_quicksort(input_list, start, end, expected):
    return quicksort(input_list, start, end) == expected

def substitution(i, j, input_list):
    i += 1
    input_list.insert(i, input_list[j])
    del input_list[j + 1]
    j += 1
    return input_list, i, j

def partition(input_list, start, end, pivot):
    j, f, i = start, end, start - 1
    pivot_value = input_list[pivot]
    while j <= f:
        if j < pivot:
            if input_list[j] < pivot_value:
                input_list, i, j = substitution(i, j, input_list)
            else:
                j += 1
        else:  
            if input_list[j] >= pivot_value:
                j += 1
            else:
                input_list, i, j = substitution(i, j, input_list)
    return input_list.index(input_list[i + 1])


def quicksort(input_list, start, end):
    if len(input_list[start:end+1]) > 1:
        pivot_index = partition(input_list, start, end, start)
        quicksort(input_list, start, pivot_index-1)
        quicksort(input_list, pivot_index+1, end)
        return input_list
    else:
        return input_list


print(test_quicksort([1, 4, 2, 65, 99, 32, 13, 14], 0, 7, [1, 2, 4, 13, 14, 32, 65, 99]))
print(test_quicksort([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""Coraline"", ""Good Omens"", ""American Gods""], 1, 6, ['The Graveyard Book', 'American Gods', 'Coraline', 'Coraline', 'Good Omens', 'Good Omens', 'Neverwhere']))
print(test_quicksort([""The Graveyard Book"", ""Coraline"", ""Good Omens"", ""Neverwhere"", ""The Graveyard Book"", ""Neverwhere"", ""American Gods""], 0, 6, ['American Gods', 'Coraline', 'Good Omens', 'Neverwhere', 'Neverwhere', 'The Graveyard Book', 'The Graveyard Book']))

```",2020-11-27T09:08:41+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 3",IlaRoss,"```
# from partition import  partition (copied the function here instead)

# test
def test_quicksort(input_list, start, end, expected):
    result = quicksort(input_list, start, end)
    if result == expected:
        return True
    else:
        return False

# algorithm
def partition(input_list, start, end, pivot_value):
    if start < 0 or start > len(input_list) - 1 or end > len(input_list) - 1:
        return 'start or end outta range'
    if start > end:
        return 'start cannot be greater than end'
    if pivot_value < start or pivot_value > end:
        return 'pivot must be included between start and end'
    else:
        pivot_el = input_list[pivot_value]
        i = start - 1
        k = start
        while (k >= start) and (k <= end):
            if input_list[k] >= pivot_el:
                k += 1
            elif input_list[k] < pivot_el:
                i += 1
                local_variable = input_list[i]
                input_list[i] = input_list[k]
                input_list[k] = local_variable
                k += 1
        copy_pivot = pivot_el
        input_list.remove(pivot_el)
        input_list.insert(i + 1, copy_pivot)
        newpivot = input_list.index(copy_pivot)
        return newpivot

def quicksort(input_list, start, end):
    if start < 0 or start > len(input_list) - 1 or end > len(input_list) - 1:
        return 'start or end outta range'
    if start > end:
        return 'start cannot be greater than end'

    else:
        newpiv = partition(input_list, start, end, start)

        # base case
        if (len(input_list[start:newpiv]) == 1) and (len(input_list[newpiv+1:end]) == 1):
            return input_list
        else:
            quicksort(input_list, start, newpiv-1)
            quicksort(input_list, newpiv+1, end)
            return input_list


# some test runs
provalist = ['z', 'c', 'g', 'b', 'f', 'm', 'e', 'a']
print(test_quicksort(provalist, 1, 6, ['z', 'b', 'c', 'e', 'f', 'g', 'm', 'a']))
unalist = [6, 3, 8, 1, 7, 9, 5]
print(test_quicksort(unalist, 2, 6, [6, 3, 1, 5, 7, 8, 9]))
alist = ['g', 'c', 'e', 'd', 'a', 'f', 'b']
print(test_quicksort(alist, 5, 3, 'start cannot be greater than end'))
blist = [3, 7, 5, 4, 1, 6, 2]
print(test_quicksort(blist, 2, 7, 'start or end outta range'))
```",2020-11-29T21:59:47+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",diegochillo,"The partition function has to return the new pivot position and reorganize the content of input_list, so I check both objects in the test_partition function.
I watched Ang's video after doing the exercise. That's why I get the result in a more naive way.

```
def test_partition(input_list,start,end,pivot_position,expected,expected_list):
    result=partition(input_list,start,end,pivot_position)
    return result==expected and input_list==expected_list


def partition(input_list,start,end,pivot_position):
  
    outbefore = list()
    outafter = list()
    before = list()
    after = list()
    newindex = 0

    pivot_e=input_list[pivot_position]
    i=0

    for i in range(len(input_list)):

        if i<start:
           outbefore.append(input_list[i])
        elif i>end:
           outafter.append(input_list[i])
        else:
            if input_list[i]<pivot_e:
               before.append(input_list[i])
            elif input_list[i]>pivot_e:
               after.append(input_list[i])
               
    input_list.clear()
    
    input_list.extend(outbefore)
    input_list.extend(before)
    input_list.append(pivot_e)
    input_list.extend(after)
    input_list.extend(outafter)
    
    newindex=len(outbefore)+len(before)
    #print(""DEBUG newindex=""+str(newindex))
    return newindex
    
    
print(test_partition ([""Rick"",""Morty"",""Beth"",""Summer"",""Mr. Poopybutthole"",""Jerry""],1,5,3,5,[""Rick"",""Morty"",""Beth"",""Mr. Poopybutthole"",""Jerry"",""Summer""]))
print (test_partition ([""Birdperson"",""Mr. Meeseeks"",""Evil Morty"",""Squanchy"",""Gazorpazorpfield"",""Pickle Rick""],0,3,2,1,[""Birdperson"",""Evil Morty"",""Mr. Meeseeks"",""Squanchy"",""Gazorpazorpfield"",""Pickle Rick""]))
print(test_partition([4,9,22,3,7,8,43,12,100,65],2,7,7,5,[4,9,3,7,8,12,22,43,100,65]))
```",2020-11-21T18:02:39+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",fcagnola,"_EDIT_: after reviewing the code, my original solution had two problems. Following Bruno's advice I first changed the return statement to return what the exercise actually requested: the index of the pivot (and not the list). Also, I noticed that while modifying the list in place the pivot position was changing, and I was actually comparing a static pivot position, ultimately resulting in weird outputs. I solved these problems and what follows should work:
```
def swap(list, old_idx, new_idx):
    tmp = list[old_idx]
    list[old_idx] = list[new_idx]
    list[new_idx] = tmp


def partition(input_list, first_elem, last_elem, pivot_position):

    idx = first_elem - 1  # counter for elements smaller than pivot
    compare = first_elem  # selects element to be compared and, in case, swapped with idx

    pivot = input_list.pop(pivot_position)
    # remove the pivot from the list, in order for it not to be moved while re-arranging the list in place

    for i in range(first_elem, last_elem):  # loops through list from start to end, but
        # the list is actually shorter since the pivot was removed through the pop() operation

        if input_list[compare] >= pivot:  # if element is >= pivot, do nothing and compare the next

            compare += 1

        elif input_list[compare] < pivot:  # if element <pivot switch places to idx and compare

            idx += 1

            swap(input_list, compare, idx)

            compare += 1

    input_list.insert(idx+1, pivot)
    # the last step before returning the index of the pivot actually re-inserting the pivot at its correct index
    # print(""debug: input list {}"".format(input_list))
    return idx+1

list_a = [7, 2, 1, 8, 6, 3, 5, 4]
list_b = [3, 6, 7, 9, 12, 8, 23, 15, 83, 24, 16]
list_c = [0, 17, 34, 51, 68, 0, 21, 42, 63, 84, 105, 126]
list_d = [""g"", ""a"", ""d"", ""e"", ""f"", ""b"", ""c"", ""h""]
print(partition(list_a, 0, 7, 6))  # returns True
print(partition(list_b, 0, 10, 7))  # returns True
print(partition(list_c, 0, 12, 8))  # returns True
print(partition(list_d, 0, 8, 3))  # returns True
```",2020-11-22T11:55:12+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",giorgiasampo,"````
def test_partition(input_list, start, end, pivot_position, expected):
  result = partition(input_list, start, end, pivot_position)
  return result == expected

def partition(input_list, start, end, pivot_position):
    work_list = input_list[start:end+1]
    pivot_value = input_list[pivot_position]
    left_list = list()
    right_list = list()
    right_list.append(pivot_value)
    result = input_list[:start]
    for item in work_list:
        if item < pivot_value:
            left_list.append(item)
        elif item != pivot_value:
            right_list.append(item)
    result.extend(left_list)
    result.extend(right_list)
    result.extend(input_list[end+1:])
    return result, result.index(pivot_value)

print(test_partition([0,1,2,3,4,5,6,7,8,9], 2, 5, 3,([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 3)))
print(test_partition(['b','c','e','a','z','f','o','n'], 2, 7, 6,(['b', 'c', 'e', 'a', 'f', 'o', 'n', 'z'], 5)))

````",2020-11-22T15:43:23+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",SarahTew,"In working on this problem I ran into some weird questions for @essepuntato.

1) Why doesn't my numbers example (taken directly from the KC Ang video) end up in the same exact order as the video? Even thought it is correct it is not what I expected.

2) In my code with my alphabet example, if I leave off the 'or equal to' sign in my code, it doesn't work for the last letter in my list, ""b"". It doesn't go in the right place. When I have the 'or equal to"" sign in the code, it works fine, but there are no repeat values in the list anyway so I don't understand why it is relevant and messing with the result in this particular case. 

```
def partition(input_list, start, end, pivot_position):
    pivot_item = input_list[pivot_position]
    i = start - 1
    j = start

    for element in range(len(input_list[start:end+1])):
        
        if input_list[j] >= input_list[pivot_position]:
            j = j + 1
#if you remove the ""="" from the above if statement, it doesn't work. Why not? Switch it out for the if statement below to see what happens. (See example with list ""alphabet"")
        #if input_list[j] > input_list[pivot_position]:
        elif input_list[j] < input_list[pivot_position]:
            i += 1
            input_list [i], input_list[j] = input_list[j], input_list[i] 
            j += 1
        
  
    input_list[i+1], input_list[pivot_position] = input_list[pivot_position], input_list[i+1]
    print(input_list)
    return input_list.index(pivot_item)
    
    
    
numbers=[7, 2, 1, 8, 6, 3, 5, 4]
alphabet=[""e"",""a"",""g"", ""c"", ""d"", ""f"", ""b""]
print(partition(numbers, 0, 7, 7))
print (partition(alphabet, 0, 6, 4))  
````

For numbers it prints: [2, 1, 3, 4, 6, 7, 5, 8]
For alphabet it prints: ['a', 'c', 'b', 'd', 'e', 'f', 'g']
For alphabet without the 'or equal to' in the code it prints ['a', 'c', 'd', 'e', 'g', 'f', 'b']",2020-11-22T17:05:22+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",gabrielefiorenza,"```

def test_partition(input_list, start, end, pivot_position,expected):
    result = partition(input_list, start, end, pivot_position)
    return expected==result

def partition(input_list,start,end,pivot_position):
    i=start-1
    j=start
    pivot= input_list[pivot_position]
    input_list.pop(pivot_position)
    for e in range(len(input_list[start:end+1])):
        if input_list[j]>=pivot:
            j+=1
        elif input_list[j]<pivot:
            i+=1
            input_list[j], input_list[i]=input_list[i],input_list[j]
            j+=1
    input_list.insert(i + 1,pivot)
    return(i+1)

my_list = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""])
print(test_partition(my_list, 1, 4, 1,2))
```",2020-11-22T17:53:12+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",SarahTew,"I tried make a new partition function that worked by actually dividing the list and I came up with one that sort of works. 

Instead of returning all the elements in a single list, it returns them in a series of sublists. I kind of like it better because it's easier to see what was included within the start and end range and what was outside of the range. 

BUT since it is done this way, you can't get the index of the pivot since it's not actually a list of elements 

The other weird thing is that even though I've put the pivot element in it's own list, it doesn't become a sublist in the final list. I don't know why this one gets added as a element to the previous list and not its own sublist. (The reason I made the pivot element into a list in the first place is because I kept getting an error about mixing lists and elements when trying to add them my final list.)

To be honest, I don't really understand why it's adding them as sublists. I have tried concatenation, .extend, .append and I can't get it just be a normal list (unless the range is the entire list to begin with) What is happening here?

```
def partition(input_list, start, end, pivot_position):
    smaller = []
    larger = []
    left_of_start = [input_list[:start]]
    right_of_end = [input_list[end + 1:]]
    pivot_element_list = [input_list[pivot_position]]
    pivot_element=input_list[pivot_position]
    final_list = []
    j = start
    for element in range(len(input_list[start:end+1])):
        if input_list[j] > input_list[pivot_position]:
            larger.append(input_list[j])
            j += 1
        elif input_list[j]< input_list[pivot_position]:
            smaller.append(input_list[j])
            j += 1
    if start != 0:
        final_list.extend(left_of_start)
    final_list.extend(smaller)
    final_list.extend(pivot_element_list)
    final_list.extend(larger)
    if end+1 != len(input_list):
        final_list.extend(right_of_end)
    index = final_list.index(pivot_element)
    return final_list
numbers=[7, 2, 1, 8, 6, 3, 5, 4]
print(partition(numbers, 1, 4, 3))
print(partition(numbers, 0, 7, 7))
````

1st print (with narrow range) will print [[7], 2, 1, 8, [3, 5, 4]]
2nd print (range includes all items in list) will print: [2, 1, 3, 4, 7, 8, 6, 5]

",2020-11-22T18:38:08+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",vanessabonanno,"```
items_list = [10, 11, 13, 14, 16, 18, 19, 15, 17]
my_pivot_position = 4
my_start = 0
my_end = 8


def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if result == expected:
        return True
    else:
        return False


def partition(input_list, start, end, pivot_position):
    # check if it is a valid list:
    if start > end:
        return ""Wrong input list!""

    i = start - 1
    j = start
    pivot = input_list.pop(pivot_position)

    for element in items_list:
        if element > pivot:
            j += 1
        elif element < pivot:
            i += 1
            input_list[i], input_list[j] = input_list[j], input_list[i]
            j += 1
    items_list.insert(i+1, pivot)
    return items_list 


print(partition(items_list, 3, 1, my_pivot_position))             # Wrong input list!
print(partition(items_list, my_start, my_end, my_pivot_position)) # [10, 11, 13, 14, 15, 16, 19, 18, 17]

# Tests:
print(test_partition(items_list, my_start, my_end, my_pivot_position, [10, 11, 13, 1, 15, 16, 19, 18, 17])) # False
print(test_partition(items_list, my_start, my_end, my_pivot_position, [10, 11, 13, 14, 15, 16, 19, 18, 17]))# True
print(test_partition(items_list, 5, 1, my_pivot_position, ""Wrong input list!""))                             # True
print(test_partition(items_list, my_start, my_end, my_pivot_position, 1.5))                                 # False
```",2020-11-22T19:00:26+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",SofiBar,"```
def test_partition(input_list, start, end, pivot_position, expected):
    if partition(input_list, start, end, pivot_position) == expected:
        return True


def partition(input_list, start, end, pivot_position):
    my_list = input_list[start:end]
    p = input_list[pivot_position]
    result_list = [p]
    new_pp = 0

    for item in my_list:
        if item > p:
            result_list.insert(new_pp + 1, item)
        if item < p:
            result_list.insert(new_pp, item)
            new_pp += 1
    del input_list[start:end]
    for item in reversed(result_list):
        input_list.insert(start, item)

    new_pp += start
    print(new_pp)
    return input_list


my_num_list = [8, 7, 3, 5, 2, 1, 9, 20, ]
b_list = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""])
print(test_partition(my_num_list, 1, 5, 3, [8, 3, 2, 5, 7, 1, 9, 20])) 
print(test_partition(b_list, 1, 5, 2, [""The Graveyard Book"", ""Coraline"", ""Good Omens"", ""American Gods"", ""Neverwhere""]))

```",2020-11-22T23:02:00+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",dbrembilla,"```
def partition(input_list, start, end, pivot_position):
    before_pivot=[]
    after_pivot=[]
    before=[]
    after=[]
    pivot = input_list[pivot_position]
    for i in input_list:
        idx=input_list.index(i)
        if idx < start:
            before_pivot.append(i)
        elif idx > end:
            after_pivot.append(i)
        else:
            if i < pivot:
                before.append(i)
            elif i > pivot:
                after.append(i)
    result = before_pivot+ before + [pivot] + after + after_pivot
    return result.index(pivot)
```",2020-11-22T23:43:27+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",AlessandraFa,"```
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    return result == expected


def partition(input_list, start, end, pivot_position):
    list_temp = []
    pivot = input_list[pivot_position]
    position = 0
    for item in input_list[start:end]:
        if item < pivot:
            list_temp.insert(position, item)
            position += 1
        elif item > pivot:
            list_temp.append(item)
    list_temp.insert(position, pivot)
    input_list[start:end] = list_temp
    return input_list, position + start


print(test_partition([1,5,8,7,3,9,2,11], 0, 7, 3, ([1, 5, 3, 2, 7, 8, 9, 11], 4)))
print(test_partition([""f"",""n"",""e"",""d"",""a"",""m""], 0, 5, 3, (['a', 'd', 'f', 'n', 'e', 'm'], 1)))
```",2020-11-22T23:44:34+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",AlessandroBertozzi,"```
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    return result == expected


def partition(input_list, start, end, pivot_position):
    my_list = input_list[start:end + 1]
    if len(input_list) == 1:
        return pivot_position
    left_list = []
    right_list = []
    for element in my_list:
        if element > my_list[pivot_position]:
            right_list.append(element)
        elif element < my_list[pivot_position]:
            left_list.append(element)
        elif element == my_list[pivot_position]:
            pass
    position_pivot = len(left_list)
    left_list.append(my_list[pivot_position])
    my_list = left_list.extend(right_list)
    return position_pivot + start


print(test_partition([""The Graveyard Book"", ""American Gods"", ""Coraline"",
                      ""Neverwhere"", ""Good Omens""], 1, 4, 1, 2))
print(test_partition([1], 0, 1, 0, 0))
```",2020-11-23T01:23:25+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",LuisAmmi,"```
def partition(input_list, start, end, pivot_position):
    pivot_item = input_list[pivot_position]
    current_list = input_list[start:end+1]
    before_start = input_list[:start]
    after_end = input_list[end+1:]
    result = list()
    result.append(pivot_item)
    for i in current_list:
        if i != pivot_item:
            if i < pivot_item:
                result.insert(result.index(pivot_item), i)
            if i > pivot_item:
                result.insert(result.index(pivot_item) + 1, i)
    update_list = before_start + result + after_end
    return update_list.index(pivot_item)
    
my_list = list([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""American Gods""])
my_list2 = list([""Hola"", ""Ciao"", ""Amigo"", ""Salut"", ""Hello"", ""Hi""])
print(partition(my_list, 1, 4, 1))
print(partition(my_list2, 2, 6, 3))",2020-11-23T19:00:27+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",GiuliaMenna,"```
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if expected == result:
        return True
    else:
        return False


def partition(input_list, start, end, pivot_position):
    part_list = input_list[start:end + 1]
    pivot_value = input_list[pivot_position]
    left = []
    right = []

    if len(input_list) == 1:
        return pivot_position

    for item in part_list:
        if item < input_list[pivot_position]:
            left.append(item)
        if item == part_list[pivot_position]:
            pass
        if item > part_list[pivot_position]:
                right.append(item)

    position_pivot = len(left)
    left.append(part_list[pivot_position])
    input_list = left.extend(right)

    return position_pivot + start


list_ = [""sole"", ""luna"", ""abete"", ""alberi"", ""canzoni""]
print(test_partition(list_, 1, 4, 3, 2))
list_numbers = [7, 3, 1, 5, 24]
print(test_partition(list_numbers, 0, 4, 1, 1))
list__=[24]
print(test_partition(list__, 0, 1, 0, 0))
family_list= [""dario"",""gemma"",""emanuela"",""stefania"",""giulia""]
print(test_partition(family_list,0,4,1,2))
```",2020-11-24T09:17:10+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",yunglong28,"```
def test_partition (input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if result == expected:
        return True
    else:
        return False


def partition(input_list, start, end, pivot_position):
    if start > end or end >= len(input_list) or pivot_position >= len(input_list):
        return None  # to be safe
    outbefore = list()  #elements before start
    outafter = list()  #elements after end
    before = list()  #elements before the pivot
    after = list()  #elements after the pivot

    pivot_e = input_list[pivot_position]
    pivoter = 1  # count the elements equal to the pivot

    for i in range(len(input_list)):

        if i < start:
            outbefore.append(input_list[i])
        elif i > end:
            outafter.append(input_list[i])
        else:
            if input_list[i] < pivot_e:
                before.append(input_list[i])
            elif input_list[i] > pivot_e:
                after.append(input_list[i])
            else:
                pivoter += 1  #if there's an element = to the pivot

    input_list.clear()

    input_list.extend(outbefore)
    input_list.extend(before)
    # append as many elements to the center as the ones equal to the pivot element
    while pivoter > 0:
        input_list.append(pivot_e)
        pivoter -= 1
    input_list.extend(after)
    input_list.extend(outafter)

    newindex = len(outbefore) + len(before)
    return newindex



print(test_partition(['Mario', 'Luigi', 'Peach', 'Donkey Kong', 'Bowser Jr.'], 0, 4, 3, 1))  #True
print(test_partition([18,22,19,21,24,4], 0, 5, 0, 1))  #True
print(test_partition(['a', 'cc', 'bbb', 'ahahah', 'f'], 0, 4, 0, 0))  #True
```",2020-11-24T10:23:19+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",edoardodalborgo,"```
def test_partition(input_list, start, end, pivot, expected):
    return partition(input_list, start, end, pivot) == expected

def substitution(i, j, input_list):
    i += 1
    input_list.insert(i, input_list[j])
    del input_list[j + 1]
    j += 1
    return input_list, i, j

def partition(input_list, start, end, pivot):
    j, f, i = start, end, start - 1
    pivot_value = input_list[pivot]
    while j <= f:
        if j < pivot:
            if input_list[j] < pivot_value:
                input_list, i, j = substitution(i, j, input_list)
            else:
                j += 1
        else:  
            if input_list[j] >= pivot_value:
                j += 1
            else:
                input_list, i, j = substitution(i, j, input_list)
    return input_list.index(input_list[i + 1])

print(test_partition([""The Graveyard Book"", ""Coraline"", ""Neverwhere"", ""Good Omens"", ""Coraline"", ""Good Omens"", ""American Gods""], 0, 5, 3, 2))
print(test_partition([""The Graveyard Book"", ""Coraline"", ""Good Omens"", ""Neverwhere"", ""The Graveyard Book"", ""Neverwhere"", ""American Gods""], 0, 6, 5, 3))


```",2020-11-27T09:12:22+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",essepuntato,"About @SarahTew, @LuisAmmi and @dbrembilla's code:

> input_list.index(pivot_item)  # or similar

You should not use the `index` method to find the index of your pivot, but you should already know which is the index according to all the swaps you have done. 

@SarahTew, about the other comments, did you try to run your code using Python Tutor? I think that you seeing the behaviour of the execution of your algorithm visually can help you in correcting it.

**For all**: as introduced during a lecture, it would be better to modify the input list ""in place"" (as Ang does: without creating a new list). Please remind that you **must** return only the new index of the pivot. However, the execution of `partition` will also modify the input list by swapping its elements. This is entirely possible if you consider that lists in Python are mutable objects.",2020-11-27T10:11:31+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 2",IlaRoss,"I took seriously the ""please take your time, think about it"" advice @essepuntato!
I am posting the last 5 exercises just now, sorry for that. 
One question regarding partition (and, consequently, quicksort): should these work also when an element occurs more than once in the input_list? If this is the case I will correct my algorithm as it doesn't seem to work.
Thank You

```
# test
def test_partition(input_list, start, end, pivot_position, expected):
    result = partition(input_list, start, end, pivot_position)
    if result == expected:
        return True
    else:
        return False


# algo
def partition(input_list, start, end, pivot_value):
    if start < 0 or start > len(input_list) - 1 or end > len(input_list) - 1:
        return 'start or end outta range'
    if start > end:
        return 'start cannot be greater than end'
    if pivot_value < start or pivot_value > end:
        return 'pivot must be included between start and end'
    else:
        pivot_el = input_list[pivot_value]
        i = start - 1
        k = start
        while (k >= start) and (k <= end):
            if input_list[k] >= pivot_el:
                k += 1
            elif input_list[k] < pivot_el:
                i += 1
                local_variable = input_list[i]
                input_list[i] = input_list[k]
                input_list[k] = local_variable
                k += 1
        copy_pivot = pivot_el
        input_list.remove(pivot_el)
        input_list.insert(i + 1, copy_pivot)
        newpivot = input_list.index(copy_pivot)
        return newpivot


alist = ['g', 'c', 'e', 'd', 'a', 'f', 'b']
blist = [3, 7, 5, 4, 1, 6, 2]
mlist = ['Monteverdi C.', 'Gesualdo C.', 'Marenzio L.', 'Schein J.H.', 'Dowland J.', 'Willaert A.', 'Verdelot, P.',
         'Palestrina G.P.']

# test runs
print(test_partition(alist, 0, 5, 3, 2))
print(test_partition(blist, 1, 5, 4, 1))
print(test_partition(mlist, 2, 7, 7, 4))
print(test_partition(alist, 4, 2, 5, 'start cannot be greater than end'))
print(test_partition(blist, 3, 8, 5, 'start or end outta range'))
print(test_partition(blist, -3, 6, 3, 'start or end outta range'))
print(test_partition(mlist, 1, 4, 6, 'pivot must be included between start and end'))
```",2020-11-29T21:56:58+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",diegochillo,"I let a line I used to debug the procedure.

```
def binary_search(item,ordered_list,start,end):
  
  middle=(end+start)//2
  current=ordered_list[middle]
  
  # Debug:
  # print (""mid:"" + str(middle) + "" cur:"" + str(current) + "" start:"" + str(start) +"" end:"" + str(end))
  
  if current==item:
    return middle
  else:
    if end-start==0:
      return None
    elif current>item:
      return binary_search(item,ordered_list,start,middle-1)
    else:
      return binary_search(item,ordered_list,middle+1,end)
      
  
def test_binary_search(item,ordered_list,start,end, expected):
  result=binary_search(item,ordered_list,start,end)
  return result==expected
  
  
#TEST CASES:
mylist=list([2,4,6,7,9,11])
print(test_binary_search(9,mylist,0,5,4))
print(test_binary_search(4,mylist,0,5,1))
print(test_binary_search(2,mylist,0,5,0))

mylist=list([""beth"",""jerry"",""morty"",""rick"",""summer""])
print(test_binary_search(""rick"",mylist,0,4,3))

mylist=list([""lizard"",""paper"",""rock"",""scissors"",""spock""])
print(test_binary_search(""sheldon"",mylist,0,4,None))

mylist=[2,3,5,7,11,13,17,19,23,29,31,37]
print(test_binary_search(13,mylist,0,11,5))


```",2020-11-21T09:39:40+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",AleRosae,"This would be my implementation:
```
def binary_search(item, ordered_list, start, end):
    middle = (start+end) // 2
    mid_item = ordered_list[middle]
    if item == mid_item:
        return middle
    else:
        if item not in ordered_list:
            return None
        elif mid_item < item:
            return binary_search(item, ordered_list, middle, end)
        else:
            return binary_search(item, ordered_list, start, middle)

def test_binary_search(item, ordered_list, start, end, expected):
    return binary_search(item, ordered_list, start, end) == expected

my_list = [""Funerals"", ""In Rainbows"", ""Neon Bible"", ""OK Computer"", ""Ormai"", ""Sfortuna"", ""The Fall of Math"", ""Wild Light""]
print(test_binary_search(""OK Computer"", my_list,0,8,3))
print(test_binary_search(""Wild Light"", my_list,0,8,7))
print(test_binary_search(""Unknown Pleasure"", my_list,0,8, None))
```

However, I am not quite sure whether the function should also work with start and end values other than the actual start and end of the list (i.e. more than 0 and less than 8 for `my_list`) 
For istance `print(binary_search(""Wild Light"", my_list,2,6))` returns the following error `RecursionError: maximum recursion depth exceeded in comparison`",2020-11-21T16:20:01+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",fcagnola,"It took me quite some time but I think I got to a working solution. The test case I used runs the function for each letter of the English alphabet on a list only containing the Italian one. The letters not in the alphabet return ""not found"" as expected.

```
def binary_search(item, ordered_list, start, end):

    mid = (start + end) // 2  # the middle of the section to be searched is stored in a variable

    if item == ordered_list[mid]:  # base case: if the item is found in the middle, return item and position
        return mid

    elif start == mid: # with this line python won't raise RecursionError, if start == middle it means value not in list
        return ""Value not in list""

    elif ordered_list[mid] < item:  # if item comes after middle re-run search in the second half of the list
        return binary_search(item, ordered_list, mid, end)

    elif ordered_list[mid] > item:  # if item comes before middle re-run search in the first half of the list
        return binary_search(item, ordered_list, start, mid)


ord_list = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'z']


for i in ""abcdefghijklmnopqrstuvwxyz"":
    print(binary_search(i, ord_list, 0, 21)) 
# test returns: 0, 1, 2, 3, 4, 5, 6, 7, 8, Value not in list, Value not in list, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, Value not in list, Value not in list, Value not in list, 20
```",2020-11-21T16:57:36+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",SarahTew,"I have a bunch of test cases because as I worked through it I had a bunch of weird problems I didn't understand (including it not working with odd-numbered ```end``` (????) and lots of cases where it seemed to work in most cases but then in running all these test cases I discovered exceptions and had to fix it.

When I got the recursion error in Python Tutor I saw in the step-by-step explanation they give you that I got the error when my ```start``` value became larger than my ````end```` value. I solved that by adding ```if start > end: return None``` at the very beginning.

The one problem I couldn't solve was for it handle empty lists. At one point it was able to return ""None"" for empty sets but that version of the code couldn't handle looking for things in the first half of an odd-numbered list. I don't know why. If anyone does, let me know. In its current state it works for everything (or so I think) except an empty list, which will give an index error and make it stop running. You'll see I've left my example of that as a comment in the code. If anyone knows how to make it so it can handle an empty list, please let me know. Also is an empty list an unordered list?

If you're having problems and don't know why, doublecheck that your list is actually in order.
````
def binary_search(item, ordered_list, start, end):
    if start > end:
        return None
    middle = (start + end) // 2
    if item == ordered_list[middle]:
        return middle
        
    if item < ordered_list[middle]:
        return binary_search(item, ordered_list, start, middle-1)
    else:
        return binary_search(item, ordered_list, middle+1, end)


siblings = [""Lilly"", ""Sarah"", ""William""]
family = [""aunt"", ""father"", ""grandma"", ""grandpa"", ""mother"", ""uncle""]
alphabet = [""a"",""b"",""c"",""d"",""e"",""f""]
empty = []
print(binary_search(""Sarah"", siblings, 0, 2))
print(binary_search(""cousin"", family, 0, 5))
print(binary_search(""e"", alphabet, 0, 5))
#print(binary_search(""Sarah"", empty, 0, 0))
print(binary_search(""William"", siblings, 0, 2))
print(binary_search(""father"", family, 0, 5,))
print(binary_search(""b"", alphabet, 0, 5))

def test_binary_search(item, ordered_list, start, end, expected):
    result = binary_search(item, ordered_list, start, end)
    if result == expected:
        return True
    else:
        return False
print(test_binary_search(""Sarah"", siblings, 0, 2, 1))
print(test_binary_search(""cousin"", family, 0, 5, None))
print(test_binary_search(""e"", alphabet, 0, 6, 4))
print(test_binary_search(""e"", alphabet, 0, 2, None))
print(test_binary_search(""b"", alphabet, 0, 5, 1))
print(test_binary_search(""father"", family, 0, 5, 1))
````",2020-11-21T21:16:23+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",laurentfintoni,"```
def test_binary_search(item, ordered_list, start, end, expected):
    result = binary_search(item, ordered_list, start, end)
    if result == expected:
        return True
    else:
        return False

def binary_search(item, ordered_list, start, end):
    ordered_list_len = len(ordered_list)
    mid = ordered_list_len // 2
    if item not in ordered_list:
        return None
    else:
        if ordered_list.index(item) == mid:
            return mid
        elif ordered_list.index(item) < mid:
            binary_search(item, ordered_list[mid:end])
        elif ordered_list.index(item) > mid:
            binary_search(item, ordered_list[start:mid])

print(test_binary_search('gold digger', ['i', 'aint', 'saying', 'shes', 'a', 'gold digger', 'but', 'she', 'not', 'messin'], 0, 9, 5))
print(test_binary_search('Trinary', ['binary', 'search', 'is', 'a', 'fast', 'algorithm'], 0, 5, 3))
print(test_binary_search('cooking', ['i', 'am', 'cooking', 'chana', 'masala'], 0, 4, 2))
```

",2020-11-22T13:11:43+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",SusannaPinotti,"```
def test_for_binary_search(item, ordered_list, start, end, expected): 
    return binary_search(item, ordered_list, start, end) == expected

def binary_search(item, ordered_list, start, end): 
    mid = (start+end) //2 
    #base case
    if start > end: 
        print(None)
    #check if the value in the middle is the item to search   
    if item == ordered_list[mid]: 
        return mid 
    #if item is bigger check values after middle
    elif item > ordered_list[mid]: 
        return binary_search(item, ordered_list, mid, end)
    #if item is smaller check values before middle
    else: 
        return binary_search(item, ordered_list, start, mid)

n_list=[1, 3, 13, 23, 27, 36, 45, 72, 101]
l_list=[""a"", ""b"", ""d"", ""f"", ""g"", ""i""]
italy_list=[""Abruzzo"", ""Basilicata"", ""Calabria"", ""Campania"", ""Emilia Romagna"", ""Friuli-Venezia Giulia"", 
""Lazio"", ""Lombardia"", ""Marche"", ""Molise"", ""Piemonte"", ""Puglia"", ""Sardegna"", ""Sicilia"",
""Toscana"", ""Trentino Alto Adige"", ""Umbria"", ""Valle D'Aosta"", ""Veneto""]

print(test_for_binary_search(23, n_list, 0, 8, 3))
print(test_for_binary_search(""f"", l_list, 0, 5, 3))
print(test_for_binary_search(""Lombardia"", italy_list, 0, 19, 7))
```",2020-11-22T14:02:17+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",giorgiasampo,"````
def test_binary_search(item,ordered_list,start,end, expected):
  result = binary_search(item,ordered_list,start,end)
  return result == expected

def binary_search(item, ordered_list, start, end):
    work_list = ordered_list[start:end]
    mid_position = len(work_list) // 2
    if item not in ordered_list:
        return None
    if ordered_list[start] == item:
        return start
    if ordered_list[end] == item:
        return end
    if work_list[mid_position] == item:
        return mid_position+start
    if work_list[mid_position] <= item:
        binary_search(item, ordered_list, start, mid_position)
    else:
        binary_search(item, ordered_list, mid_position, end)

print (test_binary_search(4,([1,2,3,4,5,6]),1,5, 3))
print (test_binary_search(""Carlo"",([""Giorgia"",""Agnese"",""Carlo"",""Simone"",""Stefania"",""Susanna"",""Giulia""]),0, 2, 2))
print (test_binary_search(""Eloisa"",([""Giorgia"",""Agnese"",""Carlo"",""Simone"",""Stefania"",""Susanna"",""Giulia""]),0, 2, None))

````
",2020-11-22T14:53:23+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",ChiaraCati,"```
def test_binary_search(item, ordered_list, start, end, expected):
    result = binary_search(item, ordered_list, start, end)
    if result == expected:
        return True
    else:
        return False

def binary_search(item, ordered_list, start, end):
    if item in ordered_list:
        middle = (start + end) // 2
        mid_i = ordered_list[middle]
        if  item == mid_i:
            return middle
        elif item != mid_i:
            for i1 in ordered_list[:middle]:
                if i1 == item:
                    return ordered_list.index(i1)
            for i2 in ordered_list[middle:]:
                if i2 == item:
                    return ordered_list.index(i2)
    else:
        return 'None'


numbers = [1,2,4,5,6]
words = ['tree', 'pc', 'whale', 'luck']

print(test_binary_search(7, numbers, 0, 4, 'None'))
print(test_binary_search('whale', words, 0, 3, 2))
print(test_binary_search(6, numbers, 0, 4, 4))
print(test_binary_search(7, numbers, 0, 5, 1))
print(test_binary_search('flower', words, 0, 3, 2))
print(test_binary_search('whale', words, 0, 3, 2))

```",2020-11-22T15:12:58+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",vanessabonanno,"```

def test_binary_search(item, ordered_list, start, end, expected):
    result = binary_search(item, ordered_list, start, end)
    if result == expected:
        return True
    else:
        return False


def binary_search(item, ordered_list, start, end):
    tot_items = start + (end + 1)        # total of the items in list
    middle_item_index = tot_items // 2   # find the middle item index
    middle_item = ordered_list[middle_item_index] # find middle item value
    start_item = ordered_list[start]     # what's the starting item of list
    end_item = ordered_list[end]         # what's the ending item of list

    if type(item) != type(middle_item):  # check if the type of instances
        return None                      # is different
    if item < start_item or item > end_item:
        return None                      # if item searched not in list
    if item == middle_item:
        return middle_item_index         # base case
    elif item > middle_item:             # search in right part of list
        return binary_search(item, ordered_list, middle_item_index, end)
    elif item < middle_item:             # search in left part of list
        return binary_search(item, ordered_list, start, (middle_item_index - 1))
    else:
        return ""Error""


my_ordered_list = [""b"", ""c"", ""d""]
my_item = ""a""
my_item2 = ""d""
print(binary_search(my_item, my_ordered_list, 0, 2))         # None
print(binary_search(my_item2, my_ordered_list, 0, 2))        # 2

# test
print(test_binary_search(""a"", my_ordered_list, 0, 2, None))  # True
print(test_binary_search(""b"", my_ordered_list, 0, 2, 0))     # True
print(test_binary_search(3, my_ordered_list, 0, 2, True))    # False
print(test_binary_search(True, my_ordered_list, 0, 2, None)) # True

```",2020-11-22T15:33:41+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",GiuliaMenna,"```
def test_bin_search(item, ord_list, start,end,expected):
    result = bin_search(item, ord_list, start, end)
    if expected == result:
        return True
    else:
        return False


def bin_search(item,ord_list, start, end):
    middle = len(ord_list) // 2
    mid_item = ord_list[middle]
    halflist = ()
    left = halflist[0:middle]
    right = halflist[middle:end]

    if item not in ord_list:
        return None

    if mid_item == item:
        return middle

    if mid_item < item:
        for item in right:
            return ord_list.index(item)

    if mid_item > item:
        for item in left:
            return ord_list.index(item)

    return ord_list.index(item)



list_n =[""a"",""b"",""c"",""d"",""e"",""f"",""g""]
list = [1,2,3,4,5,6,7,8,9]
writers_list = [""Eco"", ""Faulkner"",""Roth"",""Steinbeck"",""Tolstoj""]
print(test_bin_search(""d"",list_n,0,6,3))
print(test_bin_search(""g"",list_n,0,6,6))
print(test_bin_search(9,list,0,8,8))
print(test_bin_search(1,list,0,8,0))
print(test_bin_search(""Roth"",writers_list,0,4,2))
print(test_bin_search(""Calvino"",writers_list,0,4,None))
```
",2020-11-22T16:18:32+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",gabrielefiorenza,"```
def test_binary_search(item, ordered_list,start,end,expected):
    result = binary_search(item, ordered_list, start, end)
    return result ==expected

def binary_search(item, ordered_list, start, end):
    if item not in ordered_list:
        return None
    else:
        list_used = ordered_list[start:end+1]
        middle = len(list_used)//2
        if list_used[middle] == item:
            return ordered_list.index(list_used[middle])
        elif list_used[middle] < item:
            return binary_search(item,ordered_list,middle,end)
        elif list_used[middle] >item:
            return binary_search(item, ordered_list,start, middle)


mylist=list([""carla"",""giulia"",""chiara"",""clara"",""irene""])
print(test_binary_search(""giovanna"",mylist, 0, 4, None)) #returns true

mylist1=list([""tablet"", ""pc"", ""pen"",""pencil"",""room""])
print(test_binary_search(""pc"",mylist1,0,4,1)) #returns true

```",2020-11-22T16:19:39+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",ConstiDami,"""""""
    
    def test_binary_search(item, ordered_list, start, end, expected):
        return binary_search(item, ordered_list,start, end)==expected

    def binary_search(item, ordered_list, start, end):

        mid = (end+start) // 2
        mid_term = ordered_list[mid]
        if mid_term == item:
            return mid
        elif item > ordered_list[end-1] or item < ordered_list[start]:
            return None
        elif mid_term < item:
            return binary_search(item, ordered_list, mid, end)
        else:
            return binary_search(item, ordered_list, start, mid)

    my_list = [1,3,5,7,8,9]
    print(test_binary_search(3, my_list, 0, len(my_list), 1))
    print(test_binary_search(9, my_list, 0, len(my_list), 5))
    print(test_binary_search(0, my_list, 0, len(my_list), None))
    print(test_binary_search(4, my_list, 0, len(my_list), None))
""""""",2020-11-22T17:10:01+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",LuisAmmi,"I've not completed the implementation with the test, 'cause the code (that I suppose it's correct) gives me a wrong solution in the second print case. I can't come up with the error in this code. Could you help me, please?
```
def binary_search(item, ordered_list, start, end):
    part_of_list = ordered_list[start:(end + 1)]  #the end position is included
    mid = len(part_of_list) // 2
    if item in part_of_list:
        if item == part_of_list[mid]:
           return mid 
        if part_of_list[mid] < item:
           binary_search(item, ordered_list, mid, end)  
        if part_of_list[mid] > item:
           binary_search(item, ordered_list, start, mid)

print (binary_search(4,([1,2,3,4,5,6]),1, 5)) # 2
print (binary_search(""Leila"",([""Fabio"", ""Federica"", ""Leila"", ""Luisa""]),0, 2)). # ?? It should return me ""2"", but actually it returns ""None""
print (binary_search(""ciao"",([""hola"",""salut"",""hello"",""ciao""]),0, 2))  #none",2020-11-22T17:16:11+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",SofiBar,"```

def test_binary_search(item, ordered_list, start, end, expected):
    if binary_search(item, ordered_list, start, end) == expected:
        return True


def binary_search(item, ordered_list, start, end):
    my_list = ordered_list[start:end]
    l = len(my_list)
    m = l // 2
    left_list = my_list[0:m]
    right_list = my_list[m:l]

    if item in my_list:
        if my_list[m] == item:
            return m + start
        elif my_list[m] < item:
            x = binary_search(item, right_list, 0, len(right_list))  
            return len(left_list) + x + start
        elif my_list[m] > item:
            y = binary_search(item, left_list, 0, len(left_list))  
            return y + start

    else:
        return None

num_list = [2, 3, 4, 5, 6, 7, 8, 9]
negative_list = [-6, -5, -4, -3, -2, -1, 0]
name_list = [""Andrea"", ""Davide"", ""Fabio"", ""Martina"", ""Mattia""]
print(test_binary_search(4, num_list, 2, 7, 2))
print(test_binary_search(""Martina"", name_list, 2, 5, 3))
print(test_binary_search(""Martina"", name_list, 0, 6, 3))
print(test_binary_search(-6, negative_list, 0, 4, 0))
print(test_binary_search(4, negative_list, 2, 7, None))

```",2020-11-22T21:29:24+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",AlessandroBertozzi,"```

def test_binary_search(item, ordered_list, start, end, expected):
    result = binary_search(item, ordered_list, start, end)
    return result == expected


def binary_search(item, ordered_list, start, end):

    my_list = ordered_list[start:end + 1]
    position = len(my_list) // 2
    # Basic case
    if len(my_list) == 1 and item != my_list[position]:
        return None
    elif item == my_list[position]:
        return position
    # Divide and conquer
    elif item < my_list[position]:
        return binary_search(item, my_list, start, position)
    else:
        return position + binary_search(item, my_list, position, end)


print(test_binary_search(4, [1, 3, 4, 5, 6, 8, 9], 0, 7, 2))
print(test_binary_search(4, [1], 0, 1, None))
print(test_binary_search('g', ['a', 'b', 'c', 'd', 'e', 'f', 'g'], 0, 6, 6))
print(test_binary_search(-1, [-6, -3, -2, -1], 0, 3, 3))
```",2020-11-22T22:36:43+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",AlessandraFa,"```
def test_binary_search(item, ordered_list, start, end, expected):
    result = binary_search(item, ordered_list, start, end)
    return result == expected


def binary_search(item, ordered_list, start, end):
    if item not in ordered_list[start:end]:
        return None
    mid = (start+end) // 2
    if item == ordered_list[mid]:
        return mid
    elif item < ordered_list[mid]:
        return binary_search(item, ordered_list, start, mid-1)
    elif ordered_list[mid] < item:
        return binary_search(item, ordered_list, mid+1, end)


print(test_binary_search(4, [1,3,4,5,7,8,9,11], 1, 7, 2))
print(test_binary_search(""m"", [""f"",""n"",""e"",""d"",""a"",""m"",""p"",""t"",""r"",""v""], 0, 7, 5))
```
",2020-11-22T23:43:20+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",IlaRoss,"```
# tests
def test_binary_search(item, ordered_list, start, end, expected):
    result = binary_search(item, ordered_list, start, end)
    if result == expected:
        return True
    else:
        return False

# algorithm 
def binary_search(item, ordered_list, start, end):
    midpos = (start + end) // 2
    midel = ordered_list[midpos]

    if start < 0:
        return 'invalid start value'
    if end > len(ordered_list) - 1:
        return 'invalid end value'
    if start > end:
        return 'start cannot be greater than end'

    else:
        if midel == item:
            return midpos
        elif start >= end:
           return None
        elif midel > item:
            return binary_search(item, ordered_list, start, midpos-1)
        elif midel < item:
            return binary_search(item, ordered_list, midpos+1, end)

a = [0, 1, 3, 5, 7, 8, 9]

# some test runs
print(test_binary_search(5, a, 0, 6, 3))
print(test_binary_search(8, a, 0, 6, 5))
print(test_binary_search(1, a, 0, 6, 1))
print(test_binary_search(1, a, 0, 3, 1))
print(test_binary_search(5, a, 4, 2, 'start cannot be greater than end'))
print(test_binary_search(5, a, 2, 7, 'invalid end value'))
print(test_binary_search(5, a, -1, 4, 'invalid start value'))
print(test_binary_search(6, a, 0, 6, None))
```",2020-11-26T10:23:34+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",edoardodalborgo,"```
def test_binary_search(item, ordered_list, start, end, expected):
    return binary_search(item, ordered_list, start, end) == expected

def binary_search(item, ordered_list, start, end):
    mid = (start+end) // 2
    try:
        mid_element = ordered_list[mid]
    except IndexError:
        return binary_search(item, ordered_list, start, len(ordered_list) - 1)
    if item == mid_element:
        return mid
    if start >= end:
        return None
    elif item > mid_element:
        return binary_search(item, ordered_list, mid+1, end)
    else:
        return binary_search(item, ordered_list, start, mid-1)

list_test = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'l', 'm']
print(test_binary_search('a', list_test, 2, 9, None))
print(test_binary_search('m', list_test, 0, 40, 10))
print(test_binary_search('d', list_test, 1, 4, 3))
```",2020-11-27T09:16:00+00:00
comp-think/2020-2021,"Lecture ""Divide and conquer algorithms"", exercise 1",essepuntato,"Hi guys,

a few comments about your solutions as follows.

About @AleRosae's comment:

> However, I am not quite sure whether the function should also work with start and end values other than the actual start and end of the list (i.e. more than 0 and less than 8 for my_list)

Well, in the recursive step you already do that, right? If you have a `maximum recursion depth exceeded in comparison` error when running it, probably it means that you are running too many recursive calls that, for a list like the one you used, is kind of unusual.

About @SarahTew's comment:

> The one problem I couldn't solve was for it handle empty lists.

You have to check explicitly if the input list is empty or not before continuing, and then return `None` if that is the case. I've updated the solution of the exercise online so as to consider also this situation, which is totally reasonable indeed.

About @giorgiasampo, @ChiaraCati, @laurentfintoni, @GiuliaMenna, @gabrielefiorenza, @LuisAmmi, @SofiBar and  @AlessandraFa's code:

> item not in ordered_list   # or something similar

Doing that is kind of cheating since you are checking if the item is in the list before looking for it. But the binary search should not know that in advance: it should return `None` if the process does not find the specific item - similarly to the way the `linear_search` works, which returns `None` if the item was not found.",2020-11-27T09:45:07+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",diegochillo,"```
def test_fib(n,expected):
  result=fib(n)
  return result==expected

def fib(n):
  if n<2:
    return n
  else:
    return fib(n-1)+fib(n-2)


print(test_fib(7,13))
print(test_fib(6,8))
print(test_fib(8,21))
print(test_fib(0,0))
```",2020-11-13T14:12:54+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",SusannaPinotti,"```
def test_fib(n, expected):
    result = fib(n)
    if expected == result:
        return True
    else:
        return False

def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

print(test_fib(7, 13)) #returns True
print(test_fib(1, 1)) #returns True
print(test_fib(19, 4181)) #returns Tru
```e ",2020-11-13T15:33:56+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",dbrembilla,"```
#test
def test(n, expected):
    return fib(n) == expected

#fibonacci
def fib(n):
    if n <= 0:
        return 0
    elif n < 2:
        return 1
    else:
        return fib(n-1) + fib(n-2)

print(test(10, 55)) # True
print(test(8, 21)) # True
print(test(1, 1)) # True
```",2020-11-13T17:14:24+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",gabrielefiorenza,"```
def test_fib(n,expected):
    result = fib(n)
    return result == expected


def fib(n):
    if n <= 0:
        return 0
    elif n ==1:
        return 1
    else:
        return fib(n-1) + fib(n-2)


print(test_fib(7,13)) #returns True
print(test_fib(1,1))#returns True
print(test_fib(0,0))#returns True
```",2020-11-14T12:18:57+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",AlessandraFa,"```
def test_fib(n, expected):
    return expected == fib(n)


def fib(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    else:
        return fib(n-1)+fib(n-2)


print(test_fib(4, 3))  #True
print(test_fib(-2, 0)) #True
print(test_fib(1, 1))  #True
```",2020-11-14T14:30:08+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",IlaRoss,"```
#tests
def test_fibonacci(n, expected):
    result = fibonacci(n)
    if result == expected:
        return True
    else:
        return False


#algorithm with recursion
def fibonacci(n):
    if n == 1:
        return 1
    if n <= 0:
        return 0
    else:
        return fibonacci(n-1) + fibonacci(n-2)


#test runs
a = test_fibonacci(8, 21)
b = test_fibonacci(5, 5)
c = test_fibonacci(1, 1)
d = test_fibonacci(-3, 0)

print(a)
print(b)
print(c)
print(d)
```",2020-11-14T18:58:21+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",ChiaraCati,"```
def test_fib(n, expected):
    result = fib(n)
    if result == expected:
        return True
    else:
        return False

def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)


print(test_fib(-5, 0))
print(test_fib(0,0))
print(test_fib(1,1))
print(test_fib(2,1))
print(test_fib(3,2))
print(test_fib(4,3))

```",2020-11-15T15:10:21+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",AleRosae,"```
def test_fin(n, expected):
    return expected == fin(n)

def fin(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fin(n-1) + fin(n-2)

print(test_fin(7,13))
print(test_fin(1,1))
print(test_fin(-7,0))
```",2020-11-15T15:46:48+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",yunglong28,"```
def test_fib (n, expected):
    result = fib(n)
    if result == expected:
        return True
    else:
        return False


def fib (n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

print(test_fib(7, 13))
```",2020-11-15T16:20:11+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",edoardodalborgo,"```
def test_fib(n, expected):
    return fib(n) == expected

def fib(n):
    if n < 2:
        return n
    else:
        return fib(n - 1) + fib(n - 2)

print(test_fib(3, 2))
print(test_fib(5, 5))
print(test_fib(10, 55))
```",2020-11-15T17:09:03+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",fcagnola,"```
# Define a recursive function def fib(n) that implements the algorithm to find the nth Fibonacci number.
# In particular, if n is less than or equal to 0, then 0 is returned as a result. Otherwise, if n is equal to 1,
# then 1 is returned. Otherwise, return the sum of the same function called with n-1 and n-2 as input.
# Please accompany the function with the related test case.

from test import test_1_parameter

def fib(number):
    if number <= 0:
        return 0
    elif number == 1:
        return 1
    else:
        return fib(number-1) + fib(number-2)


print(test_1_parameter(fib,3,2)) # returns True
print(test_1_parameter(fib,7,13)) # returns True

```",2020-11-16T16:08:50+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",SofiBar,"```
def test_fib(n, expected):
    return fib(n) == expected

def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1)+fib(n-2)

print(test_fib(4, 3))
print(test_fib(6, 8))
print(test_fib(0, 0))
```",2020-11-16T23:20:24+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",giorgiasampo,"````
def test_fib(n,expected):
    result = fib(n)
    return result == expected


def fib(n):
    if n <= 0:
        return 0
    else:
        if n == 1:
            return 1
        else:
            return fib(n-1)+fib(n-2)


print (test_fib(0,0))
print (test_fib(1,1))
print (test_fib(4,3))
print (test_fib(6,8))

````",2020-11-18T15:25:01+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",vanessabonanno,"```
def test_fib(n, expected):
    result = fib(n)
    if result == expected:
        return True
    else:
        return False


def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    elif n > 1:
        return fib(n - 1) + fib(n - 2)
    else:
        return ""Wrong input""


print(fib(7))           # 13
print(fib(4))           # 3
print(test_fib(7, 13))  # True
print(test_fib(1, 1))   # True
print(test_fib(0, 0))   # True
print(test_fib(4, 4))   # False

#  With big inputs the recursion may take a long time.
#  PythonTutor shows the following alert with input = 77:
#  ""Stopped since stack has 30 functions on it.
#   You may have infinite recursion""
```",2020-11-18T15:53:49+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",laurentfintoni,"```
def test_fib(n, expected):
    result = fib(n)
    if result == expected:
        return True
    else: 
        return False 

def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n - 1) + fib(n-2)

print(test_fib(4, 3))
print(test_fib(1, 1))
print(test_fib(0, 0))
```",2020-11-19T09:24:35+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",AlessandroBertozzi,"```
# Test case for the algorithm
def test_fib(n, expected):
    result = fib(n)
    if expected == result:
        return True
    else:
        return False


# Code of the algorithm
def fib(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)



print(test_fib(7, 13))
print(test_fib(1, 1))
print((test_fib(0, 0)))
```",2020-11-19T16:59:41+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",essepuntato,"Hi all,

Thanks for your solution. In your tests, can I suggest to add also an execution with negative input, e.g. `fib(-4)`? Can you try to see if your function still behaves as expected (i.e. returning `0` in these cases)?",2020-11-19T21:10:44+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",dbrembilla,"> Hi all,
> 
> Thanks for your solution. In your tests, can I suggest to add also an execution with negative input, e.g. `fib(-4)`? Can you try to see if your function still behaves as expected (i.e. returning `0` in these cases)?

Hello, 

In my case it returned `0` with negative numbers, as expected",2020-11-19T21:15:35+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",diegochillo,"> Hi all,
> 
> Thanks for your solution. In your tests, can I suggest to add also an execution with negative input, e.g. `fib(-4)`? Can you try to see if your function still behaves as expected (i.e. returning `0` in these cases)?

My function didn't work well with negatives. Here is a reviewed version:

```
def test_fib(n,expected):
  result=fib(n)
  return result==expected

def fib(n):
  if 0<=n<2:
    return n
  elif n>1:
    return fib(n-1)+fib(n-2)
  return 0

# Test cases
print(test_fib(7,13))
print(test_fib(6,8))
print(test_fib(8,21))
print(test_fib(0,0))
print(test_fib(-4,0))
```",2020-11-19T21:40:00+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 2",GiuliaMenna,"```
def test_fib(n, expected):
    result = fib(n)
    if expected == result:
        return True
    else:
        return False

def fib(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)
    return result

print(test_fib(0,0))
print(test_fib(1,1))
print(test_fib(7,13))
```",2020-11-21T11:14:45+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",diegochillo,"```
def test_exponentiation(base_number,exponent,expected):
  result=exponentiation(base_number,exponent)
  return result==expected

def exponentiation(base_number,exponent):
  if not (exponent):
    return 1   
  else:
    return base_number * exponentiation(base_number, exponent - 1) 


print(test_exponentiation(3, 4, 81)) 
print(test_exponentiation(17, 1, 17)) 
print(test_exponentiation(2, 0, 1))
```",2020-11-13T14:18:44+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",SarahTew,"I wrote this and it does work, though not for negative exponents so I have it return a string saying the exponent is negative when that's an input. Is that right? Is there a way to make it work with negative exponents as well? Here is the link to [PythonTutor](http://www.pythontutor.com/visualize.html#code=def%20exponentiation%28base_number,%20exponent%29%3A%0A%20%20%20%20if%20exponent%20%3C%200%3A%0A%20%20%20%20%20%20%20%20return%20%22Negative%20Exponent!%22%0A%20%20%20%20%0A%20%20%20%20elif%20exponent%20%3D%3D%200%3A%0A%20%20%20%20%20%20%20%20return%201%0A%20%20%20%20elif%20exponent%20%3D%3D%201%3A%0A%20%20%20%20%20%20%20%20return%20base_number%0A%20%20%20%20else%3A%20%20%0A%20%20%20%20%20%20%20%20return%20base_number%20*%20exponentiation%28base_number,%20exponent%20-%201%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%0Aprint%28exponentiation%283,4%29%29%0Aprint%28exponentiation%2817,1%29%29%0Aprint%28exponentiation%282,0%29%29%0Aprint%28exponentiation%28-2,3%29%29%0Aprint%20%28exponentiation%283,-3%29%29%0A%0Adef%20test_exponentiation%28base_number,%20exponent,%20expected%29%3A%0A%20%20%20%20result%20%3D%20exponentiation%28base_number,%20exponent%29%0A%20%20%20%20if%20result%20%3D%3D%20expected%3A%0A%20%20%20%20%20%20%20%20return%20True%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20return%20False%0A%20%20%20%20%20%20%20%20%0Aprint%28test_exponentiation%283,%204,%2081%29%29%0Aprint%28test_exponentiation%2817,%201,%2017%29%29%0Aprint%28test_exponentiation%282,%200,%201%29%29&cumulative=false&curInstr=117&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false) if you want to see how it works.

```
def exponentiation(base_number, exponent):
    if exponent < 0:
        return ""Negative Exponent!""    
    elif exponent == 0:
        return 1
    elif exponent == 1:
        return base_number
    else:  
        return base_number * exponentiation(base_number, exponent - 1)
            

print(exponentiation(3,4))
print(exponentiation(17,1))
print(exponentiation(2,0))
print(exponentiation(-2,3))
print (exponentiation(3,-3))

def test_exponentiation(base_number, exponent, expected):
    result = exponentiation(base_number, exponent)
    if result == expected:
        return True
    else:
        return False
        
print(test_exponentiation(3, 4, 81))
print(test_exponentiation(17, 1, 17))
print(test_exponentiation(2, 0, 1))
````

",2020-11-13T14:20:29+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",SusannaPinotti,"```
def test_exponential(base_number, exponent, expected):
    result = exponential(base_number, exponent)
    if expected == result:
        return True
    else:
        return False

def exponential(base_number, exponent):
    if exponent == 0:
        return 1
    else:
        return base_number * (exponential(base_number, exponent -1))

print(test_exponential(3, 4, 81)) #returns True
print(test_exponential(17, 1, 17)) #returns True
print(test_exponential(2, 0, 1)) #returns True 
```",2020-11-13T15:27:26+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",dbrembilla,"```
#test
def test(base_number, exponent, expected):
    return expected == exponentiation(base_number, exponent)

#exponential function
def exponentiation(base_number, exponent):
    if exponent == 0:
        if base_number == 0:
            return ""Impossible.""
        elif base_number != 0:
            return 1
    elif exponent == 1:
        return base_number
    else:
        return base_number * exponentiation(base_number, exponent - 1)

print(test(17, 1, 17)) #returns True
print(test(3, 4, 81)) #returns True
print(test(2, 0, 1)) #returns True

```",2020-11-13T17:05:02+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",gabrielefiorenza,"```
def test_exponentiation (base_number,exponent, expected):
    result = exponentiation(base_number,exponent)
    return result == expected

def exponentiation(base_number,exponent):
    if not exponent:
        return 1
    else:
        return base_number * exponentiation(base_number, exponent-1)


print(test_exponentiation(3,4,81)) #returns True
print(test_exponentiation(17,1,17)) #returns True
print(test_exponentiation(2,0,1)) #returns True
```",2020-11-14T12:20:17+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",AlessandraFa,"```
def test_exponentiation(base_number, exponent, expected):
    return expected == exponentiation(base_number, exponent)


def exponentiation(base_number, exponent):
    if base_number == 0 and exponent == 0:
        return None
    elif exponent == 0:
        return 1
    elif exponent < 0:
        exponent = exponent * -1
        return 1/(base_number * exponentiation(base_number, exponent - 1))
    else:
        return base_number * exponentiation(base_number, exponent - 1)


print(test_exponentiation(3, 4, 81))   # True
print(test_exponentiation(17, 1, 17))  # True
print(test_exponentiation(2, 0, 1))    # True

```",2020-11-14T15:20:10+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",IlaRoss,"```
#tests
def test_exponentiation(base_number, exponent, expected):
    result = exponentiation(base_number, exponent)
    if result == expected:
        return True
    else:
        return False

#algorithm
def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1
    elif exponent > 0:
        return base_number * exponentiation(base_number, exponent - 1)
    elif exponent < 0:
        return 1 / base_number * exponentiation(base_number, exponent + 1)

#test runs
a = test_exponentiation(3, 4, 81)
b = test_exponentiation(17, 1, 17)
c = test_exponentiation(2, 0, 1)

print(a)
print(b)
print(c)
```",2020-11-14T18:53:55+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",yunglong28,"```
# Test function

def test_exponentiation (base_number, exponent, expected):
    result = exponentiation (base_number, exponent)
    if result == expected:
        return True
    else:
        return False

# Recursive function for calculating a power

def exponentiation(base_number,exponent):
  if exponent == 0:
    return 1   
  else:
    return base_number * exponentiation(base_number, exponent - 1)


print (test_exponentiation (3, 4, 81))  #True
print (test_exponentiation (17,1,17))  #True
print (test_exponentiation (2, 0, 1))  #True
```",2020-11-15T11:20:26+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",LuisAmmi,"```
def test_exponentiation(base_n, exp, expected):
    result = exponentiation(base_n, exp)
    if result == expected:
        return True
    else:
        return False
        

def exponentiation(base_n, exp):
    if exp == 0:
        return 1
    else:
        return base_n * exponentiation(base_n, exp - 1)

print(test_exponentiation(3, 4, 81)). #true
print(test_exponentiation(17, 1, 17))
print(test_exponentiation(2, 0, 1))",2020-11-15T14:59:54+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",ChiaraCati,"```
def test_exp(base, exponent, expected):
    result = exp(base, exponent)
    if result == expected:
        return True
    else:
        return False


def exp(base, exponent):
    if exponent >= 0:  # for exponent
        if exponent == 1:
            return base
        elif exponent > 1:
            return base * exp(base, exponent - 1)
        else:
            return 1
    if exponent < 0:
        positive = 1 / base

        if exponent == -1:
            return positive
        else:
            return round(positive * exp(base, exponent + 1), 2)



print(test_exp(3, 4, 81))
print(test_exp(17, 1, 17))
print(test_exp(2, 0, 1))
print(test_exp(4, -2, 0.06))

```",2020-11-15T15:00:57+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",edoardodalborgo,"```
def test_exponentiation(base_number, exponent, expected):
    result = exponentiation(base_number, exponent)
    if result == expected:
        return True
    else:
        return False

def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1
    else:
        return base_number * exponentiation(base_number, exponent - 1)

print(test_exponentiation(3, 4, 81))
print(test_exponentiation(17, 1, 17))
print(test_exponentiation(2, 0, 1))
```",2020-11-15T16:24:43+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",AleRosae,"```
def test_exp(base_number, exponent, expected):
    return expected == exponentiation(base_number, exponent)

def exponentiation (base_number, exponent):
    if exponent == 0:
        return 1
    elif exponent == 1:
        return base_number
    elif exponent<0:
        return 1/(base_number)*(exponentiation(base_number,exponent+1 ))
    else:
        return base_number * exponentiation(base_number, exponent-1)

print(test_exp(3,4,81))
print(test_exp(17,1,17))
print(test_exp(2,0,1))
print(test_exp(2,-4,0.0625))

```",2020-11-15T17:44:06+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",fcagnola,"```
def test_2_parameter(function, parameter1, parameter2, expected):
    result = function(parameter1, parameter2)
    return result == expected

def exponentiation(base, exponent):
    if exponent < 0:  # if exponent is negative do not run function, but return error message
        return ""exponent must be a positive integer""
    if exponent == 0: # base case, anything to the power of 0 returns 1
        return 1
    else:  # recursive function, returns multiplication of base * each run's result
        return base * exponentiation(base, exponent-1)

print(test_2_parameter(exponentiation,3,4,81)) # returns True
print(test_2_parameter(exponentiation,17,1,17)) # returns True
print(test_2_parameter(exponentiation,2,0,1)) # returns True
```",2020-11-16T16:02:23+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",SofiBar,"```
def test_exponentiation(base_number, exponent, expected):
    return exponentiation(base_number, exponent) == expected


def exponentiation(base_number, exponent):
    if exponent == 1:
        return base_number
    elif exponent == 0:
        return 1
    elif exponent < 0:
        return 1/exponentiation(base_number, -1*exponent)
    else:
        return base_number*exponentiation(base_number, exponent-1)


print(test_exponentiation(3, 4, 81))
print(test_exponentiation(17, 1, 17))
print(test_exponentiation(2, 0, 1))

```",2020-11-16T23:55:41+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",giorgiasampo,"````
def` test_exponentiation(base_number, exponent, expected):
    result = exponentiation(base_number, exponent)
    return result == expected


def exponentiation(base_number, exponent):
    if exponent == 0:
        return 1
    else:
        return base_number*exponentiation(base_number, exponent-1)


print (test_exponentiation(3, 4, 81))
print (test_exponentiation(17, 1, 17))
print (test_exponentiation(2, 0, 1))

````",2020-11-18T15:19:12+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",vanessabonanno,"```
def test_exponentiation(num, exp, expected):
    result = exponentiation(num, exp)
    if result == expected:
        return True
    else:
        return False


def exponentiation(num, exp):
    if exp == 0:
        return 1  # base condition
    elif exp == 1:
        return num
    elif exp > 0:
        return num * exponentiation(num, exp - 1)
    elif exp < 0:
        return 1 / num * exponentiation(num, exp + 1)
    else:
        return ""Wrong input""


print(test_exponentiation(3, 4, 81))    # True
print(test_exponentiation(17, 1, 17))   # True
print(test_exponentiation(2, 0, 1))     # True
```",2020-11-18T15:36:55+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",laurentfintoni,"```
def test_exponentation(int_1, int_2, expected):
    result = exponentation(int_1, int_2)
    if result == expected:
        return True
    else: 
        return False 

def exponentation(int_1, int_2):
    if int_2 == 0:
        return 1
    else:
        return int_1 * exponentation(int_1, int_2 - 1)

print(test_exponentation(3, 4, 81))
print(test_exponentation(17, 1, 17))
print(test_exponentation(2, 0, 0))
```",2020-11-19T09:00:08+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",AlessandroBertozzi,"```
# Test case for the algorithm
def test_exponentiation(int_1, int_2, expected):
    result = exponentiation(int_1, int_2)
    if expected == result:
        return True
    else:
        return False


# Code of the algorithm
def exponentiation(int_1, int_2):
    if int_2 == 0:
        return 1
    else:
        return int_1 * exponentiation(int_1, int_2 - 1)



print(test_exponentiation(3, 4, 81))
print(test_exponentiation(17, 1, 17))
print(test_exponentiation(2, 0, 1))
```",2020-11-19T17:05:03+00:00
comp-think/2020-2021,"Lecture ""Recursion"", exercise 1",GiuliaMenna,"```
def test_exp(base_number, exponent,expected):
    result = exp(base_number, exponent)
    if expected == result:
        return True
    else:
        return False

def exp(base_number, exponent):
    if exponent == 0:
        return 1
    else:
        return base_number * exp(base_number, exponent - 1)
    return result

print(test_exp(3,4,81))
print(test_exp(17,1,17))
print(test_exp(2,0,1))
```",2020-11-21T11:03:00+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",IlaRoss,"```
set_hobbit = set({'Frodo', 'Sam', 'Pippin', 'Merry'})
set_magician = set({'Saruman','Gandalf'})

my_dict = dict()
my_dict['hobbit'] = set_hobbit
my_dict['magician'] = set_magician
```",2020-11-09T14:22:02+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",penelopelask,"```
set_hobbit = set()
set_hobbit.add(""Frodo"")
set_hobbit.add(""Sam"")
set_hobbit.add(""Pippin"")
set_hobbit.add(""Merry"")


set_magician = set()
set_magician.add(""Saruman"")
set_magician.add(""Gandalf"")


mydict = dict()
mydict[""hobbit""] = set_hobbit
mydict[""magician""] = set_magician

print(set_hobbit)
print(set_magician)
print(mydict)

{'Merry', 'Frodo', 'Sam', 'Pippin'}
{'Saruman', 'Gandalf'}
{'hobbit': {'Merry', 'Frodo', 'Sam', 'Pippin'}, 'magician': {'Saruman', 'Gandalf'}}",2020-11-09T14:55:48+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",gabrielefiorenza,"```
set_hobbit = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = set({""Saruman"", ""Gandalf""})
my_dict = {""hobbit"": set_hobbit, ""magician"": set_magician}
```",2020-11-09T16:02:07+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",ChiaraCati,"```
set_hobbit = set()
set_hobbit.add('Frodo')
set_hobbit.add('Sam')
set_hobbit.add('Pippin')
set_hobbit.add('Merry')

set_magician = set()
set_magician.add('Saruman')
set_magician.add('Gandalf')

lotr_dict = dict()
lotr_dict['hobbit'] = set_hobbit
lotr_dict['magician'] =set_magician

print(lotr_dict)
```",2020-11-09T16:12:45+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",dbrembilla,"```
set_hobbit = {'Frodo', 'Sam', 'Pippin', 'Merry'}
set_magician = {'Saruman','Gandalf'}
my_dict= {""hobbit"": set_hobbit, ""magician"": set_magician}
```",2020-11-09T17:53:44+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",edoardodalborgo,"```
set_hobbit = {'Frodo', 'Sam', 'Pippin', 'Merry'}
set_magician = {'Saruman', 'Gandalf'}
dict_LOR = {
'hobbit': set_hobbit,
'magician': set_magician
}
```",2020-11-09T18:52:21+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",giorgiasampo,"set_hobbit = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = set({""Saruman"", ""Gandalf""})

my_dictionary = dict ()
my_dictionary [""hobbit""] = set_hobbit
my_dictionary [""magician""] = set_magician

print (my_dictionary)
",2020-11-09T19:48:36+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",GiuliaMenna,"```
set_hobbit = set({""Frodo"",""Sam"",""Pippin"",""Merry""})
set_magician = set({""Saruman"",""Gandalf""})

my_dict = dict()
my_dict[""hobbit""] = set_hobbit
my_dict[""magician""] = set_magician
output = my_dict

```",2020-11-09T19:51:47+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",LuisAmmi,"```
char_set = {'Sam', 'Galadriel', 'Saruman', 'Frodo', 'Merry', 'Gandalf', 'Pippin'}
set_hobbit = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = set({""Saruman"", ""Gandalf""})

rings_dic = dict()
rings_dic[""hobbit""] = set_hobbit
rings_dic[""magician""] = set_magician

print(rings_dic) 
# print {'hobbit': {'Frodo', 'Sam', 'Merry', 'Pippin'}, 'magician': {'Gandalf', 'Saruman'}}",2020-11-10T10:03:13+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",fcagnola,"```
# Suppose to organise some of the elements in the set returned by the second exercise
# in two different sets: set_hobbit that refers to the set set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""}),
# and set_magician defined as set({""Saruman"", ""Gandalf""}).
# Create a dictionary containing two pairs: one that associates the set of hobbits with the key ""hobbit"",
# and the other that associates the set of magicians with the key ""magician"".

set_hobbit = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = set({""Saruman"", ""Gandalf""})

lotr_dictionary = dict() # create an empty dictionary object
lotr_dictionary[""hobbit""] = set_hobbit # assign the existing set to the key ""hobbit"" in the new dictionary
lotr_dictionary[""magician""] = set_magician # assign the existing set to the key ""magician"" in the new dictionary
print(lotr_dictionary)
```",2020-11-10T14:34:38+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",SofiBar,"`my_set = ({""Frodo"", ""Sam"", ""Pippin"", ""Mary"", ""Saruman"", ""Gandalf""})
my_set.remove(""Saruman"")
my_set.remove(""Gandalf"")
set_hobbit = my_set
set_magician = ({""Saruman"", ""Gandalf""})

my_dictionary = dict()
my_dictionary = ({""hobbit"":set_hobbit, ""magician"":set_magician})

print(my_dictionary)`",2020-11-10T15:17:33+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",yunglong28,"```
# Creating two separate sets
set_hobbit = {""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
set_magicians = {""Gandalf"", ""Saruman""}

# Creating a dictionary
lotr_dict = {""hobbit"": '{""Frodo"", ""Sam"", ""Pippin"", ""Merry}', ""magicians"": '{""Gandalf"",""Saruman""}'}

print(lotr_dict)
```",2020-11-10T16:06:55+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",SarahTew,"```
set_hobbit={""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
set_magician={""Saruman"", ""Gandalf""}
lotr_dict=dict()
lotr_dict[""hobbit""]=set_hobbit
lotr_dict[""magician""]=set_magician

print(lotr_dict[""hobbit""])
print(lotr_dict[""magician""])
print(lotr_dict)
```",2020-11-10T16:18:28+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",vanessabonanno,"```
# I create two sets of elements
set_hobbit = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = set({""Saruman"", ""Gandalf""})

# I initialise an empty dictionary
lotr_dictionary = dict()

# I add the keys of the dictionary. Their relative values are the sets created before
lotr_dictionary[""hobbit""] = set_hobbit
lotr_dictionary[""magician""] = set_magician

print(lotr_dictionary) 
# output: {'hobbit': {'Merry', 'Pippin', 'Sam', 'Frodo'}, 'magician': {'Saruman', 'Gandalf'}}

```",2020-11-10T17:08:38+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",Camillaneri,"`set_hobbit = set(({""Frodo"", ""Sam"", ""Pippin"", ""Merry""}))
set_magician = set(({""Saruman"", ""Gandalf""}))

lotr_dict = dict()
lotr_dict[""hobbits""] = set_hobbit
lotr_dict[""magicians""] = set_magician


print(lotr_dict)
# output {'hobbit': {'Frodo', 'Pippin', 'Sam', 'Merry'}, 'magician': {'Saruman', 'Gandalf'}}`",2020-11-10T19:05:20+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",AlessandraFa,"```
set_hobbit = set({'Bilbo', 'Pippin', 'Sam', 'Merry', 'Frodo'})
set_magician = set({""Saruman"", ""Gandalf""})
lotr_dict = dict()
lotr_dict[""hobbit""] = set_hobbit
lotr_dict[""magician""] = set_magician


print(lotr_dict)
# Output: {'hobbit': {'Bilbo', 'Pippin', 'Sam', 'Frodo', 'Merry'}, 'magician': {'Gandalf', 'Saruman'}}
```",2020-11-10T21:11:36+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",LauOcchipinti,">>> set_hobbit = set()
>>> set_hobbit.add (""Frodo"")
>>> set_hobbit.add (""Sam"")
>>> set_hobbit.add (""Pippin"")
>>> set_hobbit.add (""Marry"")
>>> print(set_hobbit)
{'Sam', 'Frodo', 'Pippin', 'Marry'}
>>> set_magician = set()
>>> set_magician.add (""Gandalf"")
>>> set_magician.add(""Saruman"")
>>> print(set_magician)
{'Gandalf', 'Saruman'}
>>> dictionary = dict()
>>> dictionary[""hobbit""]= set_hobbit
>>> dictionary [""magician""]=set_magician
>>> print (dictionary)
{'hobbit': {'Sam', 'Frodo', 'Pippin', 'Marry'}, 'magician': {'Gandalf', 'Saruman'}}
",2020-11-12T12:29:14+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",AleRosae,"```
set_hobbit = set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = set({""Saruman"", ""Gandalf""})

LOTR_dict = dict()
LOTR_dict[""hobbit""] = set_hobbit
LOTR_dict[""magician""] = set_magician

print(LOTR_dict) #returns {'hobbit': {'Sam', 'Merry', 'Frodo', 'Pippin'}, 'magician': {'Gandalf', 'Saruman'}}
``` 
",2020-11-12T14:54:04+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",SusannaPinotti,"```
set_hobbit= set({""Frodo"", ""Sam"", ""Pippin"", ""Merry""})
set_magician = set({""Saruman"", ""Gandalf""})

lotr_dict = dict()
lotr_dict[""hobbits""] = set_hobbit
lotr_dict[""magicians""]= set_magician
```",2020-11-12T17:10:56+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 3",AlessandroBertozzi,"```
my_set = {""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""}

my_set.remove(""Bilbo"")
my_set.add(""Galadriel"")
my_set.update({""Saruman"", ""Frodo"", ""Gandalf""})

# organise information from previous exercise
set_magician = set()
set_hobbit = set()
for name in my_set:
    if name == ""Saruman"" or name == ""Gandalf"":
        set_magician.add(name)
    else:
        set_hobbit.add(name)

# creation of the dictionary
my_Lotr_dictionary = {}
my_Lotr_dictionary[""hobbit""] = set_hobbit
my_Lotr_dictionary[""magician""] = set_magician
print(my_Lotr_dictionary)
```",2020-11-12T20:53:23+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",IlaRoss,"`my_set = set({'Frodo', 'Sam', 'Pippin', 'Merry', 'Bilbo'})`
after `â€‹my_set.remove('Bilbo')` --> `my_set = set({'Frodo', 'Sam', 'Pippin', 'Merry'})`
after `â€‹my_set.add('Galadriel')` --> `my_set = set({'Frodo', 'Sam', 'Pippin', 'Merry', 'Galadriel'})`
after `â€‹my_set.update(set({'Saruman', 'Frodo', 'Gandalf'}))` --> `my_set = set({'Frodo', 'Galadriel', 'Gandalf', 'Sam', 'Saruman', 'Pippin', 'Merry'})`",2020-11-09T14:18:21+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",penelopelask,"```
my_set = set({'Frodo', 'Sam', 'Pippin', 'Merry', 'Bilbo'})
my_set.remove(""Bilbo"")
my_set.add(""Galadriel"")
my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))
print(my_set)

#will print

{'Frodo', 'Saruman', 'Merry', 'Sam', 'Pippin', 'Gandalf', 'Galadriel'}
",2020-11-09T14:51:47+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",gabrielefiorenza,"The status of my_set will be:
my_set = {'Pippin', 'Sam', 'Galadriel', 'Gandalf', 'Frodo', 'Merry', 'Saruman'}",2020-11-09T15:57:39+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",ChiaraCati,"```
lotr_set = set({'Frodo', 'Sam', 'Merry', 'Pippin', 'Bilbo'})
lotr_set.remove('Bilbo')
# current state {'Merry', 'Frodo', 'Sam', 'Pippin'}

lotr_set.add('Galadriel')
# current state {'Sam', 'Pippin', 'Galadriel', 'Merry', 'Frodo'}

more_set = set()
lotr_set.add('Saruman')
lotr_set.add('Frodo')
lotr_set.add('Gandalf')
# create new set to add

lotr_set.update(more_set)
print(lotr_set)
# output {'Sam', 'Galadriel', 'Pippin', 'Frodo', 'Saruman', 'Merry', 'Gandalf'} 
# 'Frodo' is not repeated because sets do not allow repetitions
```",2020-11-09T16:04:48+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",dbrembilla,"After `my_set.remove('Bilbo')` the set contains `'Merry', 'Frodo', 'Pippin', 'Sam'`
after `my_set.add('Galadriel')` the set contains `'Merry', 'Frodo', 'Pippin', 'Sam', 'Galadriel'`
after `my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))` the set contains `'Merry', 'Frodo', 'Pippin', 'Sam', 'Galadriel', 'Saruman', 'Gandalf'` ",2020-11-09T17:35:05+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",edoardodalborgo,"```
my_set = {'Bilbo', 'Frodo', 'Sam', 'Pippin', 'Merry'}
my_set.remove('Bilbo')
#after this statement the string ""Bilbo"" is removed from the set
my_set.add(""Galadriel"")
#after this statement the string ""Galadriel"" is add to the list, but we don't know in what position
my_set.update({""Saruman"", ""Frodo"", ""Gandalf""})
#after this statement all the elements of a new set, if they aren't already in my_set,
#are included in, but we don't know in what order the elements are added
```",2020-11-09T17:56:12+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",GiuliaMenna,"```
my_set=set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")

my_set.remove(""Bilbo"")
my_set.add(""Galadriel"")
my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))

#Output = ""Saruman"" ,""Galadriel"", ""Frodo"", ""Sam"", ""Merry"",""Gandalf"", ""Pippin""
```


",2020-11-09T19:36:40+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",giorgiasampo,"Starting Set:
my_set= set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Merry"")
my_set.add(""Pippin"")


â€‹my_set.remove(""Bilbo""): my_set = {'Pippin', 'Sam', 'Frodo', 'Merry'}
â€‹my_set.add(""Galadriel""):my_set = {'Frodo', 'Merry', 'Pippin', 'Sam', 'Galadriel'}
â€‹my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})): my_set = {'Frodo', 'Saruman', 'Merry', 'Pippin', 'Sam', 'Galadriel', 'Gandalf'}",2020-11-09T19:43:41+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",LuisAmmi,"```
char_set =  {'Frodo', 'Merry', 'Sam', 'Bilbo', 'Pippin'}

char_set.remove(""Bilbo"") --> char_set =  {'Sam', 'Frodo', 'Merry', 'Pippin'}
char_set.add(""Galadriel"") --> char_set =  {'Sam', 'Frodo', 'Galadriel', 'Merry', 'Pippin'}
char_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})). --> char_set =  {'Sam', 'Galadriel', 'Saruman', 'Frodo', 'Merry', 'Gandalf', 'Pippin'}
# The 'update' operation excludes any duplicate item, this is the reason why 'Frodo' appears only once. ",2020-11-10T09:24:13+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",fcagnola,"```
# Consider the set created in the first exercise, stored in the variable my_set.
# Describe the status of lotr_set after the execution of each of the following
# operations: lotr_set.remove(""Bilbo""), lotr_set.add(""Galadriel""),
# lotr_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})).

lotr_set.remove(""Bilbo"") # ""Bilbo will be removed from the set
# lotr_set contains: {'Pippin', 'Merry', 'Sam', 'Frodo'}

lotr_set.add(""Galadriel"") # ""Galadriel"" will be added to the set
# lotr_set contains: {'Pippin', 'Merry', 'Sam', 'Frodo', 'Galadriel'}

lotr_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""})) # specified set will be added to the variable lotr_set, with the exception of duplicate items
# lotr_set contains {'Pippin', 'Merry', 'Sam', 'Frodo', 'Galadriel', 'Saruman', 'Gandalf'}
```",2020-11-10T14:30:10+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",SofiBar,"
`my_set.remove(""Bilbo"")   # my_set = ({""Frodo"", ""Sam"", ""Pippin"", ""Mary""})
my_set.add(""Galadriel"")    # my_set = ({""Frodo"", ""Galadriel"", ""Sam"", ""Pippin"", ""Mary""})
my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))    # my_set = ({""Frodo"", ""Sam"", ""Pippin"", ""Mary"", ""Saruman"", ""Gandalf""})
`",2020-11-10T14:54:59+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",yunglong28,"```
{'Gandalf', 'Frodo', 'Saruman', 'Sam', 'Merry', 'Pippin', 'Galadriel'}`",2020-11-10T15:51:19+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",SarahTew,"```
my_set.remove(""Bilbo"")
my_set={""Pippin"", ""Sam"", ""Frodo"", ""Merry""}
my_set.add(""Galadriel"")
my_set={""Pippin"", ""Sam"", ""Frodo"", ""Merry"", ""Galadriel""}
my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))
my_set={""Pippin"", ""Sam"", ""Frodo"", ""Merry"", ""Galadriel"", ""Saruman"", ""Gandalf""}
```
When I ran these all in PythonTutor it would switch the order of the objects. Sets are unordered so it doesn't really matter I just wondering how it decides where to put them.",2020-11-10T16:10:01+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",vanessabonanno,"```
my_set = set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")

my_set.remove(""Bilbo"")  
# the element ""Bilbo"" is removed from my_set
# output: {'Sam', 'Frodo', 'Pippin', 'Merry'}

my_set.add(""Galadriel"") 
# the element ""Galadriel"" is added to my_set
# output: {'Sam', 'Galadriel', 'Frodo', 'Pippin', 'Merry'}

my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))
# a second set is added to ""my_set""
# output: {'Gandalf', 'Saruman', 'Sam', 'Frodo', 'Pippin', 'Merry', 'Galadriel'}
# ""Frodo"" is not added because it is already present in my_set

```",2020-11-10T16:58:34+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",Camillaneri,"`my_set = set(({'Frodo', 'Sam', 'Pippin', 'Merry', 'Bilbo'}))
my_other_set = set(({""Saruman"", ""Frodo"", ""Gandalf""}))

my_set.remove(""Bilbo"")

#{'Sam', 'Frodo', 'Merry', 'Pippin'}

my_set.add(""Galadriel"")

#{'Sam', 'Galadriel', 'Frodo', 'Merry', 'Pippin'}

my_set.update(my_other_set)

#output {'Sam', 'Galadriel', 'Frodo', 'Saruman', 'Gandalf', 'Merry', 'Pippin'}
`",2020-11-10T19:03:31+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",AlessandraFa,"```
my_set = set({'Frodo', 'Sam', 'Pippin', 'Merry', 'Bilbo'})
my_set.remove(""Bilbo"")   # removes item ""Bilbo"" from set""
my_set.add(""Galadriel"")  # adds ""Galadriel"" to the set
my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))  # adds elements from another set to my_set
                               
# Final status: {'Pippin', 'Sam', 'Frodo', 'Saruman', 'Merry', 'Gandalf', 'Galadriel'} - these are the elements contained in the set. 
# They are printed in random order because the order of the items in a set is not relevant. Since sets don't allow multiple 
# identical items, the item ""Frodo"" appears just once.
```",2020-11-10T21:08:31+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",LauOcchipinti,">>> my_set = set()
>>> my_set.add(""Bilbo"")
>>> my_set.add(""Frodo"")
>>> my_set.add(""Pippin"")
>>> my_set.add(""Marry"")
>>> print(my_set)
{'Pippin', 'Marry', 'Frodo', 'Bilbo'}
>>> my_set.remove(""Bilbo"")
>>> print(my_set)
{'Pippin', 'Marry', 'Frodo'}
>>> my_set.add(""Galadriel"")
>>> print (my_set)
{'Galadriel', 'Pippin', 'Marry', 'Frodo'}
>>> my_set.update(set({""Saruman"", ""Frodo"", ""Gandalf""}))
>>> print(my_set)
{'Galadriel', 'Pippin', 'Marry', 'Frodo', 'Gandalf', 'Saruman'}",2020-11-12T12:21:15+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",AleRosae,"```
LOTR_set = set ()
LOTR_set.add(""Bilbo"")
LOTR_set.add(""Frodo"")
LOTR_set.add(""Sam"")
LOTR_set.add(""Pippin"")
LOTR_set.add(""Merry"")

print(LOTR_set) #returns {'Bilbo', 'Pippin', 'Frodo', 'Merry', 'Sam'}

LOTR_set.remove(""Bilbo"") #Python will remove the item ""Bilbo"" 

print(LOTR_set) #returns {'Pippin', 'Frodo', 'Merry', 'Sam'}

LOTR_set.add(""Galadriel"") #Python will add the item ""Galadriel"" to the set

print(LOTR_set) #returns {'Galadriel', 'Pippin', 'Frodo', 'Merry', 'Sam'}

LOTR_set.update((set({""Saruman"", ""Frodo"", ""Gandalf""}))) #Python will update the set by includin another set which includes items ""Saruman"", ""Frodo"" and ""Gandalf""

print(LOTR_set) #returns {'Galadriel', 'Gandalf', 'Saruman', 'Pippin', 'Frodo', 'Merry', 'Sam'}
```",2020-11-12T14:48:03+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 2",SusannaPinotti,"lotr_set=set()
lotr_set.add(""Bilbo"")
lotr_set.add(""Frodo"")
lotr_set.add(""Sam"")
lotr_set.add(""Pippin"")
lotr_set.add(""Merry"")

lotr_set.remove(""Bilbo"")
lotr_set.add(""Galadriel"")
lotr_set.update( set({""Saruman"", ""Frodo"", ""Gandalf""}))

#the element Frodo in the added set will replace the same value in lotr_set, because it is not possible to have the same #value twice in a set
lotr_set = {""Pippin"", ""Merry"", ""Frodo"", ""Galadriel"", ""Gandalf"", ""Sam"", ""Saruman""}",2020-11-12T16:49:55+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",IlaRoss,"```
my_set = set()
my_set.add('Bilbo')
my_set.add('Frodo')
my_set.add('Sam')
my_set.add('Pippin')
my_set.add('Merry')
```",2020-11-09T13:17:49+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",penelopelask,"```
my_set = set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")",2020-11-09T14:43:32+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",gabrielefiorenza,"```
my_set = set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")

```",2020-11-09T15:53:35+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",ChiaraCati,"```
lotr_set = set()

lotr_set.add('Bilbo')
# current state {'Bilbo'}
lotr_set.add('Frodo')
# current state {'Bilbo', 'Frodo'}
lotr_set.add('Sam')
# current state {'Sam', 'Frodo', 'Bilbo'}
lotr_set.add('Pippin')
# current state {'Sam', 'Bilbo', 'Pippin', 'Frodo'}
lotr_set.add('Merry')
print(lotr_set)
# output {'Frodo', 'Sam', 'Merry', 'Pippin', 'Bilbo'}

```",2020-11-09T15:54:13+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",dbrembilla,"```
fellowship_hobbits = set()
fellowship_hobbits.add(""Bilbo"")
fellowship_hobbits.add(""Frodo"")
fellowship_hobbits.add(""Sam"")
fellowship_hobbits.add(""Pippin"")
fellowship_hobbits.add(""Merry"")
```",2020-11-09T17:27:59+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",edoardodalborgo,"```
my_set = {'Bilbo', 'Frodo', 'Sam', 'Pippin', 'Merry'}
```",2020-11-09T17:43:26+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",GiuliaMenna,"```
my_set=set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Merry"")
output=my_set
```",2020-11-09T19:28:11+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",giorgiasampo,"my_set= set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Merry"")
my_set.add(""Pippin"")

print my_set",2020-11-09T19:40:04+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",LuisAmmi,"```
    char_set = set()
    char_set.add(""Bilbo"")
    char_set.add(""Frodo"")
    char_set.add(""Sam"")
    char_set.add(""Pippin"")
    char_set.add(""Merry"")
    # char_set = { 'Sam', 'Bilbo',  'Frodo',  'Merry', 'Pippin'}",2020-11-10T09:10:06+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",fcagnola,"```
# Write a code in Python to create a set of the following elements:
# ""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry"".

lotr_set = set()

lotr_set.add(""Bilbo"")
lotr_set.add(""Frodo"")
lotr_set.add(""Sam"")
lotr_set.add(""Pippin"")
lotr_set.add(""Merry"")

print(lotr_set)
```",2020-11-10T14:24:26+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",SofiBar,"`my_set = set ()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Sam"")
my_set.add(""Pippin"")
my_set.add(""Mary"")

print(my_set)`",2020-11-10T14:46:01+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",yunglong28,"```
# Write a code in Python to create a set of the following elements:
# ""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry"".

my_set = {""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
print(my_set)
```",2020-11-10T15:49:42+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",SarahTew,"```
lotr_set={""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
```",2020-11-10T15:55:12+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",vanessabonanno,"```
hobbit_set = set()
hobbit_set.add(""Bilbo"")
hobbit_set.add(""Frodo"")
hobbit_set.add(""Sam"")
hobbit_set.add(""Pippin"")
hobbit_set.add(""Merry"")

print(hobbit_set)

# output: {'Merry', 'Sam', 'Frodo', 'Bilbo', 'Pippin'}

```",2020-11-10T16:50:37+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",Camillaneri,"`
hobbit_set = set()
hobbit_set.add(""Bilbo"")
hobbit_set.add(""Frodo"")
hobbit_set.add(""Sam"")
hobbit_set.add(""Pippin"")
hobbit_set.add(""Merry"")

print(hobbit_set)

`",2020-11-10T19:00:29+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",AlessandraFa,"```
my_lotr_set = set()
my_lotr_set.add(""Bilbo"")
my_lotr_set.add(""â€‹Frodo"")
my_lotr_set.add(""â€‹Sam"")
my_lotr_set.add(""â€‹Pippin"")
my_lotr_set.add(""â€‹Merry"")


print(my_lotr_set)

# Output: my_lotr_set = {""â€‹Bilbo"", ""â€‹Frodo"", ""â€‹Sam"", ""â€‹Pippin"", ""â€‹Merry""}
```",2020-11-10T20:47:39+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",LauOcchipinti,"my_set = set()
my_set.add(""Bilbo"")
my_set.add(""Frodo"")
my_set.add(""Pippin"")
my_set.add(""Marry"")
print(my_set)",2020-11-12T12:08:55+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",AleRosae,"```
LOTR_set = set()
LOTR_set.add(""Bilbo"")
LOTR_set.add(""Frodo"")
LOTR_set.add(""Sam"")
LOTR_set.add(""Pippin"")
LOTR_set.add(""Merry"")

print(LOTR_set)
```",2020-11-12T14:39:10+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",SusannaPinotti,"```
lotr_set=set()
lotr_set.add(""Bilbo"")
lotr_set.add(""Frodo"")
lotr_set.add(""Sam"")
lotr_set.add(""Pippin"")
lotr_set.add(""Merry"")
```
",2020-11-12T16:43:08+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",AlessandroBertozzi,"```
my_set = {""Bilbo"", ""Frodo"", ""Sam"", ""Pippin"", ""Merry""}
print(my_set)
```",2020-11-12T19:53:51+00:00
comp-think/2020-2021,"Lecture ""Organising information: unordered structures"", exercise 1",essepuntato,"Hi all,

thanks for your answer. Just a comment for @giorgiasampo: `print my_set` is a Python **2** construct, while in Python 3 you should use `print(my_set)` â€“ `print` is a proper function in Python 3.",2020-11-13T08:56:40+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 5",diegochillo,"```
def my_reversed(input_list):

   my_rev=list()

   n=len(input_list)-1
   c=0

   while n>=0:
      my_rev.insert(c,input_list[n])
      c=c+1
      n=n-1

   return my_rev

def test_my_reversed(input_list,expected):
   result=my_reversed(input_list)
   return result==expected
	
print(test_my_reversed([""Birdperson"",""Tammy"",""Squanchy"",""Gazorpazorpfield""],[""Gazorpazorpfield"",""Squanchy"",""Tammy"",""Birdperson""]))
```",2020-10-31T11:07:31+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 5",gabrielefiorenza,"```
def test_my_reversed(input_list,expected):
    result = my_reversed(input_list)
    if result == expected:
        return True
    else:
        return False


def my_reversed(input_list):
    result= []
    idx = len(input_list) -1
    for item in input_list:
        change = input_list[idx]
        result.append(change)
        idx -=1
    return result

print (test_my_reversed([0,1,2,3],[3, 2, 1, 0]))
print (test_my_reversed([0,1,2,3],[1, 3, 2, 0]))

```",2020-10-31T11:59:11+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 5",ChiaraCati,"```
# test
def test_my_reversed(input_list, expected):
    result = my_reversed(input_list)
    if result == expected:
        return True
    else:
        return False


# function
def my_reversed(input_list):
    r_list = []
    count = len(input_list)
    while count > 0:
        count = count - 1
        r_list.append(input_list[count])

    return r_list


print(test_my_reversed(['cane', 'gatto', 'asino','topo'], ['topo', 'asino', 'gatto', 'cane'])) # output: True
print(test_my_reversed(['cane', 'gatto', 'asino',''], ['', 'asino', 'gatto', 'cane'])) # output: True
print(test_my_reversed(['cane', 1, 'asino', 2], [2, 'asino', 1, 'cane'])) # output: True
print(test_my_reversed(['cane', 1, 'asino', (2,3)], [2,3, 'asino', 1, 'cane'])) # output: False
print(test_my_reversed(['cane', 1, 'asino', (2,3)], [(2,3), 'asino', 1, 'cane'])) # output: True
```
me and Giorgia SampÃ² did it together

ðŸ‘­

",2020-10-31T18:24:47+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 5",fcagnola,"```
# Write in Python the function def my_reversed(input_list) which behave
# like the built-in function reversed() introduced in Section ""Insertion
# sort"" and returns a proper list, and accompany the function with the
# related test case. It is not possible to use the built-in function
# reversed() in the implementation.

# defining a test function
def test(input_list, expected):
    result = my_reversed(input_list)
    return result == expected


def my_reversed(input_list):
    result_list = []  # creates an empty list object to store the result
    index = -1  # uses negative indexing to start from the last item in the input list
    for item in input_list:  # loops through input list
        result_list.append(input_list[index])  # appends each item to the result
        index -= 1  # continues negative indexing until it reaches the beginning of the input list
    return result_list  # returns the result


print(test([""a"", ""b"", ""c"", ""d"", ""e""], ['e', 'd', 'c', 'b', 'a']))  # returns True
print(test([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]))  # returns True
print(test([], []))  # returns True
```",2020-11-02T09:38:39+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 5",edoardodalborgo,"```
from collections import deque

def test_my_reversed(input_list):
    deque_check = deque()
    deque_check.extend(input_list)
    for item in my_reversed(input_list):
        item_input_list = deque_check.pop()
        if item == item_input_list:
            continue
        else: return False
    return True

def my_reversed(input_list):
    output_deque = deque()
    output_reversed_list = []
    for item in input_list:
        output_deque.appendleft(item)
    output_reversed_list.extend(output_deque)
    return output_reversed_list

input_list = input(""Enter a list of objects divided by commas: "").split("", "")
print(test_my_reversed(input_list))
```",2020-11-02T10:49:37+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 5",AleRosae,"```
def test_my_reversed(input_list, expected):
    result = my_reversed(input_list)
    if result == expected:
        return True
    else:
        return False

def my_reversed(input_list):
    output_list = list()
    n = -1
    for item in input_list:
        output_list.append(input_list[n])
        n = n - 1
    return output_list

print(test_my_reversed(([0,1,2,3,4,5]), ([5,4,3,2,1,0])))
print(test_my_reversed(([5,4,3,2,1,0]), ([0,1,2,3,4,5])))
print(test_my_reversed(([0]), ([0])))
```",2020-11-03T15:54:00+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 5",AlessandraFa,"```
def test_my_reversed(input_list, expected):
    result = my_reversed(input_list)
    if result == expected:
        return True
    else:
        return False


def my_reversed(input_list):
    reversed_list = []
    a = len(input_list) - 1
    for position, item in enumerate(input_list):
        reversed_list.append(input_list[a-position])
    return reversed_list


print(test_my_reversed([0, 1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1, 0]))```",2020-11-04T21:45:09+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 5",yunglong28,"``` 
#This is my reversed function
def my_reversed(input_list):
    reversed_list = []
    c = len(input_list)
    while c > 0:
        c = c - 1
        reversed_list.append(input_list[c])

    return reversed_list
print(my_reversed([1, 2, 3]))

``` 
``` 
#This is my test

def test_my_reversed (input_list, expected):
    result = my_reversed(input_list)
    if result == expected:
        return True
    else:
        return False
print(test_my_reversed([1, 2, 3], [3, 2, 1]))

``` ",2020-11-05T10:44:06+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 5",SusannaPinotti,"```
# negative indexing: -1 to refer to the last item of a list

def test_my_reverse(input_list, expected):
    res = my_reverse(input_list)
    if expected == res:
        return True
    else:
        return False

def my_reverse(input_list):
    reversed_list= list()
    n = -1
    for item in input_list:
        reversed_list.append(input_list[n])
        n -= 1
    return reversed_list

print(test_my_reverse([""a"", ""c"", ""c"", ""o"", ""r"", ""r"", ""a""], [""a"", ""r"", ""r"", ""o"", ""c"", ""c"", ""a""])) #returns True
print(test_my_reverse(["""", 0, ""a""], [""a"", 0, """"])) #returns True
```",2020-11-05T11:07:31+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 5",IlaRoss,"```
#test
def test_my_reversed(input_list, reversed_list):
    result = my_reversed(input_list)
    if result == reversed_list:
        return True
    else:
        return False

#algorithm
def my_reversed(input_list):
    reversed_list = list()

    for item in input_list:
        reversed_list.insert(0, item)

    return reversed_list


#variables
my_list = ['Slater', 'Murgi', 'Giammei', 'Fleur', 'Virginia', 'Chiru']
my_reversed_list = ['Chiru', 'Virginia', 'Fleur', 'Giammei', 'Murgi', 'Slater']

#test runs
print(test_my_reversed(my_list, my_reversed_list))
print(test_my_reversed([3, 3, 5, 5, 6, 3, 4, 2, 9, 6], [6, 9, 2, 4, 3, 6, 5, 5, 3, 3]))
print(test_my_reversed(['Pink Floyd'], ['Pink Floyd']))

#algorithm execution
print(my_reversed(my_list))
print(my_reversed([6, 5, 4, 3, 2, 1]))
print(['Monteverdi'])
```",2020-11-05T15:10:43+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 5",vanessabonanno,"```
def test_my_reversed(input_list, expected):
    result = my_reversed(input_list)
    if result == expected:
        return True
    else:
        return False


def my_reversed(input_list):
    rev_list = []
    index = len(input_list) - 1

    while index >= 0:
        element = input_list.pop(index)
        index -= 1
        rev_list.append(element)
    return rev_list


# first test gives False as output because there is a not expected empty string
print(test_my_reversed(list(['e', 'n', 'g', 'a', 's', 'a','l']), ['l', 'a', 's', 'a', 'g', ' ', 'n', 'e']))
print(test_my_reversed(list([4, 5, 2, 3, 0]), [0, 3, 2, 5, 4]))  # output is True
print(my_reversed(list(['e', 'i', 'v', 'o', 'm'])))              # output is ['m', 'o', 'v', 'i', 'e']
```",2020-11-06T14:58:16+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 5",AlessandroBertozzi,"```
def test_my_reversed(input_list, expected):
    result = my_reversed(input_list)
    if result == expected:
        return True
    return False


def my_reversed(input_list):
    reversed_list = [input_list[-(elemento + 1)] for elemento in range(len(input_list))]
    return reversed_list


print(test_my_reversed([0, 1, 2], [2, 1, 0]))
print(test_my_reversed([0, 1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1, 0]))
print(test_my_reversed(['c', 'i', 'a', 'o'], ['o', 'a', 'i', 'c']))

```",2020-11-06T22:53:53+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 5",LuisAmmi,"```
def test_my_reversed(input_list, expected):
    result = my_reversed(input_list)
    if result == expected:
        return True
    else:
        return False


# code
def my_reversed(input_list):
    output_list = list()
    position = -1        #initialize position
    for item in input_list:
        output_list.insert(position, item)
        position -= 1
    return output_list


# return True
print(test_my_reversed([""0"", ""1"", ""2"", ""3""], [""3"", ""2"", ""1"", ""0""]))
print(test_my_reversed([""c"", ""d"", ""e""], [""e"", ""d"", ""c""]))
print(test_my_reversed([""""], [""""])) 
",2020-11-07T10:30:37+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 5",SarahTew,"````
def my_reversed(input_list):
    my_reversed_list=list()
    position=len(input_list)
    while position>0:
      position=position-1
      my_reversed_list.append(input_list[position])
    return(my_reversed_list)
   
print(my_reversed([""William"",""Sarah"", ""Lilly""]))
print(my_reversed([""First"", ""Middle"", ""Last""]))
print(my_reversed([3, 27.5, ""November"", """"]))

def test_my_reversed(input_list, expected):
    if my_reversed(input_list)==expected:
        return True
    else:
        return False
        
print(test_my_reversed([""William"", ""Sarah"", ""Lilly""], [""Lilly"", ""Sarah"", ""William""]))
print(test_my_reversed([""First"", ""Middle"", ""Last""], [""Last"", ""Middle"", ""First""]))
print(test_my_reversed([3, 27.5, ""November"", """"], ["""", ""November"", 27.5, 3]))
````",2020-11-07T13:25:36+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 5",SofiBar,"```
`def test_my_reversed(input_list, expected):
    if expected == my_reversed(input_list):
        return True
    else:
        return False

def my_reversed(input_list):
    output_list = []
    for item in input_list:
        output_list.insert(0, item)
    return output_list

input_list = [1, 2, 3, 4, 5, 6]
rev_list = [6, 5, 4, 3, 2, 1]
input_list2 = [""cerchio"", ""quadrato"", ""triangolo""]
rev_list2 = [""triangolo"", ""quadrato"", ""cerchio""]

print(test_my_reversed(input_list, rev_list))
print(test_my_reversed(input_list2, rev_list2))`
```",2020-11-12T16:21:19+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",edoardodalborgo,"```
def test_my_range(stop_number):
    counts = 0
    for a in my_range(stop_number):
        counts += 1
    if counts == stop_number:
        return True
    else: return False

def my_range(stop_number):
    my_range_list = []
    i = 0
    while i < stop_number:
        my_range_list.append(i)
        i += 1
    return my_range_list

x = int(input(""Enter the range that you would obtain: ""))
print(test_my_range(x))
```",2020-10-30T17:55:50+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",diegochillo,"```
def my_range(stop_number):
   my_range=list()
   n=0
   while (n<stop_number):
	my_range.insert(n,n)
	n=n+1
	
   return my_range


def test_my_range(stop_number, expected):
   result=my_range(stop_number)
   return result==expected

print(test_my_range(5, [0,1,2,3,4]))

```",2020-10-31T10:52:44+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",gabrielefiorenza,"```
def test_my_range(stop_number,expected):
    result = my_range(stop_number)
    if result == expected:
        return True
    else:
        return False

def my_range(stop_number):
    result = []
    number = 0
    result.append(number)
    while number != (stop_number -1):
        number += 1
        result.append(number)
    return result


print (test_my_range(4,[0,1,2,3]))
print (test_my_range(3,[0,1]))
```",2020-10-31T11:57:52+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",dbrembilla,"```
def test_my_range(stop_number, expected):
    result=my_range(stop_number)
    return result ==expected

def my_range(stop_number):
    x = 0
    my_range_list = list()
    while x < stop_number:
        my_range_list.append(x)
        x += 1
    return my_range_list

print(test_my_range(4, [0 , 1, 2, 3]))
```",2020-10-31T17:05:30+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",ChiaraCati,"```
# Test
def test_my_range(stop_number, expected):
    result = my_range(stop_number)
    if result == expected:
        return True
    else:
        return False

# Function    
def my_range(stop_number):
    my_list = []
    c=0
    while c < stop_number:
        my_list.append(c)
        c+=1
    return my_list
    
#print(my_range(6))

print(test_my_range(6, ([0, 1, 2, 3, 4, 5]))) # Output : True
print(test_my_range(4, ([1, 2, 3, 4])))  # Output : False
print(test_my_range(0, ([0]))) # Output : False
print(test_my_range(0, ([]))) # Output : True
```

me and Giorgia SampÃ² did it together

ðŸ‘­",2020-10-31T17:56:42+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",fcagnola,"```
# Write in Python the function def my_range(stop_number) which behaves like the
# built-in function range() introduced in Section ""Insertion sort"" and returns
# a proper list, and accompany the function with the related test case. It is
# not possible to use the built-in function range() in the implementation.

def test(stop_number, expected):
    result = my_range(stop_number)
    if result == expected:
        return True
    else:
        return False

def my_range(stop_number):
    result_list = [] # creates the final result, as a list object
    number = 0 # sets the starting point at 0
    while number != stop_number: # loops through integers between 0 and stop_number
        result_list.append(number) # adds each loop value to the final list
        number += 1
    return result_list #returns the result

print(test(5, [0, 1, 2, 3, 4])) # returns True
print(test(19, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])) # returns True
```",2020-10-31T19:38:37+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",AleRosae,"```
def test_my_range (stop_number, expected):
    result = my_range(stop_number)
    if result == expected:
        return True
    else:
        return False

def my_range(stop_number):
    n = 0
    my_list = list ()
    while n != stop_number:
        my_list.append(n)
        n=n + 1


    return my_list

print(test_my_range((4), [0, 1, 2, 3]))
print(test_my_range((10), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]))
print(test_my_range((0), []))
```",2020-11-03T14:33:24+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",AlessandraFa,"```
def test_my_range(stop_number, expected):
    result = my_range(stop_number)
    if result == expected:
        return True
    else:
        return False


def my_range(stop_number):
    a = 0
    range_list = list()
    while a < stop_number:
        range_list.append(a)
        a += 1
    return range_list


print(test_my_range((8), [0, 1, 2, 3, 4, 5, 6, 7]))
print(test_my_range((1), [0]))
```",2020-11-04T20:43:21+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",yunglong28,"``` 
#This is the function that simulates range()

def my_range (stop_number):
    range = []
    n = 0
    while n < stop_number:
        range.append(n)
        n=n+1
    return range
print(my_range(8))
``` 

``` 
#This is the test function
def test_myrange (stop_number, expected):
    result = my_range(stop_number)
    if result == expected:
        return True
    else:
        return False
print(test_myrange(8, [0, 1, 2, 3, 4, 5, 6, 7]))
``` ",2020-11-05T09:26:41+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",SusannaPinotti,"```
def test_my_range(stop_number, expected):
    res = my_range(stop_number)
    if expected == res:
        return True
    else:
        return False

def my_range(stop_number):
    output_list = list()
    n = 0
    while n < stop_number:
        output_list.append (n)
        n += 1
    return output_list

print(test_my_range((6), [0,1,2,3,4,5])) #return True
print(test_my_range((0), [])) #returns True
print(test_my_range((0), [0])) #return False
``` ",2020-11-05T10:19:42+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",IlaRoss,"```
#test
def test_my_range(stop_number, range_list):
    result = my_range(stop_number)
    if result == range_list:
        return True
    else:
        return False

#algorithm
def my_range(stop_number):
    range_list = list()
    prov_list = list()
    prov_number = (stop_number-1)

    if stop_number == 0:
        return range_list

    elif stop_number < 0:
        return 'Error'

    else:

        while prov_number >= 0:
            prov_list.append(prov_number)
            prov_number -= 1

        for item in prov_list:
            range_list.insert(0, item)

        return range_list



#test runs
print(test_my_range(5, [0, 1, 2, 3, 4]))
print(test_my_range(0, []))
print(test_my_range(-3, 'Error'))

#algorithm execution
print(my_range(12))
print(my_range(0))
print(my_range(-15))
```",2020-11-05T15:09:15+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",LuisAmmi,"```
# test
def test_my_range(stop_number, expected):
    result = my_range(stop_number)
    if result == expected:
        return True
    else:
        return False


# code
def my_range(stop_number):
    output_list = list()
    n = 0                  # initialize n
    while n != stop_number:
        output_list.append(n)
        n += 1
    else:
        return output_list


print(test_my_range(3, [0, 1, 2]))
print(test_my_range(2, [0, 1]))
print(test_my_range(0, []))```",2020-11-05T18:56:03+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",vanessabonanno,"```
def test_my_range(stop_number, expected):
    result = my_range(stop_number)
    if expected == result:
        return True
    else:
        return False


def my_range(stop_number):
    my_list = []
    x = 0
    while x < stop_number:
        my_list.append(x)
        x += 1
    return my_list


print(test_my_range(4, [0, 1, 2, 3]))# output: True
print(test_my_range(2, [1, 2]))      # output: False (starting number will be 0,
                                     # not 1 because x=0; 2 is not included in list since
                                     # there is '<' and not 'less or equal to')
print(my_range(4))                   # [0, 1, 2, 3]


```",2020-11-06T14:13:33+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",AlessandroBertozzi,"```
def test_my_range(stop_number, expected):
    result = my_range(stop_number)
    if result == expected:
        return True
    return False


def my_range(stop_number):
    counter = 0
    list_number = []
    while counter < stop_number:
        list_number.append(counter)
        counter += 1
    return list_number


print(test_my_range(3, [0, 1, 2]))
print(test_my_range(7, [0, 1, 2, 3, 4, 5, 6]))
print(test_my_range(0, []))
```",2020-11-06T22:53:22+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",SarahTew,"````#my_range function

def my_range(stop_number):
    if stop_number>=0:
        n=0
        range_result=list()
        while n<stop_number:
            range_result.append(n)
            n=n+1
        return(range_result)
    else:
        return(""Negative Number!"")
        
#print ranges    
print(my_range(5))
print(my_range(3))
print(my_range(-5))
print(my_range(0))
print(my_range(3.3))

#test my_range function
def test_my_range(stop_number, expected):
    result=my_range(stop_number)
    if result==expected:
        return True
    else:
        return False
print(test_my_range(3, [0, 1, 2]))
print(test_my_range(0, []))
print(test_my_range(-9, ""Negative Number!""))
````",2020-11-07T12:18:47+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",essepuntato,"Hi all,

A general comment: can you try to run the `range` function in Python with the following input, to see what actually happens? Does your function work as the original one?

```
range(-4)
```",2020-11-09T08:35:06+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 4",SofiBar,"exercise 4:
```
`def test_my_range(stop_number, expected):
    if expected == my_range(stop_number):
        return True
    else:
        return False

def my_range(stop_number):
    count = 0
    output_list = []

    while count < stop_number:
        output_list.append(count)
        count += 1
    return output_list


print(test_my_range(5, [0, 1, 2, 3, 4]))
print(test_my_range(7, [0, 1, 2, 3, 4, 5, 6]))
print(test_my_range(4, [0, 1, 2, 3]))
````

Range issue: 
if I write a negative number my function returns an empty list because -4 is less than 0 so the condition is never true.
",2020-11-12T11:25:25+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 3",edoardodalborgo,"```
def test_my_enumerate(input_list):
    for tuple in my_enumerate(input_list):
        item = input_list[tuple[0]]
        if tuple[1] == item:
            continue
        return False
    return True

def my_enumerate(input_list):
    enumerate_list = []
    for item in input_list:
        index = input_list.index(item)
        tuple = (index, item)
        enumerate_list.append(tuple)
    return enumerate_list
```",2020-10-30T16:58:12+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 3",diegochillo,"```
# This is the function that enumerates without the use of ""enumerate""
def my_enumerate(input_list):
  myenum=list()
  n=0
  for item in input_list:
    myenum.append((n,item))
    n=n+1
  return myenum

def test_my_enumerate(input_list, expected):
    result = my_enumerate(input_list)
    if expected == result:
        return True
    else:
        return False

print(test_my_enumerate([""Rick"",""Morty"",""Mr.Poopybutthole"",""Mr.Meeseeks""],[(0,""Rick""),(1,""Morty""),(2,""Mr.Poopybutthole""),(3,""Mr.Meeseeks"")]))
```",2020-10-31T10:21:57+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 3",gabrielefiorenza,"```
def test_my_enumerate(input_list,expected):
    result = my_enumerate(input_list)
    if result == expected:
        return True
    else:
        return False


def my_enumerate(input_list):
    result = []
    for item in input_list:
        list = []
        idx = input_list.index(item)
        list.append(idx)
        list.append(item)
        tupl = tuple(list)
        result.append(tupl)
    return result


print(test_my_enumerate([""cat"", ""dog"", ""lion"",""fish""],[(0,""cat""), (1,""dog""), (2,""lion""), (3,""fish"")]))
print(test_my_enumerate([""cat"", ""dog"", ""lion"",""fish""],[(3,""cat""), (2,""dog""), (1,""lion""), (0,""fish"")]))
```",2020-10-31T11:56:23+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 3",ChiaraCati,"```
def my_enumerate(input_list):
    list_item = []
    my_tuple = ()
    for item in input_list:
        my_tuple = 0
        my_tuple = (input_list.index(item), item)
        list_item.append(my_tuple)
    return list_item
        

print(my_enumerate(['cane', 'gatto', 'asino','topo']))
```


me and Giorgia SampÃ² did it together 

:two_women_holding_hands:
--


",2020-10-31T16:21:01+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 3",fcagnola,"```
# Write in Python the function def my_enumerate(input_list)
# which behaves like the built-in function enumerate() introduced
# in Section ""Linear search"" and returns a proper list, and
# accompany the function with the related test case. It is not
# possible to use the built-in function enumerate() in the implementation.

# enumerate has input = list and output [(position, value), (position, value)]

def my_enumerate(input_list):
    enum_object = [] # creates empty enum obj which will store result
    position = 0 # sets index to 0 to start the count

    for item in input_list: # loops through items in list
        iteration_value = tuple((position, item)) # creates a tuple with index, value
        enum_object.append(iteration_value) # appends tuple to final result
        position += 1 # adds 1 to the indexing
    return enum_object # returns final result in list format


listOne = [1, 2, 3, 4]
listTwo = [""a"", ""b"", ""c"", ""d""]

print(my_enumerate(listOne)) # output: [(0, 1), (1, 2), (2, 3), (3, 4)]
print(my_enumerate(listTwo)) # output: [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]
```",2020-10-31T19:24:38+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 3",AleRosae,"```
def test_my_enumerate (input_list, expected):
    result = my_enumerate(input_list)
    if expected == result:
        return True
    else:
        return False


def my_enumerate(input_list):
    output_list = list()

    for item in input_list:
        output_list.append(input_list.index(item))
        output_list.append(item)

    return output_list


print(test_my_enumerate([""Wild Light"", ""No Man's Sky"", ""The Fall of Math"", ""replicr""], [0, ""Wild Light"", 1, ""No Man's Sky"",2, ""The Fall of Math"", 3, ""replicr""]))
print(test_my_enumerate([""Nostalghia"", ""Stalker"", ""The Mirror"", ""Solaris""], [0,""Nostalghia"", 1, ""Stalker"", 2, ""The Mirror"", 3, ""Solaris""]))
```",2020-11-03T11:39:13+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 3",yunglong28,"```
#This is the test for the function

def test_enumeration(input_list, expected):
    result = enumeration(input_list)
    if result == expected:
        return True
    else:
        return False
print(test_enumeration(list1, [(0, 'Harry'), (1, 'Ron'), (2, 'Hermione'), (3, 'Snape')]))

```


```
#This is the function that enumerates 
def enumeration(input_list):
  my_numeration=list()
  n=0
  for item in input_list:
    my_numeration.append((n,item))
    n=n+1
  return my_numeration

list1= ['Harry', 'Ron', 'Hermione', 'Snape']
print(my_numeraton(list1))

```
",2020-11-03T15:41:40+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 3",AlessandraFa,"```
def test_my_enumerate(input_list, expected):
    result = my_enumerate(input_list)
    if result == expected:
        return True
    else:
        return False


def my_enumerate(input_list):
    position = 0
    output_list = list()
    for item in input_list:
        output_list.append((position, item))
        position += 1
    return output_list


print(test_my_enumerate(list([""Minerva"", ""Ginny"", ""Hermione"", ""Luna"", ""Hedwig""]),
[(0, ""Minerva""), (1, ""Ginny""), (2, ""Hermione""), (3, ""Luna""), (4, ""Hedwig"")]))

print(test_my_enumerate(list([""Leonardo"", ""Michelangelo"", ""Donatello"", ""Raffaello""]),
[(0, 'Leonardo'), (1, 'Michelangelo'), (2, 'Donatello'), (3, 'Raffaello')]))

```",2020-11-04T19:30:59+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 3",SusannaPinotti,"```
def test_my_enumerate(input_list, expected):
    res = my_enumerate(input_list)
    if expected == res:
        return  True
    else:
        return False

def my_enumerate(input_list):
    my_tuple = list()
    position = 0
    for item in input_list:
        my_tuple.append((position , item))
        position +=1
    return my_tuple

print(test_my_enumerate([""a"", ""b"", ""c""], [(0, ""a""), (1, ""b""), (2, ""c"")])) #returns True 
```
",2020-11-05T10:02:18+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 3",IlaRoss,"```
#test
def test_my_enumerate (input_list, output_list):
    result = my_enumerate (input_list)
    if result == output_list:
        return True
    else:
        return False

#algorithm
def my_enumerate (input_list):
    output_list = list()
    position = 0

    for item in input_list:
        my_tuple = (position, item)
        output_list.append(my_tuple)
        position += 1

    return output_list

#variables for short
my_list = ['Slater', 'Murgi', 'Giammei', 'Fleur', 'Virginia', 'Chiru']
my_enumeration = [(0, 'Slater'), (1, 'Murgi'), (2, 'Giammei'), (3, 'Fleur'), (4, 'Virginia'), (5, 'Chiru')]

#some test runs
print(test_my_enumerate(my_list, my_enumeration))
print(test_my_enumerate(['Pink Floyd', 'Bach', 'Haendel', 'Vivaldi', 'Monteverdi', 'Marenzio'], [(0, 'Pink Floyd'), (1, 'Bach'), (2, 'Haendel'), (3, 'Vivaldi'), (4, 'Monteverdi'), (5, 'Marenzio')]))
print(test_my_enumerate(list(), list()))
print(test_my_enumerate(['Marte'], [(0, 'Marte')]))

#execution algorithm
print(my_list)
print(my_enumerate(my_list))
```",2020-11-05T15:07:51+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 3",LuisAmmi,"```
# test
def test_my_enumerate(input_list, expected):
    result = my_enumerate(input_list)
    if result == expected:
        return True
    else:
        return False


# code
def my_enumerate(input_list):
    output_list = list()
    for item in input_list:
        index = input_list.index(item)  # it returns the position od the item that is running in the algorithm
        output_tuple = (index, item) 
        output_list.append(output_tuple)
    return output_list


print(test_my_enumerate([""a"", ""b"", ""c""], [(0, 'a'), (1, 'b'), (2, 'c')]))   # return true
print(test_my_enumerate([""chico""], [(0, 'chico')])) #return True
print(test_my_enumerate([""""], [(0, 'a')])) #return False ```",2020-11-05T17:40:33+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 3",SarahTew,"````
# function
def my_enumerate(input_list):
    my_enumerated_list=list()
    position = 0
    for item in input_list:
        my_enumerated_list.append((position, item))
        position=position + 1
    return my_enumerated_list

# test function
def test_my_enumerate(input_list, expected):
    result = my_enumerate(input_list)
    if result == expected:
        print(True)
    else: 
        print(False)

#test that function works properly
test_my_enumerate(['William', 'Sarah', 'Lilly'], [(0, 'William'), (1, 'Sarah'), (2, 'Lilly')])

#print various enumerated lists
print(my_enumerate(['William', 'Sarah', 'Lilly']))
print(my_enumerate(['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']))
````
",2020-11-06T18:43:45+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 3",AlessandroBertozzi,"```
def test_my_enumerate(input_list, expected):
    result = my_enumerate(input_list)
    if result == expected:
        return True
    return False


def my_enumerate(input_list):
    enumerate_list = [(number, input_list[number]) for number in range(len(input_list))]
    return enumerate_list


print(test_my_enumerate(['a', 'b'], [(0, 'a'), (1, 'b')]))
print(test_my_enumerate(['ciao', 'anche', 'a', 'te'], [(0, 'ciao'), (1, 'anche'), (2, 'a'), (3, 'te')]))
print(test_my_enumerate([70, 26], [(0, 70), (1, 26)]))

```",2020-11-06T22:52:24+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 3",SofiBar,"`color_list = [""green"", ""red"", ""black"", ""blue"", ""orange"", ""yellow""]


def test_my_enumerate(input_list, expected):
    result = my_enumerate(input_list)
    if result == expected:
        return True
    else:
        return False


def my_enumerate(input_list):
    my_enumerate_list = []

    for item in input_list:
        ind = input_list.index(item)
        new_item = ind, item
        my_enumerate_list.append(new_item)
    return my_enumerate_list


print(my_enumerate(color_list))

print(test_my_enumerate(color_list, [(0, 'green'), (1, 'red'), (2, 'black'), (3, 'blue'), (4, 'orange'), (5, 'yellow')]))
`",2020-11-08T20:58:24+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 3",essepuntato,"Hi all,

A general comment: for all of you that have used the method `index`, can you please try your function by using the following input, to see if it works correctly?

```
[""a"", ""b"", ""a"", ""b"", ""a"", ""b"", ""c""]
```",2020-11-09T08:33:15+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",edoardodalborgo,"```
from collections import deque

def test_stack_from_list(input_list):
    result = stack_from_list(input_list)
    for item in reversed(input_list):
        y = result.pop()
        if y == item:
            continue
        else: return False
    return True

def stack_from_list(input_list):
    output_stack = deque()
    for item in input_list:
        output_stack.append(item)
    return output_stack
```",2020-10-30T16:49:02+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",ChiaraCati,"```
from collections import deque
# test
def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if result == expected:
        return True
    else:
        return False


# function
def stack_from_list(input_list):
    output_stack = deque()
    for item in input_list:
        output_stack.append(item)
    return output_stack


print(test_stack_from_list(([""Doctor Who"", ""The Dark Crystal"", ""Stranger Things"", ""The Mandalorian""]),
                           deque([""Doctor Who"", ""The Dark Crystal"", ""Stranger Things"", ""The Mandalorian""])))
# return True
print(test_stack_from_list(([""Doctor Who"", ""The Dark Crystal"", ""Stranger Things"", ""The Mandalorian""]),
                           deque([""Doctor Who"", ""Stranger Things"", ""The Dark Crystal"", ""The Mandalorian""])))
# return False, the order is the same as the input list
print(test_stack_from_list(([""Doctor Who"", ""The Dark Crystal"", ""Stranger Things"", ""The Mandalorian""]),
                           deque([1, 2, 3, 4])))
# return False, function returns strings, not numbers
print(test_stack_from_list(([""Doctor Who"", """", ""Stranger Things"", ""The Mandalorian""]),
                           deque([""Doctor Who"", """", ""Stranger Things"", ""The Mandalorian""])))
# return True, function accepts blank items in list
```",2020-10-30T16:59:15+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",giorgiasampo,"'''
def test_stack(input_list, expected):
    result = stack_from_list(input_list)
    if result == expected:
      return True
    else:
      return False



from collections import deque


def stack_from_list(input_list):
    output_stack = deque() 

    for item in input_list:
        output_stack.append(item)

    return output_stack

print (test_stack([""a"",""b"",""c""], deque(['a', 'b', 'c'])))
print (test_stack([""ciao"",""hello"",""bonjour""], deque(['ciao', 'hello', 'bonjour'])))
print (test_stack([""""], deque([''])))
'''",2020-10-30T17:02:44+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",diegochillo,"```
from collections import deque

# Test case for the function
def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    return expected == result
  

# Code of the function
def stack_from_list(input_list):
    output_stack = deque()  # the stack to create

    # Iterate each element in the input list and add it to the stack
    for item in input_list:
        output_stack.append(item)

    return output_stack


# Three different test runs returning True
print(test_stack_from_list([], deque()))
print(test_stack_from_list(list([1, 2, 3, 4, 5]), deque([1, 2, 3, 4, 5])))
print(test_stack_from_list([""Rick"", ""Morty"", ""Summer"", ""Beth"", ""Jerry""], deque([""Rick"", ""Morty"", ""Summer"", ""Beth"",""Jerry""])))
```",2020-10-31T10:11:35+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",gabrielefiorenza,"```
from collections import deque

def test_stack_from_list (input_list, expected):
    result = stack_from_list(input_list)
    if result == expected:
        return True
    else:
        return False
```",2020-10-31T11:55:22+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",dbrembilla,"```
from collections import deque

def test_stack(input_list, expected):
    result = stack_from_list(input_list)
    return result == expected

def stack_from_list(input_list):
    output_stack = deque() # the stack to create
# Iterate each element in the input list and add it to the stack
    for item in input_list:
        output_stack.append(item)
    return output_stack

tv= list([""The Office"", ""Lost"", ""Fargo""])

print(test_stack(tv, deque([""The Office"", ""Lost"", ""Fargo""])))
```",2020-10-31T13:45:34+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",fcagnola,"```
from collections import deque

def test(input_list, expected):
    result = stack_from_list(input_list)
    if result == expected:
        return True
    else:
        return False

def stack_from_list(input_list):
    output_stack = deque() # the stack to create

    # Iterate each element in the input list and add it to the stack
    for item in input_list:
        output_stack.append(item)

    return output_stack

#Define a test case.
print(test([2, 4, 6, 8, 10, 12], deque([2, 4, 6, 8, 10, 12]))) # returns True
print(test([""a"", ""b"", ""c"", ""f""], deque([""a"", ""b"", ""c"", ""f""]))) # returns True
```",2020-10-31T17:57:49+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",AleRosae,"```
from collections import deque
   def test_stack_from_list (input_list, expected):
   result = stack_from_list(input_list)
    if expected == result:
        return True
    else:
        return False
```

```
def stack_from_list(input_list):
    output_stack = deque() # the stack to create

    # Iterate each element in the input list and add it to the stack
    for item in input_list:
        output_stack.append(item)
    return output_stack
```

```
#tests

print(test_stack_from_list(list([""Lost"", ""OA"", ""Dark"", ""The Office""]), deque([""Lost"", ""OA"", ""Dark"", ""The Office""])))
print(test_stack_from_list(list([""JoJo"", ""Psycho Pass"", ""Promise Neverland"", ""Made in Abyss""]), deque([""JoJo"", ""Psycho Pass"", ""Promise Neverland"", ""Made in Abyss""])))
print(test_stack_from_list(list([""""]), deque([""""])))
```",2020-11-01T11:32:28+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",AlessandraFa,"```
from collections import deque


def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if result == expected:
        return True
    else:
        return False


def stack_from_list(input_list):
    output_stack = deque()
    for item in input_list:
        output_stack.append(item)
    return output_stack


# print(test_stack_from_list(list([]), deque([])))
print(test_stack_from_list(list([""The Beatles"", ""Rolling Stones"", ""Queen"", ""Pink Floyd""]), deque([""The Beatles"", ""Rolling Stones"", ""Queen"", ""Pink Floyd""])))
print(test_stack_from_list(list([""Bojack"", ""Diane"", ""Todd""]), deque([""Bojack"", ""Diane"", ""Todd""])))
```",2020-11-03T22:11:23+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",vanessabonanno,"```
from collections import deque

def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)

    if expected == result:
        return True
    else:
        return False


def stack_from_list(input_list):
    output_stack = deque() # the stack to create
    # Iterate each element in the input list and add it to the stack
    for item in input_list:
        output_stack.append(item)
    return output_stack

# test 1:
print(test_stack_from_list(list([""a"", ""c"", ""y"", ""x""]), deque(['a', 'c', 'y', 'x'])))  # this test returns True

# test 2:
print(test_stack_from_list(list([3, 4, 5, 6]), deque([3, ""4"", 5, 6])))                  # this test returns False, ""4"" is not a number

# test 3:
print(test_stack_from_list(list([""  "", ""-"", "" ""]), deque([""  "", ""-"", """"])))            # this test returns False, ""result"" is not equal to ""expected""

```",2020-11-04T16:09:31+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",SusannaPinotti,"```
from collections import deque

def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if expected == result:
        return True
    else:
        return False

def stack_from_list(input_list):
    output_stack = deque()
    for item in input_list:
        output_stack.append(item)
    return output_stack

print(test_stack_from_list([""Annie Hall"",""Manhattan"",""Match Point"", ""Midnight in Paris""], deque([""Annie Hall"",""Manhattan"",""Match Point"", ""Midnight in Paris""]))) #returns True
print(test_stack_from_list([""Journal of Nutrition"", ""Science"", ""The Lancet""], deque([""Journal of Nutrition"", ""Science"", ""The Lancet""]))) #returns True
print(test_stack_from_list([""s"", ""v"", 0], deque([""s"", ""v"", ""0""]))) #returns False 
```",2020-11-05T09:31:27+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",IlaRoss,"```
from _collections import deque

#test definition
def test_stack_from_list (input_list, output_stack):
    result = stack_from_list (input_list)
    if output_stack == result:
        return True
    else:
        return False

#algorithm definition
def stack_from_list(input_list):
    output_stack = deque()

    for item in input_list:
        output_stack.append(item)
    return output_stack


#definition variables for list and stack for short
my_list = [""Giammei"", ""Slater"", ""Murgi"", ""Virginia"", ""Chiru"", ""Fleur""]
my_stack = deque([""Giammei"", ""Slater"", ""Murgi"", ""Virginia"", ""Chiru"", ""Fleur""])

#three test runs
print(test_stack_from_list(my_list, my_stack))
print(test_stack_from_list(list(), deque(list())))
print(test_stack_from_list([2,3,5,4,1], deque([2,3,5,4,1])))
```",2020-11-05T09:55:39+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",LuisAmmi,"``` 
from collections import deque
# test
def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if result == expected:
        return True
    else:
        return False


# code
def stack_from_list(input_list):
    output_stack = deque()
    for item in input_list:
        output_stack.append(item)
    return output_stack


print(test_stack_from_list([""living room"", ""kitchen"", ""bedroom""], deque([""living room"", ""kitchen"", ""bedroom""]))) # return True
print(test_stack_from_list([], deque([]))) # return True
print(test_stack_from_list([1, 2, 3, 4, 5, 6], deque([1, 2, 3, 4, 5]))) #return False  ```",2020-11-05T14:51:00+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",SarahTew,"```
from collections import deque

def stack_from_list(input_list):
     output_stack = deque() # the stack to create
 #Iterate each element in the input list and add it to the stack
     for item in input_list:
          output_stack.append(item)
     return output_stack

#test 
def test_stack_from_list(input_list, expected):
      result = stack_from_list(input_list)
       if result == expected:
            return True
        else:
            return False

print (test_stack_from_list([""a"", ""b"", ""c"", ""d""], deque([""a"", ""b"", ""c"", ""d""]))) # returns True
print (test_stack_from_list([3, ""b"", 2.9, "" ""], deque([3, ""b"", 2.9, "" ""]))) # returns True
```


   ",2020-11-06T10:41:38+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",GiuliaMenna,"```
from collections import deque


def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if result == expected:
        return True
    else:
        return False


def stack_from_list(input_list):
    output_stack = deque()

    for item in input_list:
        output_stack.append(item)

    return output_stack

print(test_stack_from_list([10,75,114,2020],deque([10,75,114,2020])))
print(test_stack_from_list([""river"", ""lake"", ""sea"", ""ocean""],deque([""river"", ""lake"", ""sea"", ""ocean""])))
```",2020-11-06T15:59:55+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",SofiBar,"`from collections import deque

cities_list = [""Ottavia"", ""Leonia"", ""Trude""]
animal_list = [""dog"", ""cat"", ""butterfly""]
weather_list = [""sunny"", ""windy""]


def test_stack_from_list(input_list, expected):
    result = stack_from_list(input_list)
    if result == expected:
        return True
    else:
        return False


def stack_from_list(input_list):
    output_stack = deque()  

    for item in input_list:
        output_stack.append(item)

    return output_stack


print(test_stack_from_list(cities_list, deque(['Ottavia', 'Leonia', 'Trude'])))
print(test_stack_from_list(animal_list, deque(['dog', 'cat', 'butterfly'])))
print(test_stack_from_list(weather_list, deque(['sunny', 'windy'])))
`",2020-11-08T21:07:52+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 2",essepuntato,"Hi all,

Thanks for your solution. A few comments:

* @edoardodalborgo your testing function is not compliant with the template I've provided to you. In particular, it will always return a successful execution (also when the algorithm works incorrectly), since you do not have any way to specify what is the expected value.
* @ChiaraCati and @vanessabonanno, please remember that you can claim that an algorithm works correctly against the tests if all the tests are passed (i.e. they return `True`). As far as I can see, this is not true for some of your test.
* Remember to use the Markdown environment for preserving the spaces in your Python code, as reminded during the lectures.",2020-11-09T08:31:20+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 1",ChiaraCati,"```
# define a linear_search function that takes as input a list of books and the title of a book 
def linear_search( list_of_books, title):    
    
    for position, item in enumerate(list_of_books): 
    # at the beginning of every iteration the list is enumerated as follows: [(0, ""Coraline""), 
    # (1, ""American Gods""), (2, ""The Graveyard Book""), (3, ""Good Omens""), (4, ""Neverwhere"")]
        
        # start comparing the input title, with the item lists
        if item == title:
            return position

print(linear_search(list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]), ""The Sandman""))
```
Output `None`
```
# since in every iteration item == title False is returned, the function stops at the end of the list and returns 
# None as output
#This means that the input title is not contained in input list`
```",2020-10-30T16:29:47+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 1",giorgiasampo,"'''
#we define the list of books to search within
list_of_books = (""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere"")

#we then define the instruction to look for a specific title
linear_search (list_of_books, ""The Sandman"")

#for every step of the FOR EACH loop it will confront the item in the list with the given input and return it if they are the same
#the first execution should return the tuple generated by the enumeration of the list in input
#so in the first iteration we should have enumerate = [(0, ""Coraline""), (1""American Gods""), ("", ""The Graveyard Book""), (3, ""Good Omens""), (4, ""Neverwhere"")]

#Iteration 1
#position = 0
#item = ""Coraline""
#item == value_to_search is False
#Continue to the next iteration

#Iteration 2
#position = 1
#item = ""American Gods""
#item == value_to_search is False
#Continue to the next iteration

#Iteration 3
#position = 2
#item = ""The Graveyard Book""
#item == value_to_search is False
#Continue to the next iteration

#Iteration 4
#position = 3
#item = ""Good Omens""
#item == value_to_search is False
#Continue to the next iteration

#Iteration 5
#position = 4
#item = ""Neverwhere""
#item == value_to_search is False
#End of the possible iterations

#No matching items found in the given list
#return ""None"" and end the execution of the algorithm
'''",2020-10-30T16:43:35+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 1",edoardodalborgo,"```
def linear_search(input_list, value_to_search):
    for position, item in enumerate(input_list):
        if item == value_to_search:
            return position

list_of_books = [""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]
print(linear_search(list_of_books, ""The Sandman""))

When the function is called it runs a for/each loop that iterates on every tuple created
with enumerate function called with the argument list_of_books.
Every tuple contains 2 values: an item of the argument and its specific position in the list.
For every tuple(position, item) the function checks if the item interested in the iteration
is equal to the value_to_search, and if they are equal return the position of the item
in the list that we are looking for and the function stops. If the item of the iteration isn't
the same as the value searched, the function proceeds with another iteration of the for loop
and checks for another item in another tuple created by enumerate on the list.

In our case, we are searching for the item ""The Sandman"" in our list, but we don't have this item
in our list_of_books. In this case, the function iterate on every item of our list but don't catch
the item we were searching for and return the value None.

```",2020-10-30T16:46:59+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 1",diegochillo,"```

list_of_books = list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""])  
linear_search(list_of_books, ""The Sandman"")  

# FOR-EACH LOOP EXECUTION 
# enumerate(input_list) will result in:  
# enumerate([(0, ""Coraline""), (1, ""American Gods""),  
#            (2, ""The Graveyard Book""), (3, ""Good Omens""),  
#            (4, ""Neverwhere"")]) 
# 
# Iteration 1 
# position = 0 
# item = ""Coraline"" 
# item == value_to_search is False 
# Continue to the next iteration 
# 
# Iteration 2 
# position = 1 
# item = ""American Gods"" 
# item == value_to_search is False 
# Continue to the next iteration 
# 
# Iteration 3 
# position = 2 
# item = ""The Graveyard Book"" 
# item == value_to_search is False
# Continue to the next iteration
# 
# Iteration 4
# position = 3
# item = ""Good Omens""
# item == value_to_search is False
# Continue to the next iteration
# 
# Iteration 5
# position = 4
# item = ""Neverwhere"" 
# item == value_to_search is False
# END OF THE LIST
# Return None and end the execution of the algorithm
```",2020-10-31T09:24:16+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 1",dbrembilla,"```
def linear_search(input_list, value_to_search):

    for position, item in enumerate(input_list):

        if item == value_to_search:

        return position
linear_search(list([""Coraline"",
""American Gods"", ""The Graveyard Book"", ""Good Omens"",
""Neverwhere""]), ""The Sandman"")

# Loop execution:
# Iteration 1:
# position = 0
# item == value_to_search is False

# Iteration 2:
# position = 1
# item == value_to_search is False

# Iteration 3:
# position = 2
# item == value_to_search is False

# Iteration 4:
# position = 3
# item == value_to_search is False

# Iteration 5
# position = 4
# item == value_to_search is False
# no output
```",2020-10-31T13:32:23+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 1",AleRosae,"The linear search function is defined as follows:
```
def linear_search (input_list, value_to_search):
    for position, item in enumerate(input_list):
        if item == value_to_search:
            return position
```
the list of books in which we want to search for the value is the following:
`books_list = list[""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]`
the value we want to search for is: ""The Sandman""
`linear_search(books_list, ""The Sandman"")`

Function will iterate throughout the list considering each item one by one, in order to check whether the value is present.

iteration 1:
position = 0
item = ""Coraline""
item == value_to_search False


iteration 2:
position = 1
item = ""American Gods""
item == value_to_search False

iteration 3:
position = 2
item = ""The Graveyard Book""
item == value_to_search False

iteration 4:
position = 3
item = ""Good Omens""
item == value_to_search False

iteration 5:
position = 4
item = ""Neverwhere""
item == value_to_search False


Since ""The Sandman"" is not present in the list, `item == value_to_search` always returns `False`, thus `None `is returned as output",2020-10-31T17:22:04+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 1",fcagnola,"```
# Code of the algorithm
def linear_search(input_list, value_to_search):
    # iterate all the items in the input list, getting also their position on the list
    for position, item in enumerate(input_list):
        # check if the current item is equal to the value to search
        if item == value_to_search:
            # if so, the position of the current item is returned # and the algorithm stops
            return position

input_list = list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""])
print(linear_search(input_list, ""The Sandman""))


# The function defined as linear_search will take in input two parameters, 
# a list and a value to search. The execution will then iterate through a 
# for-each loop. Enumerate will return a list like the following
# [(0,""Coraline""), (1,""American Gods""), (2,""The Graveyard Book""), (3,""Good Omens""), (4,""Neverwhere"")]
# The algorithm will then iterate through said list in this way:

# 1st iteration:
# position = 0, item = ""Coraline""
# value_to_search == item returns False
# proceed to next iteration

# 2nd iteration:
# position = 1, item = ""American Gods""
# value_to_search == item returns False
# proceed to next iteration

# 3rd iteration:
# position = 2, item = ""The Graveyard Book""
# value_to_search == item returns False
# proceed to next iteration

# 4th iteration:
# position = 3, item = ""Good Omens""
# value_to_search == item returns False
# proceed to next iteration

# 5th iteration:
# position = 4, item = ""Neverwhere""
# value_to_search == item returns False
# end iteration and return None because the value was not in the list
```",2020-10-31T17:47:42+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 1",yunglong28,"```
#  Linear Search algorithm

def linear_search(input_list, value_to_search):
    for position, item in enumerate(input_list):
        if item == value_to_search:
            return position
```

```
#  List to search is:
list = [""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]
```

```
#  Execution:
print(linear_search(list, ""The Sandman"")
#  enumerate(list) will result in: 
enumerate ([(0, ""Coraline""), (1, ""American Gods""), (2, ""The Graveyard Book""), (3, ""Good Omens""), (4, ""Neverwhere"")])

#  Iteration 1
#  position = 0
#  item = ""Coraline""
#  item == value_to_search is False
#  Continue to the next iteration

#  Iteration 2
#  position = 1
#  item = ""American Gods""
#  item == value_to_search is False
#  Continue to the next iteration

#  Iteration 3
#  position = 2
#  item = ""The Graveyard Book""
#  item == value_to_search is False
#  Continue to the next iteration

#  Iteration 4
#  position = 3
#  item = ""Good Omens""
#  item == value_to_search is False
#  Continue to the next iteration

#  Iteration 5
#  position = 4
#  item = ""Neverwhere""
#  item == value_to_search is False
#  the output is None and the for loop is stopped


```",2020-11-02T12:00:58+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 1",gabrielefiorenza,"list_of_books = list([""Coraline"", ""American Gods"",""The Graveyard Book"", ""Good Omens"",""Neverwhere""])
linear_search(list_of_books, ""The Graveyard Book"")

FOR-EACH LOOP EXECUTION
enumerate(input_list) will result in:
enumerate([(0, ""Coraline""), (1, ""American Gods""), (2, ""The Graveyard Book""), (3, ""Good Omens""), (4, ""Neverwhere"")])
Iteration 1
position = 0
item = ""Coraline""
item == value_to_search is False
Continue to the next iteration
Iteration 2
position = 1
item = ""American Gods""
item == value_to_search is False
Continue to the next iteration
Iteration 3
position = 2
item = ""The Graveyard Book""
item == value_to_search is False
Continue to the next iteration
Iteration 4
position = 3
item = ""Good Omens""
item == value_to_search is False
Continue to the next iteration
Iteration 5
position = 4
item = ""Neverwhere""
item == value_to_search is False
Return None.",2020-11-02T17:43:04+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 1",AlessandraFa,"```
# linear search algorithm:
def linear_search(input_list, value_to_search):
    for position, item in enumerate(input_list):
        if item == value_to_search:
            return position

# list to search:
list_of_books = [""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]
value_to_search = ""The Sandman""

print(list(enumerate(list_of_books)))
# Output: [(0, ""Coraline""), (1, ""American Gods""), (2, ""The Graveyard Book""), 
# (3, ""Good Omens""), (4, ""Neverwhere"")]
# Each tuple has the form (<position>, <item>); for-each algorithm compares each item with 
# the searched value. In this case, the items in list_of_books are compared to ""The Sandman"".

# Execution:

# Iteration 1:
# for position = 0, item = ""Coraline"":
# ""Coraline"" == ""The Sandman"" is False --> condition not met: execute Iteration 2

# Iteration 2:
# for position = 1, item = ""American Gods"":
# ""American Gods"" == ""The Sandman is False --> condition not met: execute Iteration 3

# Iteration 3:
# for position = 2, item = ""The Graveyard Book"":
# ""The Graveyard Book"" == ""The Sandman"" is False --> condition not met: execute iteration 4

# Iteration 4:
# for position = 3, item = ""Good Omens"":
# ""Good Omens"" == ""The Sandman"" is False --> condition not met: execute iteration 5

# Iteration 5:
# for position = 4, item = ""Neverwhere"":
# ""Neverwhere"" == ""The Sandman"" is False --> condition not met; end of the list.

# Since value ""The Sandman"" was not found in the list, the algorithm returns None and ends 
# the execution.

```",2020-11-03T21:52:41+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 1",vanessabonanno,"```
For-each loop execution

enumerate(list) will return:
-> enumerate([(0, ""Coraline""), (1, ""American Gods""), (2, ""The Graveyard Book""), (3, ""Good Omens""), (4, ""Neverwhere"")])

1st iteration:
position = 0
item = ""Coraline""
item == value_to_search FALSE 
go to next iteration

2nd iteration:
position = 1
item = ""American Gods""
item == value_to_search FALSE 
go to next iteration

3rd iteration:
position = 2
item = ""The Graveyard Book""
item == value_to_search FALSE 
go to next iteration

4th iteration:
position = 3
item = ""Good Omens""
item == value_to_search FALSE 
go to next iteration

5th iteration:
position = 4
item = ""Neverwhere""
item == value_to_search FALSE 
No others items in list

Python will end iterations of the for-each loop and will return ""None""
```",2020-11-04T15:46:05+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 1",IlaRoss,"Being the function `linear_search`:

```def linear_search (input_list, value_to_search):
       for position, item in enumerate (input_list):
           if item == value_to_search:
               return position
```

We execute it for `input_list = ([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""])` and `value_to_search = ""The Sandman""`

```
linear_search (list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]), ""The Sandman"")

#FOR-EACH Loop execution
#1st iteration
#position = 0
#item = ""Coraline""
#item == value_to_search is False
#Go back and continue with next iteration
#
#2nd iteration
#position = 1
#item = ""American Gods""
#item == value_to_search is False
#Go back and continue with next iteration
#
#3rd iteration
#position = 2
#item = ""The Graveyard Book""
#item == value_to_search is False
#Go back and continue with next iteration
#
#4th iteration
#position = 3
#item = ""Good Omens""
#item == value_to_search is False 
#Go back and continue with next iteration
#
#5th iteration
#position = 4
#item = ""Neverwhere""
#item == value_to_search is False
#No more items in the list. Iteration ends.
#
#As no match was found for ""The Sandman"", the function returns None and the execution ends.
```",2020-11-05T08:31:12+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 1",SusannaPinotti,"```
linear_search(list([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""]), ""The Sandman"")

#FOR-EACH LOOP EXECUTION 
#enumerate(input_list) will result in: 
#enumerate([( 0, ""Coraline""), (1, ""American Gods""), (2, ""The Graveyard Book""), (3, ""Good Omens""), (4, ""Neverwhere"")])
#
#Iteration 1 
#position = 0 
#item = ""Coraline""
#item == value_to_search is False
#next iteration is executed
#
#Iteration 2 
#position = 1 
#item = ""American Gods""
#item == value_to_search is False 
#next iteration is executed 
#
#Iteration 3
#position= 2
#item = ""The Graveyard Book""
#item == value_to_search is False 
#next iteration is executed
#
#Iteration 4 
#position = 3
#item = ""Good Omens""
#item == value_to_search is False 
#next iteration is executed 
#
#Iteration 5
#position = 4
#item = ""Neverwhere""
#item == value to search is False 
#the iteration stops 
#
#no value is returned since there is no match 


```",2020-11-05T09:15:02+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 1",LuisAmmi,"The first thing to do is to enumerate the values in the list. So, the algorithm gives us a new list with items associated with their own position. Then, the algorithm will check, one by one, all the item up to find the value specified in the definition of the function. 
```
def linear_search(list_of_book, value_to_search):
    for position, item in enumerate(list_of_book):
        if item == value_to_search:
            return position


print(linear_search([""Coraline"", ""American Gods"", ""The Graveyard Book"", ""Good Omens"", ""Neverwhere""],""The Sandman""))

The algorithm runs in this way:
# For-each loop execution
# enumerate(list_of_book) will return `enumerate[(0, ""Coraline""), (1, ""American Gods""), (2, ""The Graveyard Book""), (3, ""Good Omens""), (4, ""Neverwhere"")` 
# it starts with the first iteration:
# position = 0
# item = ""Coraline""
# item == value_to_search is False
# Continue to the next iteration

# Iteration 2
# position = 1
# item = ""American Gods""
# item == value_to_search is False
# Continue to the next iteration

# Iteration 3
# position = 2
# item = ""The Graveyard Book""
# item == value_to_search is False
# Continue to the next iteration

# Iteration 4
# position = 3
# item = ""Good Omens""
# item == value_to_search is False
# Continue to the next iteration

# Iteration 5
# position = 4
# item = ""Neverwhere""
# item == value_to_search is False

# So the value_to_search is not in the list. The algorithm returns None.

",2020-11-05T12:04:26+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 1",SarahTew,"   list_of_books = list([""Coraline"", ""American Gods"",
""The Graveyard Book"", ""Good Omens"",
""Neverwhere""])

linear_search(list_of_books, ""The Sandman"")

FOR-EACH LOOP EXECUTION
enumerate(input_list) will result in:
enumerate([(0, ""Coraline""), (1, ""American Gods""),
(2, ""The Graveyard Book""), (3, ""Good Omens""),
(4, ""Neverwhere"")])
Iteration 1
position = 0
item = ""Coraline""
item == value_to_search is False
Continue to the next iteration
Iteration 2
position = 1
item = ""American Gods""
item == value_to_search is False
Continue to the next iteration
Iteration 3
position = 2
item = ""The Graveyard Book""
item == value_to_search is False
Continue to the next iteration
Iteration 4
position = 3
item = ""Good Omens""
item == value_to_search is False
Continue to the next iteration
Iteration 5
position = 3
item = ""Neverwhere""
item == value_to_search is False
No more iterations
Return ""None""   ",2020-11-06T09:56:52+00:00
comp-think/2020-2021,"Lecture ""Brute-force algorithms"", exercise 1",GiuliaMenna,"```
def linear_search(input_list, value_to_search):
        for position,item in enumerate(input_list):
            if item == value_to_search:
                return position

input_list = [""Coraline"",""American Gods"",""The Graveyard Book"",""Good Omens"",""Neverwhere""]
value_to_search = ""The Sandman""
print(linear_search(input_list, ""The Sandman""))

#For-each Loop execution
#Position = 0
#Item = ""Coraline""
#Item == value_to_search is false
#Move to the next position

#Position = 1
#Item= ""American Gods""
#Item == value_to_search is false
#Move to the next position

#Position = 2
#Item = ""The Graveyard Book""
#Item == value_to_search is false
#Move to the next position

#Position =3
#Item =""Good Omens""
#Item == value_to_search is false
#Move to the next position

#Position = e
#Item = ""Neverwhere""
#Item == value_to_search is false
#for-each loop execution stops
#Output = None
```",2020-11-06T15:04:07+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",SarahTew,"1. my_queue = deque([""Harry"", ""Hermione"", ""Ron"", ""Severus""])
2. my_queue = deque([""Harry"", ""Hermione"", ""Ron"", ""Severus"", ""Voldemort""])
3. my_queue = deque([""Hermione"", ""Ron"", ""Severus"", ""Voldemort""])
",2020-10-26T11:01:45+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",ChiaraCati,"`my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])`
`my_queue.popleft()` returns: Harry, Hermione, Ron, Severus
`my_queue.append(""Voldemort"")` returns: Harry, Hermione, Ron, Severus, Voldemort
`my_queue.popleft()`returns: Hermione, Ron, Severus, Voldemort",2020-10-26T13:00:27+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",margheparla,"from collections import deque
my_queue= deque([""Draco"", ""Harry"",""Hermione"", ""Ron"", ""Severus""])
my_queue.popleft()
my_queue.append(""Voldemort"")
my_queue.popleft()
print(my_queue)",2020-10-26T13:21:33+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",yunglong28,"from _collections import deque   # This imports deque
my_queue = deque()   # This creates a new queue

my_queue.append(""Draco"")  # Now we add the elements
my_queue.append(""Harry"")
my_queue.append(""Hermione"")
my_queue.append(""Ron"")
my_queue.append(""Severus"")
deque(['Draco', 'Harry', 'Hermione', 'Ron', 'Severus'])

my_queue.popleft()  # Now we execute the exercise
my_queue.append(""Voldemort"")
my_queue.popleft()
print(my_queue)
deque(['Hermione', 'Ron', 'Severus', 'Voldemort'])",2020-10-26T14:31:22+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",AleRosae,"`from _collections import deque`
`my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])`
`my_queue.popleft()` # returns deque(['Harry', 'Hermione', 'Ron', 'Severus'])
`my_queue.append(""Voldemort"")` # returns deque(['Harry', 'Hermione', 'Ron', 'Severus', 'Voldemort'])
`my_queue.popleft() `#returns deque(['Hermione', 'Ron', 'Severus', 'Voldemort'])




",2020-10-26T15:45:56+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",laurentfintoni,"status 1 - deque([""Harry"", ""Hermione"", ""Ron"", ""Severus""])
status 2 - deque([""Harry"", ""Hermione"", ""Ron"", ""Severus"", ""Voldemort""])
status 3 - deque([""Hermione"", ""Ron"", ""Severus"", ""Voldemort""])",2020-10-26T16:07:14+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",dbrembilla,"`my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])`
After `my_queue.popleft()` `my_queue` contains `""Harry"", ""Hermione"", ""Ron"", ""Severus""`
After `my_queue.append(""Voldemort"")` `my_queue` contains `""Harry"", ""Hermione"", ""Ron"", ""Severus"", ""Voldemort""`
After `my_queue.popleft()` `my_queue` contains `""Hermione"", ""Ron"", ""Severus"", ""Voldemort""`",2020-10-26T16:11:11+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",edoardodalborgo,"```
from collections import deque
my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_queue.popleft() #it removes the string ""Draco"" from the queue and returns ""Draco""
my_queue.append(""Voldemort"") #it adds the string ""Voldemort"" at the end of the queue
my_queue.popleft() #it removes the string ""Harry"" from the queue and returns ""Harry""
print(my_queue) #the queue printed is: deque[""Hermione"", ""Ron"", ""Severus"", ""Voldemort""]

```",2020-10-26T16:12:53+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",vanessabonanno,"my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_queue.popleft()                       #current status: deque([""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_queue.append(""Voldemort"")  #current status: deque([""Harry"", ""Hermione"", ""Ron"", ""Severus"", ""Voldemort""])
my_queue.popleft()                       #current status: deque([""Hermione"", ""Ron"", ""Severus"", ""Voldemort""])",2020-10-26T16:53:02+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",AlessandraFa,"```
my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_queue.popleft() #removes first element left from my_queue
print(my_queue)

my_queue.append(""Voldemort"") #adds string ""Voldemort"" at the end of my_queue
print(my_queue)

result_b = my_queue.popleft() #removes first element left from my_queue
print(my_queue)

deque(['Harry', 'Hermione', 'Ron', 'Severus']) # ""Draco"" has been removed
deque(['Harry', 'Hermione', 'Ron', 'Severus', 'Voldemort']) # ""Voldemort"" has been added at the end
deque(['Hermione', 'Ron', 'Severus', 'Voldemort']) # ""Harry"" has been removed
```",2020-10-26T18:27:31+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",LuisAmmi,"```

my_queue = deque([""Draco"",""Harry"",""Hermione"",""Ron"",""Severus""]):
my_queue.popleft() #the first item is removed and the algorithm returns deque([""Harry"",""Hermione"",""Ron"",""Severus""])
my_queue.append(""Voldemort"") #addition of this item
my_queue.popleft() #returns deque([""Hermione"",""Ron"",""Severus"",""Voldemort""])

print(my_queue) #it will print [""Hermione"",""Ron"",""Severus"",""Voldemort""]

```",2020-10-26T20:53:13+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",gabrielefiorenza,"```
from collections import deque

my_queue = deque([""Draco"", ""Harry"",""Hermione"", ""Ron"", ""Severus""])
my_queue.popleft()
my_queue.append(""Voldemort"")
my_queue.popleft()

print(my_queue)
```

OUTPUT:
deque(['Hermione', 'Ron', 'Severus', 'Voldemort'])
",2020-10-27T10:27:39+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",penelopelask,"```
from collections import deque
my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_queue.popleft()
my_queue.append(""Voldemort"")
my_queue.popleft()
print(my_queue)

#will print
deque(['Hermione', 'Ron', 'Severus', 'Voldemort'])",2020-10-27T11:17:40+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",giorgiasampo,"Initial queue:  my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

1 - my_queue.popleft(): deque([""Harry"", ""Hermione"", ""Ron"", ""Severus""])
2 - my_queue.append(""Voldemort""): deque([""Harry"", ""Hermione"", ""Ron"", ""Severus"", ""Voldemort""])
3 -  my_queue.popleft(): deque([""Hermione"", ""Ron"", ""Severus"", ""Voldemort""])",2020-10-27T12:48:58+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",fcagnola,"The queue will remove the first element, then add one, and remove the new first.
Operations will result in the following outputs:
```[""Harry"", ""Hermione"", ""Ron"", ""Severus""]```
then
```[""Harry"", ""Hermione"", ""Ron"", ""Severus"", ""Voldemort""]```
and finally
```[""Hermione"", ""Ron"", ""Severus"", ""Voldemort""]```",2020-10-27T15:39:45+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",samuelespotti,"from collections import deque

my_queue = deque([""Draco"", ""Harry"",""Hermione"", ""Ron"", ""Severus""])
my_queue.popleft()
my_queue.append(""Voldemort"")
my_queue.popleft()

print(my_queue)

deque(['Hermione', 'Ron', 'Severus', 'Voldemort'])",2020-10-27T15:44:25+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",SusannaPinotti,"```
from collections import deque

my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

my_queue. popleft()
print(my_queue)

my_queue.append(""Voldemort"")
print(my_queue)

my_queue.popleft()
print(my_queue)


deque(['Harry', 'Hermione', 'Ron', 'Severus'])
deque(['Harry', 'Hermione', 'Ron', 'Severus', 'Voldemort'])
deque(['Hermione', 'Ron', 'Severus', 'Voldemort'])
```",2020-10-27T17:45:01+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",GiuliaMenna,"```
from collections import deque

my_queue = deque([""Draco"",""Harry"",""Hermione"",""Ron"",""Severus""])
my_queue.popleft()
my_queue.append(""Voldemort"")
my_queue.popleft()

print(deque)
```

deque = ([""Hermione"",""Ron"",""Severus"",""Voldemort""])",2020-10-27T17:51:03+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",enri-ca,"my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""]). 

my_stack.pop(), my_stack.pop() return
my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron""]).
my_stack = deque([""Draco"", ""Harry"", ""Hermione""])

my_stack.append(""Voldemort"") returns
my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Voldemort""])",2020-10-28T06:02:35+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",enri-ca,"my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
after: my_queue.popleft(), my_queue.append(""Voldemort""), my_queue.popleft() returns
([""Harry"", ""Hermione"", ""Ron"", ""Severus""])
([""Harry"", ""Hermione"", ""Ron"", ""Severus"", ""Voldemort""])
([""Hermione"", ""Ron"", ""Severus"", ""Voldemort""])",2020-10-28T06:08:47+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",alicebordignon,"from collections import deque
queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
queue.popleft()
print(queue) #(['Harry', 'Hermione', 'Ron', 'Severus'])
queue.append(""Voldemort"")
print(queue) #(['Harry', 'Hermione', 'Ron', 'Severus', 'Voldemort'])
queue.popleft()
print(queue) #(['Hermione', 'Ron', 'Severus', 'Voldemort'])",2020-10-29T08:43:08+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",DeniseBas,"from collections import deque
my_queue = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

my_queue.popleft()
my_queue.append(""Voldemort"")
my_queue.popleft()

print(my_queue)

deque(['Hermione', 'Ron', 'Severus', 'Voldemort'])",2020-10-29T15:20:00+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 3",IlaRoss,"my_queue:
after my_queue.popleft()  -->  my_queue = deque([""Harry"", ""Hermione"", ""Ron"", ""Severus""])
after my_queue.append(""Voldemort"")  -->  my_queue = deque([""Harry"", ""Hermione"", ""Ron"", ""Severus"", ""Voldemort"")]
after my_queue.popleft()  -->  my_queue = deque([""Hermione"", ""Ron"", ""Severus"", ""Voldemort"")]",2020-10-29T17:37:22+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",SarahTew,"1. my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron""])
2. my_stack = deque([""Draco"", ""Harry"", ""Hermione""])
3. my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Voldemort""])
",2020-10-26T10:59:18+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",ChiaraCati,"`my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])`
`my_stack.pop()` returns: Draco, Harry, Hermione, Ron 
`my_stack.pop()` returns: Draco, Harry, Hermione
`my_stack.append( ""Voldemort"")` returns: Draco, Harry, Hermione, Voldemort
",2020-10-26T12:57:23+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",margheparla,"from collections import deque

my_stack = deque([""Draco"", ""Harry"",""Hermione"", ""Ron"", ""Severus""])
my_stack.pop()
my_stack.pop()
my_stack.append(""Voldemort"")
print(my_stack)",2020-10-26T13:20:06+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",yunglong28,"from _collections import deque   # This imports deque
my_stack = deque()   # This creates a new stack


my_stack.append(""Draco"")  # Now we add the elements
my_stack.append(""Harry"")
my_stack.append(""Hermione"")
my_stack.append(""Ron"")
my_stack.append(""Severus"")
deque(['Draco', 'Harry', 'Hermione', 'Ron', 'Severus'])


my_stack.pop()  # Now we execute the exercise
my_stack.pop()
my_stack.append(""Voldemort"")
print(my_stack)
deque(['Draco', 'Harry', 'Hermione', 'Voldemort'])",2020-10-26T14:27:37+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",AleRosae,"```
from _collections import deque
my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_stack.pop() # returns deque(['Draco', 'Harry', 'Hermione', 'Ron'])
my_stack.pop() # returns deque(['Draco', 'Harry', 'Hermione'])
my_stack.append(""Voldemort"") # returns deque(['Draco', 'Harry', 'Hermione', 'Voldermort'])",2020-10-26T15:39:18+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",dbrembilla,"`my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""]). `
After `my_stack.pop() `, `my_stack`  would contain `""Draco"", ""Harry"", ""Hermione"", ""Ron""`
After again `my_stack.pop()` `my_stack` would contain `""Draco"", ""Harry"", ""Hermione""`
After `my_stack.append(""Voldemort"")`, `my_stack`  would contain `""Draco"", ""Harry"", ""Hermione"", ""Voldemort""`",2020-10-26T16:00:32+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",edoardodalborgo,"```
from collections import deque
my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_stack.pop() #it removes the last string of the stack (""Severus"") and return ""Severus""
my_stack.pop() #it removes the last string of the stack (""Ron"") and return ""Ron""
my_stack.append(""Voldemort"") #it adds the string ""Voldemort"" at the end of the stack
print(my_stack) #it prints deque[""Draco"", ""Harry"", ""Hermione"", ""Voldemort""]

```",2020-10-26T16:00:51+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",laurentfintoni,"status 1 - deque([""Ron"", ""Hermione"", ""Harry"", ""Draco""])
status 2 - deque([""Hermione"", ""Harry"", ""Draco""])
status 3 - deque([""Voldemort"", ""Hermione"", ""Harry"", ""Draco""])",2020-10-26T16:04:01+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",vanessabonanno,"my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_stack.pop()                           #current status: deque([""Draco"", ""Harry"", ""Hermione"", ""Ron""])
my_stack.pop()                           #current status: deque([""Draco"", ""Harry"", ""Hermione""])
my_stack.append(""Voldemort"") #current status: deque([""Draco"", ""Harry"", ""Hermione"", ""Voldermort""])",2020-10-26T16:46:35+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",AlessandraFa,"```
from collections import deque
my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_stack.pop()
print(my_stack)

my_stack.pop()
print(my_stack)

my_stack.append(""Voldemort"")
print(my_stack)

# Output:
deque(['Draco', 'Harry', 'Hermione', 'Ron']) # the last item of the deque (""Severus"") is returned and removed
deque(['Draco', 'Harry', 'Hermione']) # after deleting ""Severus"", the last item of the deque is ""Ron"", which is again returned and removed from my_stack
deque(['Draco', 'Harry', 'Hermione', 'Voldemort']) # The string ""Voldemort"" is added at the end of the deque
```",2020-10-26T18:09:53+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",LuisAmmi,"```

my_stack = deque([""Draco"",""Harry"",""Hermione"",""Ron"",""Severus""]):
my_stack.pop() #the last item is removed and the algorithm returns deque([""Draco"",""Harry"",""Hermione"",""Ron""])
my_stack.pop() #returns deque([""Draco"",""Harry"",""Hermione""])
my_stack.append(""Voldemort"") #addition of this item
print(my_stack) #it will print [""Draco"",""Harry"",""Hermione"",""Voldemort""]

```",2020-10-26T20:31:18+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",gabrielefiorenza,"```
from collections import deque

my_stack = deque([""Draco"", ""Harry"",""Hermione"", ""Ron"", ""Severus""])
my_stack.pop()
my_stack.pop()
my_stack.append(""Voldemort"")

print(my_stack)
```
OUTPUT:
deque(['Draco', 'Harry', 'Hermione', 'Voldemort'])",2020-10-27T10:25:50+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",penelopelask,"```
from collections import deque
my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_stack.pop()
my_stack.pop()
my_stack.append(""Voldemort"")
print(my_stack)

deque(['Draco', 'Harry', 'Hermione', 'Voldemort'])",2020-10-27T11:08:34+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",giorgiasampo,"Initial stack: my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

1 - my_stack.pop(): my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron""])
2 - my_stack.pop(): my_stack = deque([""Draco"", ""Harry"", ""Hermione""])
3 - my_stack.append(""Voldemort""): my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Voldemort""])",2020-10-27T12:45:58+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",fcagnola,"The stack will first eliminate the last element, then the second-to last, and then add the new one.
Each step will modify the stack as follows:
``` [""Draco"", ""Harry"", ""Hermione"", ""Ron""]```
then
``` [""Draco"", ""Harry"", ""Hermione""]```
and finally
``` [""Draco"", ""Harry"", ""Hermione"", ""Voldemort""]```
",2020-10-27T15:37:07+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",samuelespotti,"from collections import deque

my_stack = deque([""Draco"", ""Harry"",""Hermione"", ""Ron"", ""Severus""])
my_stack.pop()
my_stack.pop()
my_stack.append(""Voldemort"")

print(my_stack)

deque(['Draco', 'Harry', 'Hermione', 'Voldemort'])",2020-10-27T15:40:44+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",GiuliaMenna,"```
from collections import deque

my_stack = deque([""Draco"",""Harry"",""Hermione"",""Ron"",""Severus""])
my_stack.pop()
my_stack.pop()
my_stack.append(""Voldemort"")

print(deque)

```
deque = (['Draco', 'Harry', 'Hermione', 'Voldemort'])",2020-10-27T16:35:04+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",SusannaPinotti,"```
from collections import deque

my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])

my_stack.pop()
print(my_stack)

my_stack.pop()
print(my_stack)

my_stack.append(""voldemort"")
print(my_stack)

deque(['Draco', 'Harry', 'Hermione', 'Ron'])
deque(['Draco', 'Harry', 'Hermione'])
deque(['Draco', 'Harry', 'Hermione', 'voldemort'])
```

",2020-10-27T17:40:21+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",alicebordignon,"from collections import deque
my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_stack.pop()
print(my_stack) #(['Draco', 'Harry', 'Hermione', 'Ron'])
my_stack.pop()
print(my_stack) #(['Draco', 'Harry', 'Hermione'])
my_stack.append(""Voldemort"")
print(my_stack) #(['Draco', 'Harry', 'Hermione', 'Voldemort'])",2020-10-29T08:38:12+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",DeniseBas,"from collections import deque
my_stack = deque([""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""])
my_stack.pop()
my_stack.pop()
my_stack.append(""Voldemort"")
print(my_stack)

deque(['Draco', 'Harry', 'Hermione', 'Voldemort'])",2020-10-29T15:13:21+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 2",IlaRoss,"my_stack:
after my_stack.pop()  -->  my_stack = deque ([""Draco"", ""Harry"", ""Hermione"", ""Ron""])
after my_stack.pop()  -->  my_stack = deque ([""Draco"", ""Harry"", ""Hermione""])
after my_stack.append(""Voldemort"")  -->  my_stack = deque ([""Draco"", ""Harry"", ""Hermione"", ""Voldemort""])",2020-10-29T17:21:55+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",SarahTew,"hp_listÂ =Â list()
hp_list.append(""Draco"")
 hp_list.append(""Harry"")
hp_list.append(""Hermione"")
hp_list.append(""Ron"")
hp_list.append(""Severus"")
printÂ (hp_list)",2020-10-26T10:53:15+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",Fran-cesca,"```
FIRST METHOD
hp_list= list()
hp_list.append(""Draco"")
hp_list.append(""Harry"")
hp_list.append(""Hermione"")
hp_list.append(""Ron"")
hp_list.append(""Severus"")
print (hp_list)

SECOND METHOD
hp1_list= [""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""]
print (hp1_list)

THIRD METHOD
hp2_list= list()
hp2_list.append(""Harry"")
hp2_list.append(""Severus"")
hp2_list.append(""Hermione"")
hp2_list.append(""Ron"")
hp2_list.append(""Draco"")
hp2_list.sort()
print(hp2_list)
```",2020-10-26T12:40:55+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",ChiaraCati,"`my_list_hp=list()`
`my_list_hp.append(""Draco"")`
`my_list_hp.append(""Harry"")`
`my_list_hp.append(""Hermione"")`
`my_list_hp.append(""Ron"")`
`my_list_hp.append(""Severus"")`

`print(my_list_hp)`",2020-10-26T12:46:29+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",margheparla,"my_list= list()
my_list.append(""Harry"")
my_list.append(""Draco"")
my_list.append(""Hermione"")
my_list.append(""Severus"")
my_list.append(""Ron"")
my_list.sort()
print(my_list)",2020-10-26T13:16:40+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",yunglong28,"lista_hp = list['Draco', 'Harry', 'Hermione', 'Ron', 'Severus']
print(lista_hp)",2020-10-26T14:15:17+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",penelopelask,"``` 
#FIRST METHOD
Harry_potter_list = list()
Harry_potter_list.append(""Draco"")
Harry_potter_list.append(""Harry"")
Harry_potter_list.append(""Hermione"")
Harry_potter_list.append(""Ron"")
Harry_potter_list.append(""Severus"")
print(Harry_potter_list)

#SECOND METHOD
Harry_potter_list = list()
Harry_potter_list.append(""Hermione"")
Harry_potter_list.append(""Draco"")
Harry_potter_list.append(""Severus"")
Harry_potter_list.append(""Ron"")
Harry_potter_list.append(""Harry"")
Harry_potter_list.sort()
print(Harry_potter_list)

#THIRD METHOD
Harry_potter_list = [""Draco"", ""Harry"", ""Hermione"", ""Ron"", ""Severus""]
print(Harry_potter_list)```",2020-10-26T14:59:18+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",AleRosae,"```
my_list = list()
my_list.append(""Draco"")
my_list.append(""Harry"")
my_list.append(""Hermione"")
my_list.append(""Ron"")
my_list.append(""Severus"")

print(my_list)
```",2020-10-26T15:34:31+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",edoardodalborgo,"```
#with user input
names_list = input('Enter each name separed by a comma: ').split(', ')
print(sorted(names_list))

#without user input
names_list = list()
names_list.append(""Severus"")
names_list.append(""Harry"")
names_list.append(""Ron"")
names_list.append(""Hermione"")
names_list.append(""Draco"")
print(sorted(names_list))
```",2020-10-26T15:39:10+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",laurentfintoni,"my_list = list()
my_list.append(""Draco"")
my_list.append(""Harry"")
my_list.append(""Hermione"")
my_list.append(""Ron"")
my_list.append(""Severus"")

print(my_list)",2020-10-26T15:49:52+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",dbrembilla,"```
harry_potter_names = list()
harry_potter_names.append(""Draco"")
harry_potter_names.append(""Harry"")
harry_potter_names.append(""Hermione"")
harry_potter_names.append(""Ron"")
harry_potter_names.append(""Severus"")
```",2020-10-26T15:51:22+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",vanessabonanno,"my_hp_list = list()
my_hp_list.append(""Draco"")
my_hp_list.append(""Harry"")
my_hp_list.append(""Hermione"")
my_hp_list.append(""Ron"")
my_hp_list.append(""Severus"")

print(my_hp_list)",2020-10-26T16:42:03+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",AlessandraFa,"```
hp_list = list()
hp_list.append(""Draco"")
hp_list.append(""Harry"")
hp_list.append(""Hermione"")
hp_list.append(""Ron"")
hp_list.append(""Severus"")
print(hp_list)
```",2020-10-26T17:36:10+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",LuisAmmi,"```
hogwarts_list = list()
hogwarts_list.append(""Draco"")
hogwarts_list.append(""Harry"")
hogwarts_list.append(""Hermione"")
hogwarts_list.append(""Ron"")
hogwarts_list.append(""Severus"")

print(hogwarts_list)
```",2020-10-26T18:01:14+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",gabrielefiorenza,"```
my_list = list()
my_list.append(""Draco"")
my_list.append(""Harry"")
my_list.append(""Hermione"")
my_list.append(""Ron"")
my_list.append(""Severus"")

print(my_list)
```",2020-10-27T10:23:18+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",giorgiasampo,"harry_list = list()
harry_list.append(""Harry"")
harry_list.append(""Severus"")
harry_list.append(""Hermione"")
harry_list.append(""Ron"")
harry_list.append(""Draco"")
harry_list.sort()
print(harry_list)",2020-10-27T12:42:29+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",samuelespotti,"potter_list= list()
potter_list.append(""Draco"")
potter_list.append(""Harry"")
potter_list.append(""Hermione"")
potter_list.append(""Ron"")
potter_list.append(""Severus"")
print (potter_list)",2020-10-27T15:10:28+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",fcagnola,"```
mylist = []
mylist.append(""harry"")
mylist.append(""draco"")
mylist.append(""hermione"")
mylist.append(""ron"")
mylist.append(""severus"")
print(mylist)
```",2020-10-27T15:31:43+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",GiuliaMenna,"```
harry_potter_list = list()
harry_potter_list.append(""Draco"")
harry_potter_list.append(""Harry"")
harry_potter_list.append(""Hermione"")
harry_potter_list.append(""Ron"")
harry_potter_list.append(""Severus"")

print(harry_potter_list)
```",2020-10-27T15:41:41+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",SusannaPinotti,"```
HP_list = list()
HP_list.append(""Harry"")
HP_list.append(""Draco"")
HP_list.append(""Hermione"")
HP_list.append(""Ron"")
HP_list.append(""Severus"")
HP_list.sort()

print(HP_list)
```",2020-10-27T17:33:01+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",enri-ca,"```
HPE=list()
HPE.append(""Draco"")
HPE.append(""Harry"")
HPE.append(""Hermione"")
HPE.append(""Ron"")
HPE.append(""Severus"")
print(HPE)
```",2020-10-28T05:57:34+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",alicebordignon,"potter_list = []
potter_list.append(""Harry"")
potter_list.append(""Draco"")
potter_list.append(""Hermione"")
potter_list.append(""Ron"")
potter_list.append(""Severus"")
potter_list.sort()
print(potter_list)",2020-10-29T08:30:19+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",DeniseBas,"hp_list = list()

hp_list.append('Harry')
hp_list.append(""Draco"")
hp_list.append(""Hermione"")
hp_list.append(""Ron"")
hp_list.append(""Severus"")
hp_list.sort()

print(hp_list)",2020-10-29T15:05:21+00:00
comp-think/2020-2021,"Lecture ""Organising information: ordered structures"", exercise 1",IlaRoss,"```
hp_characters = [""Hermione"", ""Ron"", ""Draco"", ""Harry""]
hp_characters.append(""Severus"")
hp_characters.sort()
```",2020-10-29T17:02:27+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",SarahTew,"[Here](http://www.pythontutor.com/visualize.html#code=%23%20Code%20of%20the%20algorithm%0Adef%20contains_word%28first_word,%20second_word,%20bib_entry%29%3A%0A%20%20%20%20result%20%3D%200%0A%20%20%20%20contains_first_word%20%3D%20first_word%20in%20bib_entry%0A%20%20%20%20contains_second_word%20%3D%20second_word%20in%20bib_entry%0A%20%20%20%20if%20contains_first_word%20and%20second_word%20in%20bib_entry%3A%0A%20%20%20%20%20%20%20%20sum%20%3D%20result%20%2B%202%0A%20%20%20%20%20%20%20%20return%20sum%0A%20%20%20%20elif%20contains_first_word%20or%20second_word%20in%20bib_entry%3A%0A%20%20%20%20%20%20%20%20sum%20%3D%20result%20%2B%201%0A%20%20%20%20%20%20%20%20return%20sum%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20return%20result%0A%20%20%20%20%20%20%20%20%0A%23%20Run%20the%20algorithm%0Aprint%20%28contains_word%28%22Sarah%22,%20%22Tew%22,%20%22Shotton,%20D.%20%282013%29.%20Open%20Citations.%20Nature,%20502%3A%20295-267.%20doi%3A10.1038/502295a%22%29%29%0Aprint%20%28contains_word%28%22Nature%22,%20%22Open%22,%20%22Shotton,%20D.%20%282013%29.%20Open%20Citations.%20Nature,%20502%3A%20295-267.%20doi%3A10.1038/502295a%22%29%29%0Aprint%20%28contains_word%28%222013%22,%20%22References%22,%20%22Shotton,%20D.%20%282013%29.%20Open%20Citations.%20Nature,%20502%3A%20295-267.%20doi%3A10.1038/502295a%22%29%29%0A%20%20%20%20%20%20%20%20%0A%23%20Test%20case%20for%20the%20algorithm%0Adef%20test_contains_word%28first_word,%20second_word,%20bib_entry,%20expected%29%3A%0A%20%20%20%20result%20%3D%20contains_word%28first_word,%20second_word,%20bib_entry%29%0A%20%20%20%20if%20expected%20%3D%3D%20result%3A%20%0A%20%20%20%20%20%20%20%20return%20True%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20return%20False%0A%20%20%20%20%20%20%20%20%0A%23%20Three%20different%20test%20runs%0Aprint%20%28test_contains_word%28%22Shotton%22,%20%22Open%22,%20%22Shotton,%20D.%20%282013%29.%20Open%20Citations.%20Nature,%20502%3A%20295-267.%20doi%3A10.1038/502295a%22,%202%29%29%0Aprint%20%28test_contains_word%28%22Citations%22,%20%22Science%22,%20%22Shotton,%20D.%20%282013%29.%20Open%20Citations.%20Nature,%20502%3A%20295-297.%20doi%3A10.1038/502295a%22,%201%29%29%0Aprint%20%28test_contains_word%28%22References%22,%20%221983%22,%20%22Shotton,%20D.%20%282013%29.%20Open%20Citations.%20Nature,%20502%3A%20295-297.%20doi%3A10.1038/502295a%22,%200%29%29&cumulative=false&heapPrimitives=nevernest&mode=edit&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false) is a link to the code in Python Tutor. The indents got messed up when I copied and pasted it into the text box plus I just think Python Tutor is easier to read and more fun because you can run the program.",2020-10-21T10:45:08+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",essepuntato,"Hi @SarahTew,

For having the right indent here in the comment, you should use [Markdown](https://guides.github.com/features/mastering-markdown/), in particular, the ""```"" markup, e.g.:

<pre>
```
def f(a_string):
    return a_string
```
</pre>

will be shown as follows:

```
def f(a_string):
    return a_string
```

I hope it may help :-)",2020-10-21T10:51:31+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",SarahTew,"@essepuntato I am still having trouble. I will keep investigating. The Markdown language also turns all my notes made with # s in Python into headers. It has the same display issues when I use the 'insert code' in the tool bar directly above. It is frustrating to have written all the code and then have to rewrite it with correct formatting. I will keep experimenting. Thanks! 

Also, I realized my code isn't exactly like the flowchart: it adds 1 and 2 to the result to get the right answer but the flowchart has add one to result, then add one again to equal two. I've tried editing my code to match this but I can't get the 2 result to work. I will look through the others when they are posted.",2020-10-21T11:07:50+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",diegochillo,"    def test_contains_words(first_word, second_word, bib_entry, expected):
       result=contains_words(first_word, second_word, bib_entry)
       return result==expected


    def contains_words(first_word, second_word, bib_entry):
       wordcnt=0
       if first_word in bib_entry: wordcnt+=1
       if second_word in bib_entry: wordcnt+=1
       return wordcnt
    

    
    print(test_contains_words(""Umberto"",""Eco"",""Eco, Umberto - Kant e l'ornitorinco, Bompiani,1996"", 2))
    print(test_contains_words(""essere"",""tempo"",""Jean-Paul, Sartre - L'essere e il nulla, Mondadori,2002"", 1))
    print(test_contains_words(""Friedrich"",""Nietzsche"",""Hegel, Wilhelm Friedrich, Fenomenologia dello spirito, Bompiani,1996"", 1))",2020-10-21T12:30:56+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",dbrembilla,"```
result = 0
def increase_result():
    global result
    result= result + 1
def entry_check(x,z):
    if x in z:
        increase_result()
def bibl_check(entry1, entry2, bibl):
    entry_check(entry1, bibl)
    entry_check(entry2, bibl)
    return result
def test_bibl_check(entry1, entry2, bibl, expected):
    res = bibl_check(entry1, entry2, bibl)
    if res == expected:
        return True
    else:
        return False
```
(I know that it uses something we did not talk about, but I did not know how to implement it otherwise)
I try to run the code
`print(test_bibl_check(""Judt"", ""America"", ""Judt, Tony (2005) Postwar: A History of Europe since 1945, Penguin Books, London"", 1))`
prints `True`
`print(test_bibl_check(""Schloss"", ""Prag"", ""Kafka, Franz (1925). Der Prozess, Die Schmiede, Berlin"", 1))`
prints `False`; if we correctly put 0 as  expected value, it returns `True`
`print(test_bibl_check(""London"", ""York"", ""London, Jack (1903). The Call of the Wild, Macmillan, New York"", 2))`
prints `True`
Link for this last test : [here](http://www.pythontutor.com/visualize.html#code=result%20%3D%200%0Adef%20increase_result%28%29%3A%0A%20%20%20%20global%20result%0A%20%20%20%20result%3D%20result%20%2B%201%0Adef%20entry_check%28x,z%29%3A%0A%20%20%20%20if%20x%20in%20z%3A%0A%20%20%20%20%20%20%20%20increase_result%28%29%0Adef%20bibl_check%28entry1,%20entry2,%20bibl%29%3A%0A%20%20%20%20entry_check%28entry1,%20bibl%29%0A%20%20%20%20entry_check%28entry2,%20bibl%29%0A%20%20%20%20return%20result%0Adef%20test_bibl_check%28entry1,%20entry2,%20bibl,%20expected%29%3A%0A%20%20%20%20res%20%3D%20bibl_check%28entry1,%20entry2,%20bibl%29%0A%20%20%20%20if%20res%20%3D%3D%20expected%3A%0A%20%20%20%20%20%20%20%20return%20True%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20return%20False%0Aprint%28test_bibl_check%28%22London%22,%20%22York%22,%20%22London,%20Jack%20%281903%29.%20The%20Call%20of%20the%20Wild,%20Macmillan,%20New%20York%22,%202%29%29%0A&cumulative=false&heapPrimitives=nevernest&mode=edit&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false)",2020-10-21T14:43:13+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",gabrielefiorenza,"THIS IS THE PYTHON ALGORITHM:
def contains_word(first_word, second_word, bib_entry):
    result = 0

    if first_word in bib_entry:
        result = result + 1
    else:
        result = result + 0

    if second_word in bib_entry:
        result = result + 1
    else:
        result = result + 0

    return result

THIS IS THE TEST WITH A AN EXECUTION:
def test_contains_word(first_word, second_word, bib_entry, expected):
    result = contains_word(""Peroni"", ""HTML"", ""Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A.G., Poggi, F., Vitali, F., Motta, E. 2017. 
Research ArticlesSimplified HTML: a Web-first format  HTML-based scholarlyarticles. PeerJ Computer Science 3: e132. e2513. DOI:https://doi.org/10.7717/peerj-cs.132"")
    if result == expected:
        return True
    else:
        return False

print(test_contains_word(""Peroni"", ""HTML"", ""Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A.G., Poggi, F., Vitali, F., Motta, E. 2017. Research ArticlesSimplified HTML: a Web-first format  HTML-based scholarlyarticles. PeerJ Computer Science 3: e132. e2513. DOI:https://doi.org/10.7717/peerj-cs.132"", 2))

Output:
True

THIS IS THE TEST WITH ANOTHER EXECUTION:
def test_contains_word(first_word, second_word, bib_entry, expected):
    result = contains_word(""Citations"", ""Science"", ""Shotton, D.(2013). Open Citations. Nature, 502: 295â€“297. doi:10.1038/502295a"")
    if result == expected:
        return True
    else:
        return False

print(test_contains_word(""Citations"", ""Science"", ""Shotton, D.(2013). Open Citations. Nature, 502: 295â€“297. doi:10.1038/502295a"", 1))

Output:
True",2020-10-21T17:22:58+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",giorgiasampo,"This is the link to the algorithm, I hope it works.

https://repl.it/@giorgiasampo/Exercise-3#main.py",2020-10-21T17:44:57+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",edoardodalborgo,"```
def test_contains_words(word1, word2, bib_entry_words, expected):
    if contains_words(word1, word2, bib_entry_words) == int(expected):
        return True
    else:
        return False

def contains_words(word1, word2, bib_entry_words):
    result = 0
    for word in bib_entry_words:
        if word1 == word:
            result += 1
        elif word2 == word:
            result += 1
    return result

word1, word2, expected = input('Enter word1, word2, expected: ').split(',')
pre_bib_entry_list = input('Enter a bibliographic entry: ').replace('\""', """").split(',')
bib_entry_words = list()
for word in pre_bib_entry_list:
    words = word.split()
    for word in words:
        if word in bib_entry_words:
            continue
        else:
            bib_entry_words += words
print(test_contains_words(word1, word2, bib_entry_words, expected))

```
",2020-10-21T21:33:59+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",ConstiDami,"```
def test_bibl(first_word, second_word, bibl_entry, expected):
    result = bibl(first_word, second_word, bibl_entry)
    if result == expected:
        return True
    else:
        return False

def bibl(first_word, second_word, bibl_entry):
    result=0
    if first_word in bibl_entry:
        result+=1
    if second_word in bibl_entry:
        result+=1
    return result

print(test_bibl(""Shotton"", ""Open"", ""Shotton, D. (2013). Open Citations. Nature, 502: 295â€“297. doi:10.1038/502295a"", 2))
print(test_bibl(""Shotton"", ""Open"", ""Shotton, D. (2013). Open Citations. Nature, 502: 295â€“297. doi:10.1038/502295a"", 1))
print(test_bibl(""Shotton"", ""Open"", ""Shotton, D. (2013). Open Citations. Nature, 502: 295â€“297. doi:10.1038/502295a"", 0))
```

When I run the code, the result is as expected, ""True"", ""False"" and ""False""",2020-10-22T14:31:22+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",SusannaPinotti,"```
deftest_contains_words(w1, w2, bib_entry, expected): 
    res=contains_words(w1,w2,bib_entry)
    if expected == res: 
        return True 
    else: 
        return False

def contains_words(w1, w2, bib_entry): 
    res=0
    if w1 in bib_entry:  
        res=res+1
    else: 
        res=res+0 
    if w2 in bib_entry: 
        res=res+1
    else: 
        res=res+0
    return res
    

print(test_contains_words(""linguistica"",""Rema"",""Rossini, Favretti, Rema, Un'introduzione alla linguistica applicata.ed.Bologna, Patron, 2009"",2))
print(test_contains_words(""Elder"",""corpus"",""Davies Alain and Elder Catherine, The handbook of applied linguistics, Malden (MA), Blackwell,"",1))
print(test_contains_words(""2009"",""italian"",""D. Jurafsky and J.H. Martin (2008). Speech and Language Processing, 2nd ed., Prentice Hall."",0))




```",2020-10-22T15:53:12+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",yunglong28,"def contains_word(first_word, second_word, bib_entry):  
    contains_first_word = first_word in bib_entry
    contains_second_word = second_word in bib_entry
    x=0
    if contains_first_word:
        x=x+1
    if contains_second_word:
        x=x+1
    return x
print(contains_word(""Deleuze"", ""Differenza"", ""Gilles Deleuze, Differenza e ripetizione, Cortina Editore""))

#TEST
def test_contains_word(first_word, second_word, bib_entry, expected):
    result = contains_word(first_word, second_word, bib_entry)
    if result == expected:
        return True
    else:
        return False


print(test_contains_word(""Deleuze"", ""Differenza"", ""Gilles Deleuze, Differenza e ripetizione, Cortina Editore"", 2))
print(test_contains_word(""Deleuze"", ""Differenza"", ""Gilles Deleuze, Differenza e ripetizione, Cortina Editore"", 1))",2020-10-22T16:06:42+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",fcagnola,"What follows is my proposed solution:
```
def test_arewordsinentry(word_1, word_2, bib_entry, expected):
    result = are_words_in_entry(word_1, word_2, bib_entry)
    if result == expected:
        return True
    else:
        return False

def are_words_in_entry(word_1, word_2, bib_entry):
    result = 0
    if word_1 in bib_entry:
        result = result + 1
    else:
        result = result + 0
    if word_2 in bib_entry:
        result = result + 1
    else:
        result = result + 0
    return result

print(""Testing are_words_in_entry function: all results should be True:"")
print(test_arewordsinentry('a', 'b', 'abcdef', 2))
print(test_arewordsinentry('a', 'b', 'bcdefg', 1))
print(test_arewordsinentry('a', 'b', 'cdefgh', 0))
```
All the tests work, so I guess the function itself is implemented well",2020-10-22T16:07:06+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",LuisAmmi,"```

def contains_word(first_word, second_word, bib_entry):
result = 0
if first_word in bib_entry:
result = result + 1
if second_word in bib_entry:
result = result + 1
return result

print(contains_word(""Connie"",""Annie"",""Connie J. A. Beck and Bruce D. Sales, Family Mediation: Facts, Myths, and Future Prospects (Washington: APA, 2001), 99-100""))

def test_contains_word(first_word, second_word, bib_entry, expected):
result = contains_word(first_word, second_word, bib_entry)
if result == expected:
return True
else:
return False

print(test_contains_word(""Jewell"", ""Mike"",""Jewelle Taylor Gibbs and Larke Nahme Huang, eds., Children of Color: Psychological Interventions With Minority Youth"", 1))

```",2020-10-22T16:07:24+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",AlessandraFa,"One possible solution:
```
def test_findwords (word1, word2, bibentry, expected):
  result = findwords (word1, word2, bibentry)
  if result == expected:
    return True
  else:
    return False

def findwords (word1, word2, bibentry):
  result = 0
  if word1 in bibentry:
    result = result + 1
  if word2 in bibentry: 
    result = result + 1
    return result
  else:
    return 0
  
print(test_findwords(""Animal"", ""Penguin"", ""Orwell, G. Animal Farm. Penguin Books, 1945"", 2))
print(test_findwords(""Person"", ""Penguin"", ""Orwell, G. Animal Farm. Penguin Books, 1945"", 2))
print(test_findwords(""Person"", ""Penguin"", ""Orwell, G. Animal Farm. Penguin Books, 1945"", 1))
print(test_findwords(""Animal"", ""Penguin"", ""Orwell, G. Animal Farm. Penguin Books, 1945"", 0))
```
The test returns the expected Boolean values ""True"", ""False"","" True"", ""False"". ",2020-10-22T17:12:19+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",GiuliaMenna,"```
def test_contains_words(first_word, second_word, bib_entry, expected):
    result = contains_words(first_word, second_word, bib_entry)
    if result == expected:
        return True
    else:
        return False 

def contains_words(first_word, second_word, bib_entry):
    result = 0
    if first_word in bib_entry:
        result=result + 1

    if second_word in bib_entry:
        result=result + 1
    return result

print(contains_words(""East"", ""Steinbeck"", ""John Steinbeck, East of Eden, The Viking press, 1952""))
print(test_contains_words(""East"", ""Steinbeck"", ""John Steinbeck, East of Eden, The Viking press, 1952"", 2))
print(test_contains_words(""USA"", ""Steinbeck"", ""John Steinbeck, East of Eden, The Viking press, 1952"", 1))
print(test_contains_words(""USA"", ""novel"", ""John Steinbeck, East of Eden, The Viking press, 1952"", 0))
```
 ",2020-10-22T19:26:54+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",AlessandroBertozzi,"The results of the three prints are respectively: True, True, True.
```
def test_contains_word(first_word, second_word, bib_entry, expected):
    result = contains_word(first_word, second_word, bib_entry)
    if expected == result:
        return True
    else:
        return False


def contains_word(first_word, second_word, bib_entry):
    result = 0
    contains_first_word = first_word in bib_entry
    contains_second_word = second_word in bib_entry
    if contains_first_word:
        result += 1
    if contains_second_word:
        result += 1
    return result


print(test_contains_word(""Shotton"", ""Open"",
                         ""Shotton, D. (2013). Open Citations. Nature, 502: 295â€“297. doi:10.1038/502295a"", 2))
print(test_contains_word(""Citations"", ""Science"",
                         ""Shotton, D. (2013). Open Citations. Nature, 502: 295â€“297. doi:10.1038/502295a"", 1))
print(test_contains_word(""References"", ""1983"",
                         ""Shotton, D. (2013). Open Citations. Nature, 502: 295â€“297. doi:10.1038/502295a"", 0))
```",2020-10-22T22:14:26+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",penelopelask,"def test_contains_word(first_word, second_word, bib_entry, expected):
    result = contains_word(first_word, second_word, bib_entry)
    if expected == result:
        return True
    else:
        return False


def contains_word(first_word, second_word, bib_entry):
    result = 0
    contains_first_word = first_word in bib_entry
    contains_second_word = second_word in bib_entry
    if contains_first_word:
        result += 1
    if contains_second_word:
        result += 1
    return result
    
print(test_contains_word(""English"", ""Literature"", ""Oxford University Press,Ed.7,2009"", 2))
print(test_contains_word(""English"", ""Literature"", ""Oxford University Press,Ed.7,2009"", 1))
print(test_contains_word(""English"", ""Literature"", ""Oxford University Press,Ed.7,2009"", 0))",2020-10-23T07:18:51+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",ChiaraCati,"`#test`
`def test_contains_word(word_1, word_2, bib_entry, expected):`
    `result = contains_word(word_1, word_2, bib_entry)`
    `if result == expected:`
       ` return True`
    `else:`
        `return False`

`#start developing my algorithm`
`def contains_word(word_1, word_2, bib_entry):`
    `#run test for 1st time withour setting a value in return`
    `#test returns all the prints as False`
    `#set the result value as 0`
    `#set result as return value` 
    `#run the test that will `
    `#test returns the first 3 prints as False and the 4th as true`
    `result= 0`
    `#set first if condition that adds 1 to the initial result if word_1 is in bib_entry`
    `#run the test that will `
    `#test returns 1st and 3rd prints as False and 2nd and 4th as true`
    `if word_1 in bib_entry:`
        `result = result+1`
    `#set second if condition that adds 1 to the initial result if word_1 is in bib_entry`
    `#run the test  `
    `#test returns all prints as True`
    `if word_2 in bib_entry:`
       ` result = result+1`
       ` return result `
   
`# 4 test runs`
`print(test_contains_word(""Ranum"", ""Problem"", ""Miller, B. N., Ranum, D. L. (2011). Problem Solving with Algorithms and Data Structures usingPython"", 2))`
`print(test_contains_word(""Ranum"", ""Computer"", ""Miller, B. N., Ranum, D. L. (2011). Problem Solving with Algorithms and Data Structures usingPython"", 1))`
`print(test_contains_word(""Exercise"", ""Problem"", ""Miller, B. N., Ranum, D. L. (2011). Problem Solving with Algorithms and Data Structures usingPython"", 1))`
`print(test_contains_word(""Exercise"", ""Computer"", ""Miller, B. N., Ranum, D. L. (2011). Problem Solving with Algorithms and Data Structures usingPython"", 0))`",2020-10-23T08:08:29+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",AleRosae,"Here is the [link ](http://www.pythontutor.com/visualize.html#code=def%20test_biblio_count%28word1,%20word2,%20entry_bib,%20expected%29%3A%0A%20%20%20%20result%20%3D%20biblio_count%20%28word1,%20word2,%20entry_bib%29%0A%0A%20%20%20%20if%20result%20%3D%3D%20expected%3A%0A%20%20%20%20%0A%20%20%20%20%20return%20True%0A%0A%20%20%20%20else%3A%0A%20%20%20%20%0A%20%20%20%20%20%20%20%20return%20False%0A%0Adef%20biblio_count%20%28word1,%20word2,%20entry_bib%29%3A%0A%20%20%20%20contains_first_word%20%3D%20word1%20in%20entry_bib%0A%20%20%20%20contains_second_word%20%3D%20word2%20in%20entry_bib%0A%20%20%20%20result%20%3D%200%0A%20%0A%20%20%20%20if%20contains_first_word%20and%20contains_second_word%3A%0A%20%20%20%20%20%20%20%20result%20%3D%20result%20%2B%202%0A%20%20%20%20%0A%20%20%20%20%0A%20%20%20%20elif%20contains_first_word%3A%0A%20%20%20%20%20%20%20%20result%20%3D%20result%20%2B%201%0A%20%20%20%20%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20result%20%3D%200%0A%0A%20%20%20%20return%20result%0A%20%20%20%20%0Aprint%20%28test_biblio_count%20%28%22genome%22,%20%22medicine%22,%20%22HOFMANN,%20Bj%C3%B8rn,%20On%20the%20Triad%20Disease,%20Illness%20and%20Sickness,%20%C2%ABJournal%20of%20Medicine%20and%20Philosophy%C2%BB,%2027%20%282002%29%206,%20pp.%20651-673%22,%200%29%29%0Aprint%20%28test_biblio_count%20%28%22cancer%22,%20%22medicine%22,%20%22KRAMER,%20Barnett%20S.%20and%20KLAUSNER,%20Richard,%20D.,%20Grappling%20with%20cancer%3A%20Defeatism%20Versus%20the%20Reality%20of%20Progress,%20%C2%ABThe%20New%20England%20Journal%20of%20Medicine,%20337%20%281997%29%2013,%20pp.%20926-934%22,%201%29%29%0Aprint%20%28test_biblio_count%20%28%22ethics%22,%20%22knowledge%22,%20%22Leonelli%20Sabina%202016%20Locating%20ethics%20in%20data%20science%3A%20responsibility%20and%20accountability%20in%20global%20and%20distributed%20knowledge%20production%20systems%20Phil.%20Trans.%20R.%20Soc.%20A.%22,%202%29%29%0A&cumulative=false&heapPrimitives=nevernest&mode=edit&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false)to the algorithm. 
I have run the test and it gave me True for each entry, so I am assuming that it works.",2020-10-23T09:41:09+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",IlaRoss,"```

#tests
def test_contains_word(first_word, second_word, bib_entry, expected):
    count = contains_word(first_word, second_word, bib_entry)
    if count == expected:
        return True
    else:
        return False

#code algorithm
def contains_word(first_word, second_word, bib_entry):
    count = 0
    if first_word in bib_entry:
        count = count + 1
    if second_word in bib_entry:
        count = count + 1
    return count

#four test runs
print(test_contains_word(""Fubini"", ""Settecento"", ""Fubini, E., L'estetica musicale dall'antichitÃ  al Settecento, 2002, Einaudi"", 2))
print(test_contains_word(""Fubini"", ""pittura"", ""Fubini, E., L'estetica musicale dall'antichitÃ  al Settecento, 2002, Einaudi"", 1))
print(test_contains_word(""Novecento"", ""estetica"", ""Fubini, E., L'estetica musicale dall'antichitÃ  al Settecento, 2002, Einaudi"", 1))
print(test_contains_word(""Vinay"", ""Rinascimento"", ""Fubini, E., L'estetica musicale dall'antichitÃ  al Settecento, 2002, Einaudi"", 0))

```",2020-10-24T08:23:43+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 3",enri-ca,"```
def test_enrica(string1, string2, string3, expected):
result = enrica(string1, string2, string3)
if result == expected:
        return True
    else:
        return False

def enrica(string1, string2, string3):
    resultvalue=0
    check1=string1 in string3
    check2=string2 in string3
    if check1 :
        resultvalue=resultvalue+1
    else :
        resultvalue=resultvalue+0

    if check2 :
        resultvalue=resultvalue+1
    else :
        resultvalue=resultvalue+0
    return resultvalue

print(test_enrica('a', 'b', 'cb', 1))
print(test_enrica('a', 'b', 'ab', 2))
print(test_enrica('a', 'b', 'cd', 0))",2020-10-24T14:14:26+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",SarahTew,"False

Work:
True and not (True)
True and False
False
",2020-10-21T09:47:19+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",giorgiasampo,"The Boolean value is TRUE because:
-""spam"" not in ""spa span sparql"" returns TRUE
-""egg""> ""span"" returns FALSE (I summed the values of the letters according to the alphabetical order so e=5, g=7, s=19, p=16, a=1, n=14 so egg=19 and span=50)
-not FALSE (result of previous operations) is TRUE
-TRUE and TRUE is TRUE",2020-10-21T09:59:18+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",edoardodalborgo,"""spam"" not in ""spa span sparql"" -> T
not (""egg"" > ""span"") -> not(F) -> T
""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"") -> T",2020-10-21T10:07:59+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",SarahTew,"@giorgiasampo Thank you for your detailed explanation! I thought comparisons were purely just alphabetical by word (so whichever would come first in a dictionary was considered larger). Now I understand ðŸ‘

@essepuntato Thank you Professor Peroni. For anyone else that is confused about comparing strings I found [this ](https://runestone.academy/runestone/books/published/thinkcspy/Strings/StringComparison.html)helpful explanation with a few simple exercises at the bottom to clear up the rules for comparing strings. ",2020-10-21T10:57:50+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",essepuntato,"@SarahTew @giorgiasampo 

Indeed the comparisons with strings **are** alphabetical, but the one that comes first in a dictionary is lesser than the other. E.g.:

`""this string"" > ""another string""` is `True` since `""t""` (first character of the first string) is greater than `""a""`(first character of the second string)",2020-10-21T11:02:29+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",ChiaraCati,"`â€œspamâ€ not in â€œspa span sparqlâ€ and not (â€œeggâ€>â€span) `
-> `â€œspamâ€ not in â€œspa span sparqlâ€ and not False ` [first solve the part in the brackets]
-> `True and True ` [second step solve the ` not ` operations]
-> ` True` [finally solve the ` and ` operation]",2020-10-21T11:47:48+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",fcagnola,"`""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")`
`True and not (""egg"" > ""span"")`
`True and not False`
`True and True`
`True`",2020-10-21T12:29:30+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",dbrembilla,"`""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")`
`True and not False`
`True and True` then `True`",2020-10-21T14:14:00+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",vanessabonanno,"The answer is True:
""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")
True and not False      [(""egg"" > ""span"") is False because egg comes before (<) ""span"" in alphabet]
True and True
True ",2020-10-21T14:28:48+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",AlessandraFa,"The boolean value is True:

`""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")`
`""spam"" not in ""spa span sparql"" and not (False)`
`""spam"" not in ""spa span sparql"" and True`
`True and True`
`True`",2020-10-21T15:31:09+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",gabrielefiorenza,"TRUE:
""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")
""spam"" not in ""spa span sparql"" and not False
True and True
True",2020-10-21T16:04:37+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",LuisAmmi,"The boolean value is TRUE.
First of all, we analyze the first condition about the two strings ""spam"" and ""spa span sparql"".
""**Spam**"" **NOT in** ""**spa span sparql**"" = **TRUE**

So, we check the second one.
- **NOT (""Egg""> ""Span"")**
- NOT (FALSE) --> because the first letter of ""Egg"" comes before ""S"" in the alphabet, so it's not ""greater than"" the second one.
- **TRUE**

So, **TRUE and TRUE= TRUE**",2020-10-22T08:25:05+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",samuelespotti,"
""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"") => false because ""s"" is greater than ""e"" (I think I understand) 
""spam"" not in ""spa span sparql"" and not (False)
True and True
True",2020-10-22T10:20:20+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",GiuliaMenna,"""spam"" not in ""spa span sparql"" and not (""egg"">""span"")?

True and not (False)
True and True = TRUE ",2020-10-22T11:15:25+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",SusannaPinotti,This expression returns the boolean value True ,2020-10-22T14:00:47+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",yunglong28,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"").
""spam"" not in ""spa span ""sparql"" is TRUE. not(""egg"">""span"") is TRUE (""egg"" greater than ""span"" is false and with not TRUE)
TRUE and TRUE is TRUE
so TRUE",2020-10-22T14:13:17+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",laurentfintoni,"The boolean value is True. 

We solve the operation in () first. ""egg"" is not greater than ""span"" by alphabetical value, so the result is False. the first part is True (""spam"" is not in the string). True and not False returns True. ",2020-10-22T15:40:38+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",penelopelask,"**""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")**
(""spam"" not in ""spa span sparql"") and not ( **False** )
(**True**) and (**True**)
_True_",2020-10-23T06:34:11+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",lauratravaglini,"_""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")_

True and not False
True and True
**True**",2020-10-23T07:26:44+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",AleRosae,"The Boolean value is True. Here is the procedure:

`""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")`

`""spam"" not in ""spa span sparql""` -> True

`True and not (""egg"" > ""span"")`

`(""egg"" > ""span"")` -> False because ""e"" comes before ""s""

`True and not (False)`

`True and True`

True`",2020-10-23T08:27:02+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",IlaRoss,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")
""spam"" not in ""spa span sparql"" and not false
""spam"" not in ""spa span sparql"" and true
true and true
true",2020-10-24T08:02:55+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 2",enri-ca,"""spam"" not in ""spa span sparql"" and not (""egg"" > ""span"")
  (""egg"" > ""span"") = F
  ""spam"" not in ""spa span sparql"" = T
T and not (F)
  not (F) = T
T and T
T",2020-10-24T11:02:07+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",SarahTew,"True

Work:
not (not True or False and True) or False
not (False or False and True) or False
not (False or False) or False
not (False) or False
True or False
True",2020-10-21T09:46:57+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",edoardodalborgo,"not(((not T) or F) and T) or F -> not((F or F) and T) or F -> not( F and T) or F ->not F or F -> 
T or F -> T",2020-10-21T09:53:14+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",giorgiasampo,"The Value is TRUE because:
-not TRUE is FALSE - not (False or False and True) or False
-FALSE and TRUE is FALSE - not (False or False) or False
-FALSE or FALSE is FALSE - not (False) or False
-Not FALSE is TRUE - True or False
-TRUE or FALSE states TRUE",2020-10-21T09:58:37+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",ChiaraCati,"not (not True or False and True) or False 
-> not (False or False and True) or False
-> not (False or False) or False
-> not False or False
-> True or False
-> True ",2020-10-21T11:29:37+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",fcagnola,"Given the statement: `not (not True or False and True) or False`

the order of operation as I understood it should be _not_->_and_->_or_, and parentheses before everything else, so:
`not (False or False and True) or False`
`not (False or False) or False`
 `not False or False`
`True or False`
`True`",2020-10-21T12:22:52+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",dbrembilla,"The boolean value is True
Procedure:
not (not True or False and True) or False
not (False or False and True) or False
not (False or False) or False
not False or False
True or False
True",2020-10-21T14:04:38+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",vanessabonanno,"As my colleagues answered before I believe the answer is True:

not(not True or False and True) or False
not(False or False and True) or False
not(False and True) or False
not(False) or False
True or False
True",2020-10-21T14:30:44+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",AlessandraFa,"The boolean value should be True:

not (**not True** or False and True) or False
not (False or **False and True**) or False
not (**False or False**) or False
**not False** or False
**True or False**
True",2020-10-21T15:00:18+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",gabrielefiorenza,"True:
not(not True or False and True) or False
not(False or False and True) or False
not(False or False) or False
not False or False
True or False
True
",2020-10-21T16:01:15+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",LuisAmmi,"The boolean value is TRUE. The method followed is checking the values on the table 1 and replacing terms with the corresponding boolean values.

Not (not-True or False-and-True) or False
Not (False or False) or False
Not (False) or False
True o False
True",2020-10-22T07:54:32+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",samuelespotti,"not (not True or False and True) or False
- not (False or False and True) or False
- not (False or False) or False
- not False or False
- True or False
- True",2020-10-22T10:04:51+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",lauratravaglini,"_no(not True or False and True) or False_

not(False or False and True) or False
not(False or False) or False
not False or False
True or False
**True**",2020-10-22T10:14:46+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",GiuliaMenna,"not (not True or False and True) or False?

not (F or F and T) or F 
not (F or F) or F
not (F) or F 
not F or F
T or F =
TRUE",2020-10-22T11:13:31+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",SusannaPinotti,The boolean value resulting from this expression is True. ,2020-10-22T13:53:58+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",yunglong28,"not (not True or False and True) or False
not (False or False) or False
True or False
True",2020-10-22T14:16:11+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",laurentfintoni,"the Boolean value is True.

We start with the operations between (). not True gives us False. False or False and True gives us False because the and operation requires both values to match and the or operation requires one value to be True. So now we have not (False), which is True. And the final is True or False, which is True. ",2020-10-22T15:30:44+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",penelopelask,"not (not True or False and True) or False 

not (False or False) or False

not (False) or False

True or False

True. ",2020-10-23T06:27:38+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",AleRosae,"The answer is True. Here is the procedure:

not (not True or False and True) or False

not (False or False and True) or False

not (False or False) or False

not (False) or False

True or False

True ",2020-10-23T08:17:47+00:00
comp-think/2020-2021,"Lecture ""Programming languages"", exercise 1",IlaRoss,"not (not true or false and true) or false
not (false or false and true) or false
not (false or false) or false
not false or false
true or false
true",2020-10-24T08:00:09+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 3",diegochillo,"(With the input below, a zero is returned on the initial cell)

    input: '001001'
    blank: ' '
    start state: start
    table:

      start:
        [1,0]: {write: 1, R: findfirst}
    
      findfirst:
        [1]: {write: 0, R: findsecond}
        [0]: {R}
        [' ']: {L: getbacknotfound}
    
      findsecond:
        [0]: {R}
        [1]: {write: 0, R: findthird}
        [' ']: {L: getbacknotfound}
    
      findthird:
        [1]: {R: end}
        [0]: {R}
        [' ']: {L: getbacknotfound}
    
      getbacknotfound:
        [0]: L
        [1]: {write: 0, L: end}
  
      end:
",2020-10-19T18:14:10+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 3",edoardodalborgo,"In this solution the reasoning is inverted compared to the second exercise. I write 1 in the starting point and if the algorithm catch three different 1s values in three different states it ends, and the result is just printed at the starting point. If the algorithm catch some 0s and 1s but the 1s values aren't three, the algorithm rewrites every 1s values to 0, included the value of the starting point.

blank: ['']
start state: A
table:
  A:
    0,1: {write 1, R: B}
  B:
    0: {R: B}
    1: {R: C}
    ['']: {L: E}
  C:
    0: {R: C}
    1: {R: D}
    ['']: {L: E}
  D:
    0: {R: D}
    1: {R: F}
    ['']: {L: E}
  E:
    0: {L: E}
    1: {write 0, L: E}
    ['']: {L: F}
end state: F",2020-10-20T09:59:49+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 3",ConstiDami,"blank: ' '
start state: moveendright
table:

  moveendright:
    [0, 1] : {R: moveendright}
    ' ': {L: moveleft}
  
  moveleft:
    0: {L: moveleft}
    1: {write: 0, L: foundone}
    ' '  : {R: return}

  foundone:
    1 : {write: 0, L: foundtwo}
    0 : {L: foundone}
    ' ': {R: return}
  
  foundtwo:
    1 : {write: 0, L: foundthree}
    0 : {L: foundtwo}
    ' ': {R: return}
    
  foundthree:
    [1, 0]: {write: 0, L: foundthree}
    ' ' : {R: returnfound}
  
  return: 
    [1, 0]: {write: 0, L: end}
 
  returnfound:
    [1, 0]: {write: 1, L: end}
  
  end:


I used the same instructions as in ex.2, but instead of starting again with moveleft if the machine finds a 0, it stays in the state where the number of '1' found is 'stored' (in the name of the function).",2020-10-20T10:49:29+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 3",SarahTew,"[Turing Machine non-consecutive 1s.pdf](https://github.com/comp-think/2020-2021/files/5408224/Turing.Machine.non-consecutive.1s.pdf)

My table assumes the head can move back to its original position in one movement which I think the Turing machine could do. I looked on [stack exchange](https://cs.stackexchange.com/questions/124643/turing-machine-with-move-to-origin-instead-of-move-left) it said you could remove all the tape to the left of the cell where you want to write the answer, start running from there then send it back to the leftmost cell (aka the origin since the rest has been removed). That would work for my purposes. There could be other ways to do it as well; I don't really know.

I have tried so many different arrangements and so far I haven't found one it doesn't catch but please try it for yourself and let me know if the chart is easy to follow and gives you the right answers. Thanks!
",2020-10-20T11:26:48+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 3",falcon1982,"
CURR STATE | READ | WRITE | MOVE | NEXT STATE
-- | -- | -- | -- | --
OK | Â  | Â  | Â  | Â 
E | 0 | 0 | L | E
E | 1 | 0 | R | OK
F | 0 | 1 | R | G
F | 1 | 1 | R | G
G | 0 | 0 | R | G0
G | 1 | 0 | R | G1
G0 | 0 | 0 | R | G00
G0 | 1 | 0 | R | G01
G1 | 0 | 0 | R | G01
G1 | 1 | 0 | R | G11
G01 | 0 | 0 | R | G010
G01 | 1 | 0 | R | G011
G00 | 0 | 0 | L | E
G00 | 1 | 0 | R | G010
G11 | 0 | 0 | R | G110
G11 | 1 | 0 | R | OK
G110 | 0 | 0 | R | G1100
G110 | 1 | 0 | R | OK
G1100 | 0 | 0 | L | E
G1100 | 1 | 0 | R | OK
G011 | 0 | 0 | R | G1100
G011 | 1 | 0 | R | OK
G001 | 0 | 0 | L | E
G001 | 1 | 0 | R | G1100

",2020-10-20T19:08:42+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 3",LuisAmmi,"input: '010110'
blank: '0'
start state: start
table:
  start:
    0: { write: 1, R: pn }
  pn:
    0: { write: 0, R: p0 }
    1: { write: 0, R: p1 }
  p0:
    0: { write: 0, R: p00 }
    1: { write: 0, R: p01 }
  p1:
    0: { write: 0, R: p10 }
    1: { write: 0, R: p11 }
  p00:
    0: { write: 0, L: fail }
    1: { write: 0, R: p001 }
  p01:
    0: { write: 0, R: p001  }
    1: { write: 0, R: p011 }
  p10:
    0: { write: 0, R: p001 }
    1: { write: 0, R: p011 }
  p11:
    0: { write: 0, R: p011 }
    1: { write: 0, L: stop }
  p001:
    0: { write: 0, L: fail }
    1: { write: 0, R: p0011 }
  p011:
    0: { write: 0, R: p0011 }
    1: { write: 0, L: stop }
p0011:
    0: { write: 0, L: fail }
    1: { write: 0, L: stop }
  fail:
    0: { write: 0, L: fail }
    1: { write: 0, L: stop }
  stop:",2020-10-21T12:28:34+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 3",gabrielefiorenza,"input : ""000101""
blank: ""0""
start state: start
table:
  start:
    0: { write: 0, R : A}
  A:
    0: { write: 1, R : E}
    1: { write: 1, R : B}
  B:
    0: { write: 1, R : F}
    1: { write: 1, R : C}   
  C:
    0: { write: 1, R : G}
    1: { write: 1, L : D}
  D:
    0: { write: 1, R : STOP}
    1: { write: 1, L : D}
  E:
    0: { write: 1, R : H}
    1: { write: 1, R : F}
  F:
    0: { write: 1, R : M}
    1: { write: 1, R : G}
  G:
    0: { write: 1, R : I}
    1: { write: 1, L : D}
  H:
    0: { write: 1, R : STOP}
    1: { write: 1, R : M}
  I:
    0: { write: 1, R : STOP}
    1: { write: 1, L : D}
  L:
    0: { write: 1, R : STOP}
    1: { write: 1, R : M}
  M:
    0: { write: 1, R : STOP}
    1: { write: 1, R : I}
  STOP:
    ",2020-10-21T15:46:09+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 2",diegochillo,"Writes 1 in the initial cell if thee consecutive ""1"" appear in the five-symbols sequence
(with the input below, a 0 is written because there are no consecutive ones)

    input: '010101'
    blank: ' '
    start state: start
    table:

      start:
        [1,0]: {write: 1, R: findfirst}

      findfirst:
        [1]: {write: 0, R: findsecond}
        [0]: {R}
        [' ']: {L: getbacknotfound}

      findsecond:
        [0]: {R: findfirst}
        [1]: {write: 0, R: findthird}
        [' ']: {L: getbacknotfound}

      findthird:
        [1]: {R: end}
        [0]: {R: findfirst}
        [' ']: {L: getbacknotfound}

      getbacknotfound:
        [0]: L
        [1]: {write: 0, L: end}

      end:
",2020-10-19T17:47:46+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 2",edoardodalborgo,"In this solution when the algorithm catch three consecutive 0s (negative condition, if you have 3 consecutive 0s  you can't have 3 consecutive 1s) in three different states (B, C, D) it ends and the solution in the first cell is just printed by the first operation in the starting point (write 0). When the algorithm catch some 1s consecutive it rewrites from right to left every value from 0 to 1 including the starting value and the ends. I don't know if it's correct by this way, but i think that it works.

blank: ['']
start state: A
table:
  A:
    0,1, ['']: {write 0, R: B}
  B:
    0: {R: C}
    1: {R: B}
    ['']: {L: E}
  C:
    0: {R: D}
    1: {R: C}
    ['']: {L: E}
  D:
    0: {R: F}
    1: {R: D}
    ['']: {L: E}
  E:
    0: {write 1, L: E}
    1: {L: E}
    ['']: {L: F}
end state: F",2020-10-20T09:53:05+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 2",ConstiDami,"blank: ' '
start state: moveendright
table:

  moveendright:
    [0, 1] : {R: moveendright}
    ' ': {L: moveleft}
  
  moveleft:
    0: {L: moveleft}
    1: {write: 0, L: foundone}
    ' '  : {R: return}

  foundone:
    1 : {write: 0, L: foundtwo}
    0 : {L: moveleft}
    ' ': {R: return}
  
  foundtwo:
    1 : {write: 0, L: foundthree}
    0 : {L: moveleft}
    ' ': {R: return}
    
  foundthree:
    [1, 0]: {write: 0, L: foundthree}
    ' ' : {R: returnfound}
  
  return: 
    [1, 0]: {write: 0, L: end}
 
  returnfound:
    [1, 0]: {write: 1, L: end}
  
  end:",2020-10-20T10:44:15+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 2",SarahTew,"[Turing Machine Consecutive.pdf](https://github.com/comp-think/2020-2021/files/5409585/Turing.Machine.Consecutive.pdf)
This is my table for finding consecutive 1s with a Turing machine. Like my chart for exercise 3, using this depends on being the head being able to move back to its starting position all at once at the end. I think there are ways to make the Turing machine do that (see my answer in exercise 3 for link) so if that's the case these instructions should work. The way it is written now I think it would work no matter how many cells followed after the head or what was printed on them. It would only read the first five after the initial start point. 

I think these instructions are more efficient than those I made for exercise 3 (which I did first). For these ex. 2 instructions I got rid of some redundant states but couldn't figure out how to get rid of all of them (ie. the ones that that just tell you to keep reading right) without losing its ability to count just the first five cells.",2020-10-20T15:19:44+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 2",giorgiasampo,"![IMG_20201020_171610](https://user-images.githubusercontent.com/72857698/96609128-78a2ef00-12fa-11eb-87f7-34283f0d1953.jpg)
",2020-10-20T15:34:22+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 2",falcon1982,"
CURR STATE | READ | WRITE | MOVE | NEXT STATE
-- | -- | -- | -- | --
OK | Â  | Â  | Â  | Â 
E | 0 | 0 | L | E
E | 1 | 0 | R | OK
F | 0 | 1 | R | G
F | 1 | 1 | R | G
G | 0 | 0 | R | G0
G | 1 | 0 | R | G1
G0 | 0 | 0 | R | G00
G0 | 1 | 0 | R | G01
G00 | 0 | 0 | L | E
G00 | 1 | 0 | R | G001
G01 | 0 | 0 | L | E
G01 | 1 | 0 | R | G011
G001 | 0 | 0 | L | E
G001 | 1 | 0 | R | G011
G011 | 0 | 0 | L | E
G011 | 1 | 0 | R | OK
G1 | 0 | 0 | R | G10
G1 | 1 | 0 | R | G011
G10 | 0 | 0 | L | E
G10 | 1 | 0 | R | G101
G101 | 0 | 0 | R | E
G101 | 1 | 0 | L | G011

",2020-10-20T19:21:47+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 2",AlessandraFa,"I originally had another solution, but it didnâ€™t have any stop condition and therefore wasnâ€™t able to understand when to stop (once reached the 5th cell), so I wrote this one which is much longer, I couldnâ€™t find a better one. In this case, the algorithm is also counting the steps and stops when it reaches the last cell (if the return conditions arenâ€™t met before).

![11111111Cattura](https://user-images.githubusercontent.com/72857617/96684773-6e293980-137c-11eb-8abb-986e39abade1.PNG)
",2020-10-21T06:42:03+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 2",gabrielefiorenza,"input : ""011000""
blank: ""0""
start state: start
table:
  start:
    0: { write: 1, R : A}
  A:
    0: { write: 0, R : B}
    1: { write: 1, R : B}
  B:
    0: { write: 0, R : C}
    1: { write: 1, R : C}
  C:
    0: { write: 0, L : D}
    1: { write: 1, R : G}
  D:
    0: { write: 0, L : E}
    1: { write: 1, L : E}
  E:
    0: { write: 0, L : F}
    1: { write: 1, L : F}
  F:
    0: { write: 0, R : STOP}
    1: { write: 0, R : STOP}
  G:
    0: { write: 0, L : H}
    1: { write: 1, R : M}
  H:
    0: { write: 0, L : I}
    1: { write: 1, L : I}
  I:
    0: { write: 0, L : E}
    1: { write: 1, L : L}
  L:
    0: { write: 0, L : F}
    1: { write: 0, L : STOP}
  M:
    0: { write: 0, L : N}
    1: { write: 1, L : STOP}
  N:
    0: { write: 0, L : O}
    1: { write: 0, L : O}
  O:
    0: { write: 0, L : P}
    1: { write: 0, L : P}
  P:
    0: { write: 0, L : E}
    1: { write: 1, L : STOP}
  STOP:
    ",2020-10-21T14:48:49+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",diegochillo,"Turing machine that writes 101 around the initial cell:

    input: ''
    blank: '0'
    start state: A
    table:
    
        A:
        [1,0]: {write: 1, L: B}

        B:
        [0]: {write: 1, R}
        [1]: {write: 0, R: C}

        C:
        [0]: {write: 1, R: D}

        D:
",2020-10-19T12:17:48+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",fcagnola,"This is my proposed **solution**, I think it'll work

Current state | Symbol | Write | Move | Next state
------------- | -------- | ----- |-------|----------
A | 0/1 | 1 | Right | B
B | 0/1 | 0 | Right | C
C | 0/1 | 1 | Right | D

Starting state: **A**
Ending state: **D**",2020-10-19T12:35:13+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",edoardodalborgo,"blank: '0'
start state: A
table:
  A: 
    0: {write 1, L: B}
    1: {write 0, R: C}
  B: 
    0,1: {write 1, R: A}
  C: 
    0,1: {write 1, R: D}
end state: D",2020-10-19T16:33:30+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",DeniseBas,"![Untitled Diagram](https://user-images.githubusercontent.com/72915965/96487312-54cda380-123d-11eb-8971-0b187c18cf80.jpg)
",2020-10-19T17:00:23+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",SarahTew,"I don't understand how to do this unless it's possible to move the header two spaces at once. (or move the header without it being part of a state??) I'm going to through my understanding of all the answers posted so far. Please please please if you think you understand this and your answer is right, please reply to me and explain. I think I am misunderstanding some sort of key information about Turing machines and/or the stipulations within the question.

@diegochillo's and @fcagnola write a 1 in the initial cell, which is incorrect since the instructions said that one had to be 0 and only the immediately adjacent cells should contain 1. @giorgiasampo's does make 1 0 1 with the 0 being in original cell position of the header but contains instructions for state D which is forbidden. @edoardodalborgo's doesn't work when you write 0 as in state A. It sends you to state C where you write a one and it finishes so it just says 01. Right? What am I missing? Is it something about how the cells are set up before state A begins? Is it the definition of instructions that I've misunderstood and a table that looks like @giorgiasampo's with stuff in state D is allowed? Is the origin cell of the header different from the origin cell of state A?

I've tried reusing a state like @DeniseBas but it just traps me in an endless loop. Can you have one state with two different sets of instructions and next states (as in Denise's state A)??? I wouldn't think so but I am lost as to how to actually do this with only states A, B, and C containing instructions, moving one space at a time, and each phase being exactly the same each time it is used.

",2020-10-19T17:09:01+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",LuisAmmi,"I agree with SarahTew, something's not right. 
The prohibition on specifing any instruction for the final state D makes the problem complex. Indeed, the text tells us that once reached the final state (so, after the transition from C to D),2 cells (the ones immediately on the left and on the right of the inital position of the head, which means the cells pointed by the head during the state C and A) will change value to 1.
If this change must take place simultaneously, we can say (if I have understood correctly how the Touring machine works) that there is no solution, because the head of the machine points one cell at a time and write one symbol at a time.
Moreover, if D has no instruction we cannot proceed writing new symbols in cells. The table tell us the machine has to stop. But we also cannot anticipate the change of symbols before, because the text specify that only *once reached* the D state, we should write 1 in those two cells. 
Maybe this argument is uncorrect, anyway I can not find other solutions.",2020-10-20T08:33:51+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",diegochillo,"@SarahTew who wrote:
> @diegochillo's and @fcagnola write a 1 in the initial cell, which is incorrect since the instructions said that one had to be 0 and only the immediately adjacent cells should contain 1. 

Dear Sarah,
The instructions state that you have to get the 101 ""once reached the final state"". During the process, you can write what you want where you want. I restore the 0 in the initial cell at the B state.
",2020-10-20T09:49:29+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",alicebordignon,"
![image](https://user-images.githubusercontent.com/72934558/96570757-04048c00-12cb-11eb-9038-37d0feca977b.png)




",2020-10-20T09:55:38+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",ConstiDami,"Current state | Tape symbol | Write symbol | Move head | Next State
---------------|---------------|----------------|--------------|-----------
A | 0 | 1 | R | B
A | 1 | 0 | L | C
B | 0 | 1 | L | A
C | 0 | 1 | R | D
D |  |   | |


At first I was confused because I thought that at the beginning of the execution, the cells could contain either 0 or 1, but after rereading the book chapter, I saw that all the cells are assigned to 0 in advance! I don't know if this information can help other people... :)",2020-10-20T10:02:05+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",GiuliaMenna,"![Untitled Diagram (1)](https://user-images.githubusercontent.com/72873975/96573173-0c11fb00-12ce-11eb-8cda-2d4ff10b29c4.png)

Initial state: A 
Final state: D

Only the cells immediately on the left and on the right of the initial position A have the value 1 specified.",2020-10-20T10:19:57+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",SarahTew,"@diegochillo I am still confused so I've copied your algorithm here for reference and below it I have written out when happens when I follow the algorithm and the problems that still aren't resolved. I still don't understand if I'm misreading the question and/or your algorithm.

input: ''
blank: '0'
start state: A
table:

    A:
    [1,0]: {write: 1, L: B}

    B:
    [0]: {write: 1, R}
    [1]: {write: 0, R: C}

    C:
    [0]: {write: 1, R: D}

    D:

Let the **bold** number be the number in the initial position cell. Let __ represent a cell with nothing written in it (it is either blank or contains something for the machine to read that you have not written)

At the end of state A you have __ **1** __ then you move left and to State B.
At the end of state B you have either 1 **1** __ then you move right but there's no subsequent state (Why does it end here?)
                                                       or  0 **1** __ then you move right and move to State C
At the end of the State C you have 0 **1**__ then you move to State D.

All of the scenarios above end with a 1 in the initial cell. You don't replace it with 0 in State B because you've moved to the left; you're putting a 0 in the cell to the left of your initial starting place. They also don't contain 1s in the cells adjacent to the initial cell. How is your algorithm supposed to work? How are you getting 1 **0** 1 ? 
",2020-10-20T11:55:00+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",diegochillo,"@SarahTew 

_input:''_ and _blank: '0'_ mean that all the cells are initially filled with symbol '0'.

>  then you move right but there's no subsequent state

When there's no state specified, it means that **you remain in the same state you are**.

So the sequence is:

Initial symbols: 0**0**0

A: regardless of the symbol (1 or 0), write 1 on the initial cell, move left and switch to state B (Symbols: 0**1**0)

B: cursor is left to initial cell, there's a 0, so write 1 and move right (Symbols: 1**1**0)

B: cursor is back on initial cell, there's a 1, so write 0, move right and switch to state C (Symbols: 1**0**0)

C: cursor is right to the initial cell, there's a 0, so write 1, move right and switch to final empty state D (Symbols: 1**0**1)

...as ou can check on https://turingmachine.io/

Hope this helps.",2020-10-20T12:36:53+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",lauratravaglini,"Current State  | Tape symbol  | Write symbol  | Move head  | Next state
-------------- | ------------- | -------------- | ----------- | -----------
A | 1 | 0 | right | B
B | 0 | 1 | right | C
C | 1 | 0 | right | D
D
",2020-10-20T12:52:39+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",SarahTew,"@diegochillo Thank you!!! I understand now! For those following the replies: The key is that you don't _have to_ assign a next state (duh!), that's how you can use the same state twice. See @diegochillo's latest reply for a step by step explanation. Mystery solved! Thank you!",2020-10-20T13:04:54+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",laurentfintoni,"input: '01'
blank: ' '
start state: a
table:
  a:
    '0': {L: b}
  b:
    ' ': {write: 1, R: c}
  c:
    '0': {R: b}
  d:
 
seems to work using https://turingmachine.io/",2020-10-20T15:04:58+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",giorgiasampo,"![IMG_20201020_172417](https://user-images.githubusercontent.com/72857698/96609054-62952e80-12fa-11eb-87b4-f89c19eba6f9.jpg)
",2020-10-20T15:33:44+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",gabrielefiorenza,"![ta](https://user-images.githubusercontent.com/72872864/96609359-bbfd5d80-12fa-11eb-9a1f-ba616683d9ad.PNG)
",2020-10-20T15:36:13+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",Camillaneri,"input: ''
blank: '0'
start state: A
table:
  A:
    [1,0]: {write: 1, R: B}
  B:
    [1,0]: {write: 1, L: C}
  C:
    [1]: {write: 0, L}
    [0]: {write: 1, R: D}
  D:

Start state: A
End state: D",2020-10-20T16:02:09+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",vanessabonanno,"blank: '0'
start state: A
table:
  A:
    0: {write: 1, R: B}
    1: {write: 1, R: B}
  B:
    0: {write: 0, R: C}
    1: {write: 0, R: C}
  C:
    0: {write: 1, R: D}
    1: {write: 1, R: D}
  D:
    
The output should be: ... 0 0 0 1 0 1 0 0 0 ...
This is how I tried solving this exercise, but I still have one big doubt: what is the ""initial position"" that have to present on its immediately near cells ""1""?",2020-10-20T16:36:53+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",AlessandraFa,"![Cattura](https://user-images.githubusercontent.com/72857617/96642955-2b894200-1327-11eb-8ff7-a95844bf9e8e.PNG)
",2020-10-20T17:47:18+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",AlessandroBertozzi,"![Alan Turing machine (2)](https://user-images.githubusercontent.com/72964241/96631097-2c65a800-1316-11eb-85a0-6d0d02b99f12.PNG)
",2020-10-20T18:52:45+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",LuisAmmi,"![image](https://user-images.githubusercontent.com/67541950/96634139-5de07280-131a-11eb-8bcc-cc6e30fcec51.jpeg)
Initial state: A
Final state: D",2020-10-20T19:22:59+00:00
comp-think/2020-2021,"Lecture ""Computability"", exercise 1",essepuntato,"Hi all,

Besides the varous correct answers I've seen here, I have to say that the discussion in this exercise was one of the best ones I've seen in the past four years. Thanks for that!",2020-10-21T07:28:37+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",IlaRoss,"![20201016_154916](https://user-images.githubusercontent.com/72861005/96266986-981edc80-0fc7-11eb-84c2-81af1b00e974.jpg)
 Referring to the first algorithm (sorry for my handwriting)",2020-10-16T13:54:28+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",laurentfintoni,"I think this is the first algorithm 
![Screen Shot 2020-10-16 at 4 08 31 PM](https://user-images.githubusercontent.com/72798408/96268968-02d11780-0fca-11eb-8d84-e6eeb24bfcf2.png)
",2020-10-16T14:10:09+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",laurentfintoni,"And I think this is the second but tbh my head hurts 
![Screen Shot 2020-10-16 at 4 10 38 PM](https://user-images.githubusercontent.com/72798408/96269110-39a72d80-0fca-11eb-8e20-9cf0679d2620.png)
",2020-10-16T14:11:33+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",laurentfintoni,"I forgot to specify the value in the third return value box, should be return value ""sum"" or something like that... ",2020-10-16T14:14:41+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",giorgiasampo,"![Fibonacci's code](https://user-images.githubusercontent.com/72857698/96274300-a32a3a80-0fd0-11eb-945a-e4672e3317b8.png)
",2020-10-16T14:57:16+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",SarahTew,"![Fibonacci 2](https://user-images.githubusercontent.com/72857758/96275441-05376f80-0fd2-11eb-92d0-bdb091b8e33d.png)
![Fibonacci 1](https://user-images.githubusercontent.com/72857758/96275444-05d00600-0fd2-11eb-85a9-dcf5bc826328.png)
",2020-10-16T15:07:21+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",gabrielefiorenza,"![FLOWCHART 2](https://user-images.githubusercontent.com/72872864/96283137-0a99b780-0fdc-11eb-9725-275ea68349fc.png)
![FLOWCHART 3](https://user-images.githubusercontent.com/72872864/96283140-0b324e00-0fdc-11eb-8275-bfd9bfd3b9f5.png)
",2020-10-16T16:18:56+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",giorgiasampo,"![Fibonacci 2](https://user-images.githubusercontent.com/72857698/96283099-f9e94180-0fdb-11eb-9768-dbda5115efdf.png)

I don't know if this was what I was supposed to come up with, but I tried to make something similar to a ""do loop"" with a check variable, in order to generalie the function.",2020-10-16T16:19:44+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",dbrembilla,"Fibonacci without recursion
![Diagram (1)](https://user-images.githubusercontent.com/72857468/96283513-9875a280-0fdc-11eb-9d46-985d09d1e6d2.jpg)
Fibonacci with recursion
![Diagram (2)](https://user-images.githubusercontent.com/72857468/96283437-8136b500-0fdc-11eb-92a6-f0f5f18a2265.jpg)
",2020-10-16T16:22:12+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",edoardodalborgo,"This is the first algorithm
![Flowchart1_es3_lez2](https://user-images.githubusercontent.com/72916575/96292712-ee047c00-0fe9-11eb-9b14-dbf792b4f34c.png)
",2020-10-16T17:58:25+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",ChiaraCati,"![D061DE3F-BD19-47AE-9B06-0DECC178EE42](https://user-images.githubusercontent.com/72877990/96295004-85b79980-0fed-11eb-921b-f45dfd2f4258.jpeg)
",2020-10-16T18:24:03+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",ChiaraCati,"
![748400DA-019C-4AFB-9358-40ED2D6464D1](https://user-images.githubusercontent.com/72877990/96298162-4b043000-0ff2-11eb-9e6c-c076511482a1.jpeg)

",2020-10-16T18:58:38+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",SusannaPinotti,"![Flowchart Fibonacci Iterativo](https://user-images.githubusercontent.com/72868258/96304403-565c5900-0ffc-11eb-868c-0a6b16cfbc80.png)
Flowchart for the first algorithm ",2020-10-16T20:11:03+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",SusannaPinotti,"
![Flowchart Fibonacci ricorsivo (2)](https://user-images.githubusercontent.com/72868258/96304780-0336d600-0ffd-11eb-8dff-f22c4edabd36.png)
Flowchart for the second algorithm ",2020-10-16T20:15:23+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",diegochillo,"Second (recursive) algorithm:
![Flowchart_Fibonacci_Recursive](https://user-images.githubusercontent.com/72892133/96331491-f72f3080-105d-11eb-9353-0c20de13b61d.jpg)
",2020-10-17T07:50:11+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",ConstiDami,"First algorithm

![Ex3_1](https://user-images.githubusercontent.com/61546325/96339950-219ddf80-1098-11eb-9381-8610623d92b9.jpg)

Second algorithm

![Ex3_2](https://user-images.githubusercontent.com/61546325/96339959-2bbfde00-1098-11eb-9699-4bc5b154c607.jpg)
",2020-10-17T14:45:56+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",penelopelask,"

![fibonacci 1 + 2](https://user-images.githubusercontent.com/72964637/96348387-07bcc680-10b1-11eb-8062-53ae61f60faa.png)
",2020-10-17T16:43:32+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",yunglong28,"Fibonacci ex. 1
![Untitled Diagram(1)](https://user-images.githubusercontent.com/72975038/96365643-58303480-1142-11eb-91e4-c29415011860.png)
",2020-10-18T11:03:43+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",yunglong28,"Fibonacci 2
![Untitled Diagram(2)](https://user-images.githubusercontent.com/72975038/96367928-fc20dc80-1150-11eb-83d7-cd011965ef2c.png)
",2020-10-18T12:48:32+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",Fran-cesca,"
![Untitled Diagram (2)](https://user-images.githubusercontent.com/72857660/96368637-30969780-1155-11eb-9150-38ed1ffdbe7a.jpg)
",2020-10-18T13:18:37+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",GiuliaMenna,"![Untitled Diagram (1)](https://user-images.githubusercontent.com/72873975/96370610-b834d400-115e-11eb-8f97-eaeef8177305.png)
![Flowchart 2](https://user-images.githubusercontent.com/72873975/96370617-be2ab500-115e-11eb-99f9-5f8f1ed18e66.png)
",2020-10-18T14:29:08+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",AlessandraFa,"![Fibonacci flowchart 1](https://user-images.githubusercontent.com/72857617/96371424-f384d200-1161-11eb-88f2-b6d18f60340e.png)

![Fibonacci recursion](https://user-images.githubusercontent.com/72857617/96371422-f2ec3b80-1161-11eb-893b-d77585839353.png)

",2020-10-18T14:50:36+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",DeniseBas,"
![Copy of Untitled Diagram](https://user-images.githubusercontent.com/72915965/96371859-321b8c00-1164-11eb-9f5b-734067a41e67.jpg)
![Untitled Diagram-3](https://user-images.githubusercontent.com/72915965/96371863-35af1300-1164-11eb-9113-1ef645720ff0.jpg)
",2020-10-18T15:06:09+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",LuisAmmi,"![image](https://user-images.githubusercontent.com/67541950/96374695-6ac36180-1174-11eb-99c8-4004a56249a2.jpeg)
The second flowchart",2020-10-18T17:02:27+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",AlessandroBertozzi,"![First algroroithm](https://user-images.githubusercontent.com/72964241/96386056-5002e400-1198-11eb-8739-304737d5e22d.jpg)
Fibonacci 1",2020-10-18T21:19:46+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 3",enri-ca,"Fibonacci 1
![immagine](https://user-images.githubusercontent.com/72966913/96413083-671ef180-11eb-11eb-96bf-d5fbb39b471d.png)

Fibonacci 2
![immagine](https://user-images.githubusercontent.com/72966913/96413133-7b62ee80-11eb-11eb-9591-3b1c314fa4e1.png)
",2020-10-19T07:15:44+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",SarahTew,"
![Exercise 2](https://user-images.githubusercontent.com/72857758/96256923-c8f81500-0fb9-11eb-89e9-799413825074.png)
",2020-10-16T12:45:12+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",denizovski,"![Flowchart Diagram](https://user-images.githubusercontent.com/59102247/96259808-c94add00-0fc6-11eb-856e-b65937772b16.png)
",2020-10-16T12:46:56+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",laurentfintoni,"![Screen Shot 2020-10-16 at 2 45 03 PM](https://user-images.githubusercontent.com/72798408/96264672-b931fe00-0fc4-11eb-8d11-2384da690479.png)
",2020-10-16T13:32:27+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",giorgiasampo,"![Diagramma non titolato](https://user-images.githubusercontent.com/72857698/96265174-6b69c580-0fc5-11eb-992f-e611682149d3.png)
",2020-10-16T13:36:59+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",fcagnola,"This is my proposal
![Diagram](https://user-images.githubusercontent.com/56833063/96272514-7bd26e00-0fce-11eb-8b8d-e985489ab44b.png)

",2020-10-16T14:42:13+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",dbrembilla,"![Diagram](https://user-images.githubusercontent.com/72857468/96277246-492b7400-0fd4-11eb-90a7-500201e3d6dc.jpg)
",2020-10-16T15:23:23+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",gabrielefiorenza,"![FLOWCHART 1](https://user-images.githubusercontent.com/72872864/96283063-e5a54480-0fdb-11eb-9557-0160459c0a85.png)
",2020-10-16T16:17:59+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",edoardodalborgo,"![ex2_lez2](https://user-images.githubusercontent.com/72916575/96287516-5fd8c780-0fe2-11eb-8e4d-8c5765f2d12b.png)
",2020-10-16T17:04:19+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",ChiaraCati,"
![33680E3A-1C22-4020-BC0C-9E00C0F19A48](https://user-images.githubusercontent.com/72877990/96335569-dc6ab500-1079-11eb-9d50-0a2eff7dd91d.jpeg)

",2020-10-17T11:08:49+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",SusannaPinotti,"![image](https://user-images.githubusercontent.com/72868258/96336988-be09b700-1083-11eb-8a28-75340af8660a.png)
",2020-10-17T12:19:28+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",ConstiDami,"![Ex2](https://user-images.githubusercontent.com/61546325/96338992-eef0e880-1091-11eb-8b6c-ba9282d94ae1.jpg)
",2020-10-17T14:01:38+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",penelopelask,"![exercise2](https://user-images.githubusercontent.com/72964637/96342030-f3bd9880-10a1-11eb-86f6-3fcefc92452f.png)
",2020-10-17T14:55:38+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",AlessandraFa,"![Flowchart A=B](https://user-images.githubusercontent.com/72857617/96364435-f7512e00-113a-11eb-9437-77472ba3bf13.png)
",2020-10-18T10:11:51+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",yunglong28,"

![Untitled Diagram](https://user-images.githubusercontent.com/72975038/96365122-a5120c00-113e-11eb-97cc-717200a82c90.png)
",2020-10-18T10:37:20+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",Fran-cesca,"![Untitled Diagram (1)](https://user-images.githubusercontent.com/72857660/96368344-aac61c80-1153-11eb-9704-7a3c7429b394.jpg)
",2020-10-18T13:07:47+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",GiuliaMenna,"![Untitled Diagram](https://user-images.githubusercontent.com/72873975/96369026-d5b26f80-1157-11eb-9e4b-bfa5d4691342.png)

",2020-10-18T13:37:58+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",valentinacozzi,"![DF0CDC12-98ED-4753-9702-6C2055472EF9](https://user-images.githubusercontent.com/72857648/96371319-6d688b80-1161-11eb-8279-8aa66c9c8e53.jpeg)
",2020-10-18T14:46:29+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",DeniseBas,"![Untitled Diagram](https://user-images.githubusercontent.com/72915965/96372071-765b5c00-1165-11eb-8a3e-46dfbe129567.jpg)
",2020-10-18T15:15:06+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",LuisAmmi,![image](https://user-images.githubusercontent.com/67541950/96375101-50d74e00-1177-11eb-994c-3b5e390ab009.jpeg),2020-10-18T17:23:17+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",enri-ca,"![immagine](https://user-images.githubusercontent.com/72966913/96376290-51bfae00-117e-11eb-95a4-51d319142050.png)
",2020-10-18T18:13:22+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 2",essepuntato,"Hi all,

Thanks for your answers. A few comments about some issues I found reading your proposed solutions:
1. remember that defining an algorithm and executing it (i.e. passing specific input values to a computer that will follow the instruction depicted in the algorithm to return something) are two different activities. When you develop an algorithm, you do not consider, usually, particular input values (e.g. the string ""john"" or the number 3) but just variables / parameters (i.e. the input string *a* and the number *n*).
2. According to the convetion I've introduced, using `""a""` does not defined a variable but a string containing the character *a*.
3. The steps of the algorithms must not contain references to variables that are not initialised before or that are not the input parameter of the algorithm.",2020-10-19T07:26:14+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 1",SarahTew,2,2020-10-16T12:44:41+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 1",IlaRoss,It's 2,2020-10-16T13:10:45+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 1",giorgiasampo,2,2020-10-16T13:24:37+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 1",fcagnola,"The result should be **2**, since both words can be found in the citation",2020-10-16T14:33:09+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 1",Lucaspoladore,The number 2,2020-10-16T15:08:46+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 1",dbrembilla,It returns 2,2020-10-16T15:14:16+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 1",gabrielefiorenza,2,2020-10-16T16:17:12+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 1",edoardodalborgo,2,2020-10-16T16:36:30+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 1",SusannaPinotti,The result is 2 ,2020-10-17T12:20:53+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 1",AlessandraFa,The result is 2.,2020-10-18T09:57:37+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 1",yunglong28,The result is 2,2020-10-18T10:04:01+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 1",DeniseBas,It is 2.,2020-10-18T13:36:12+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 1",valentinacozzi,"The result is 2, because both â€œPeroniâ€ and â€œHTMLâ€ are â€˜containedâ€™ in the bibliographic entry.",2020-10-18T14:07:49+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 1",LuisAmmi,"The algorithm must return the number 2, because the bibliographic entry contains both the words ""Peroni"" and ""HTML"".",2020-10-18T17:38:11+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 1",enri-ca,The algorithm's execution returns 2.,2020-10-18T17:55:18+00:00
comp-think/2020-2021,"Lecture ""Algorithms"", exercise 1",lauratravaglini,2,2020-10-19T06:12:20+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",SarahTew,"Oven mitt and mitten; both protect hands from extreme temperatures, both are made of thick insulating fabric, both have similar shape (split it two sections: thumb and mitt).",2020-10-14T09:40:51+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",AleRosae,"A library shelf and any folder on a computer: they are both used to store documents, which may be of different kinds, and those documents might be arranged in different ways (e.g. one sections is meant to store all Russian books, another one contains only French essays, etc. ).",2020-10-14T13:23:46+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",LuisAmmi,"1) To show your own badge (as a plastic card) to have access to University spaces and facilities 
2) to login with your web account (or SPID) on the University's website (to attend online lessons, for instance)
Both of them are valid forms of identification.",2020-10-14T15:03:34+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",ChiaraCati,"A keyboard and a piano both have keys, every key has its own univocal meaning and pressing them in a  determined
sequence enables us to communicate something meaningful (e.g an emotional state) in a textual or melodical form",2020-10-14T15:19:06+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",AlessandraFa,"Following a recipe to cook a dish or following instructions to build a piece of furniture: both situations require a specific sequence of actions to reach a goal. In both cases, the steps must be followed in a precise order to produce the desired object (food or furniture), which represents the goal. The physical presence and action of at least one person are required. Specific instruments (ingredients for the recipe, construction materials for the building process) are also needed.",2020-10-14T20:54:00+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",diegochillo,"Brushing something until it's clean; hitting a nail until it's pushed in.
Both require the repetition of an action until a condition is satisfied.",2020-10-14T21:32:24+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",gabrielefiorenza,"1st situation : searching the cheapest model of an object in an online marketplace to buy it.
2nd situation: watching the map and trying to find the shortest way to get to a specific part of the city.
Abstraction: in both situations we are searching and comparing options in order to choose the best one according to our need(buying the cheapest model of the object; getting to that specific part of the city)",2020-10-15T10:22:07+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",GiuliaMenna,"A bottle of milk and an oil container. They are both fluids, stored in a watertight container, and both used to feed someone or something: in the first case humans or animals, in the second different kinds of vehicles.",2020-10-15T11:22:10+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",laurentfintoni,"a drum machine and a drum kit. They are both objects that when given inputs (touching buttons on a drum machine, hitting drum skins on a kit) produce rhythmic sounds.  ",2020-10-15T12:41:04+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",SusannaPinotti,"Two situations like ""writing a speech or a presentation"" and ""coming up with an answer to this exercise"" can be seen as following the same abstract pattern: 
-Initial cluelessness
-Desiring to be original, catchy
-Embryonic idea begins to take shape 
-Perfectioning of the idea (usually while taking a shower)",2020-10-15T14:22:31+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",giorgiasampo,"Doing the laundry and catching a plane could be seen as two situations which share the same pattern if analysed from an abstract point of view:
1. You need to pack all the clothes involved in the same place
2. You need to check at least twice that you are not above the weight limit
3. You need to get to the place where the machine you need to perform such actions is kept
4. You need to separate from the clothes 
5. You have to wait at least one hour before being able to perform the following action
6. You will spend your waiting time in a very noisy environment
7. Your clothes will be moving throughout the whole process",2020-10-15T14:45:29+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",vanessabonanno,I am thinking about a hair straightener and a voice microphone. They are both designed to be held in hand; they can be made by almost same material (the external part made of plastic); a long cable connects it to a source of electricity.,2020-10-15T16:02:25+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",alicebordignon,"A mandarin and a orange are both citrus fruit though differing from each other in taste and aromas, more or less with the same color and similar forms and skins. ",2020-10-15T16:32:31+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",DeniseBas,"An eyelid and curtains. Both block the passage of light, they both act as a shield against dust, they can be open and closed by a voluntary act, their closure can induce sleep.",2020-10-15T20:43:15+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",penelopelask,"Both COVID-19 and flu can have varying degrees of similar signs and symptoms. Someone can have fever or feel feverish/chills in both situations. He might also have a sore throat and a runny or stuffy nose. Finally a common feature could be the muscle pain or a headache. 
",2020-10-16T06:57:59+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",AlessandroBertozzi,"A street and any pc's folder structure. Both ""objects"" create a hierarchy, which can be followed by any users to reach the researched place.",2020-10-16T07:49:11+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",enri-ca,"Objects:
different kinds of doors have the same caractheristic of closing/opening a gate even if they are made of different materials, technology, shape etc.
Situations:
Drawing and writing are paired by i.e. the position of the agent, the support, the shape of the tool used, etc.",2020-10-16T08:05:25+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",ConstiDami,"Pencils to color a drawing and brushes and paint to paint a piece of furniture: they add color in order to transform and embelish a preexisting object, without changing its shape. ",2020-10-16T08:28:00+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",Maedeam,"We have two table, one table for serving food and one desk for studying, both of them have four desk leg and a flat surface, but the usages are different. ",2020-10-16T09:41:24+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",valentinacozzi,"I'm thinking about 2 occupations: painter and make-up artist. They both paint in a sense (whether it is a painting or a face/body) and they both use brushes and colours (don't know if it's a good example, I spend to much time on YouTube). 
Speaking of which: following instructions or a recipe (in a cookbook for instance) or watching a ""How to"" video",2020-10-16T09:47:11+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 3",edoardodalborgo,"I'm thinking about pushing a button for calling an elevator and clicking on an icon on the computer's desktop to call a executable file for executing an algorithm. In all of those cases you push a button of a graphic interface for executing an algorithm, an abstraction of a lot of passages for moving the elevator to you and to do something with your computer.",2020-10-16T10:27:16+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",IlaRoss,"Is it 13? 
Wow, I had never seen that function to calculate a Fibonacci number! It is simply great :-D",2020-10-14T09:53:44+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",SarahTew,"Reading the natural language definition it only returns 0 for the 0th term, not the first. So I think this definition  of the Fibonacci sequence eliminates '0' as the first term and instead starts with '1' as the first term. If that's the case then the input '7' yields 13.",2020-10-14T10:09:42+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",SusannaPinotti,"Following the recursive method for the Fibonacci function described in the second natural language definition, the value resulting from the input ""7"" is the sum of the Fibonacci function for ""7-1"" and ""7-2"". So Fib(7)=Fib(6)+Fib(5)=8+5=13",2020-10-14T15:00:05+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",diegochillo,"Exploding the whole recursion:

f(0)=0
f(1)=1
f(2)=f(1)+f(0)=1
f(3)=f(2)+f(1)=2
f(4)=f(3)+f(2)=3
f(5)=f(4)+f(3)=5
f(6)=f(5)+f(4)=8
f(7)=f(6)+f(5)=13
",2020-10-14T21:07:14+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",denizovski,"In Fibonacci function, the terms are numbered from 0 onwards like this: 
n=0,1,2,3,4,5,6,7...
**fib=0,1,1,2,3,5,8,13...**
In this way, **7** as an input equals **13.**",2020-10-14T21:35:14+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",lauratravaglini,"The Fibonacci sequence is 0,1,1,2,3,5,8,13,21,...
If n is 7, returns the sum of the same function with n-1 as input and the same function with n-2 as input.  
Fib(7)=Fib(7-1)+Fib(7-2) -> Fib(7)=Fib(6)+Fib(5) -> Fib(7)=8+5 -> Fib(7)= **13**
(usually when I think Iâ€™ve figured something out in math Iâ€™m actually wrong, so I donâ€™t know, I tried)",2020-10-15T08:03:26+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",AlessandraFa,"Using **7** as input, the result of applying the recursive definition of the Fibonacci function is **13**.
The Fibonacci sequence is the series of numbers **fib=0, 1, 1, 2, 3, 5, 8, 13, 21,...x<sub>(n-1+n-2)</sub>.**
Each number in the sequence **x<sub>n</sub>** is the result of the sum of the previous ones **x<sub>n-1</sub>** and **x<sub>n-2</sub>**. The recursive definition returns 0 if the input is less or equal to 0, so 1 should be considered as 1st term.
Since 7 is the input number, the result will be the 7th number x<sub>7</sub> of the series, namely the sum of x<sub>6</sub> and x<sub>5</sub>. So, **x<sub>n</sub>=x<sub>n-1</sub>+x<sub>n-2</sub>** corresponds, in this case, to **x<sub>7</sub> = x<sub>6</sub>+x<sub>5</sub>=5+8=13.**",2020-10-15T09:39:57+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",gabrielefiorenza,"The answer is 13, because in the Fibonacci sequence each number is the sum of the two preceding ones, starting from 0 and 1. ",2020-10-15T10:00:19+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",samuelespotti,"The Fibonacci sequence is 0,1,1,2,3,5,8,13,21,...
If n is 7, we have to do the sum of "" n-1"" as input (7-1=6) and t n-2 as input (7-2=5)
 Fib(7)=Fib(6)+Fib(5) -> Fib(7)=8+5 -> Fib(7)= 13",2020-10-15T12:00:53+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",giorgiasampo,"Applying the second definition we get 7 as an input: being 7 different from 0 and not below it we don't return 0 as a result and proceed with the instructions.
7 is different from 1 so we don't return 1.
The Fibonacci sequence goes like 0,1,1,2,3,5,8,13,22.... and so on, where all the numbers correspond to the sum of the previous two.
Going on with the instructions given,we get the sum of the function for n-1 (6) plus the function for n-2 (5) which is 8+5=13.",2020-10-15T14:26:00+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",alicebordignon,"According to the Fibonacci sequence (0, 1, 1, 2, 3, 5, 8, 13, 21...) the result will be the sum of the 2 previous numbers. So, if the input number is 7, we might sum (7-1=fib6) and (7-2=fib5) equals to 8+5 and obtain 13 as the fib(7) ",2020-10-15T16:07:05+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",falcon1982,"F(7)=
F(6)+F(5)= 
(F(5)+F(4)  ) +  (F(4)+F(3) )=
(F(4)+F(3)+F(3)+F(2))  + ( F(3)+F(2)+ F(2)+1 )=
(F(3)+F(2)+F(2)+1 +F(2)+1 + 1+0) +(F(2)+1 +1+0+1+0+1)=
(F(2)+1 +1+0 +1+0 +1+1+0 +1+1+0)+(1+0 +1+1+0+1+0+1)=
(1+0 +1 +1+0 +1+0 +1+1+0 +1+1+0)+(1+0 +1+1+0+1**+0+1**)=
8+5=13

",2020-10-15T16:44:38+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",diegochillo,"> F(7)=
> F(6)+F(5)=
> (F(5)+F(4) ) + (F(4)+F(3) )=
> (F(4)+F(3)+F(3)+F(2)) + ( F(3)+F(2)+ F(2)+1 )=
> (F(3)+F(2)+F(2)+1 +F(2)+1 + 1+0) +(F(2)+1 +1+0+1+0+1)=
> (F(2)+1 +1+0 +1+0 +1+1+0 +1+1+0)+(1+0 +1+1+0+1+0+1)=
> (1+0 +1 +1+0 +1+0 +1+1+0 +1+1+0)+(1+0 +1+1+0+1)=
> 8+5=13

There's a ""+0+1"" missing in the penultimate row",2020-10-15T17:25:10+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",falcon1982,And I double checked it ðŸ¤¦â€â™‚ï¸,2020-10-15T17:31:58+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",DeniseBas,"F(7)=F(5)+F(6) -> F(7)=8+5 so it means that F(7)=13

 ",2020-10-15T21:18:06+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",Camillaneri,"n=7

I have to sum the result of the functions of n-1 and n-2

7-1=6
7-2=5

I have already calculated the functions of 6 and 5 with the same procedure, wich are 8 and 5

8+5=13 
the function of 7 Is 13 ",2020-10-16T06:57:41+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",essepuntato,"Hi all,

Thanks for your answer. Someone said that ""0"" is not the first element while ""1"" is. Could you explain what you mean?

Anyway, the solution has been provided in the section linking the chapter in the main page of the course.",2020-10-16T07:35:48+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 2",Maedeam,"The function for calculating the 7th Fibonacci number takes as input an integer â€œ7â€. If â€œ7â€ is less than or equal to 0, then 0 is returned as a result. Otherwise, if â€œ7â€ is equal to 1, then 1 is returned. Otherwise, return the sum of the same function with â€œ7-1â€ as input and still the same function with â€œ7-2â€ as input.",2020-10-16T09:47:08+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",SarahTew,"In class lecture: I write; you write
Written lecture notes; I write, you write, I read, you read",2020-10-14T09:45:47+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",IlaRoss,"I write
you write
I read
you read",2020-10-14T09:47:00+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",SusannaPinotti,"There are two pronous and two verbs, this means that only four sentences can be formed according to the regular grammar rules: I/you write and I/you read. ",2020-10-14T14:08:44+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",LuisAmmi,"The possible combinations of ""terminals"" and <non terminals> given are 4: I write, you write, I read and you read.",2020-10-14T14:33:02+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",GiuliaMenna,"The possible sentences that can be produced by the regular grammar are given by the combination of two pronouns and two verbs, that are converted from four different 'terminal' words/sentences to two non-terminal symbols and to non-terminal 
 sentences (written in angle brackets).",2020-10-14T17:13:56+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",denizovski,"I write
you write
I read
you read",2020-10-14T20:03:33+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",lauratravaglini,"According to the hierarchy proposed by Chomsky the regular grammar's rules are two, thus we can find:
1. a non-terminal symbol on the left side and a terminal on the right side (e.g. < verb > : := ""write"");
2. a non-terminal symbol on the left side and a terminal (possibly) followed by a non-terminal on the right side (e.g. < sentence > : := ""I"" < verb >).
Because of its simplicity, a regular grammar can generate very basic and clear sentences.",2020-10-14T20:32:15+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",AlessandraFa,"There are 4 possible combinations that can be obtained combining the terminal symbols â€œIâ€ and â€œyouâ€ with the terminals â€œwriteâ€ and â€œreadâ€, which should replace the non-terminal symbol `<verb>.` Thus, the possible sentences are:
I read
I write 
you read 
you write

",2020-10-14T20:36:24+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",gabrielefiorenza,"There are 4 possible sentences, obtained by replacing the non-terminal <verb> with the two terminals ""write"" and ""read"".
I write
I read
You write
You read",2020-10-15T09:44:07+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",samuelespotti,"We have four possible combinations of ""terminals"" (two pronouns and two verbs): I write, you write, I read, you read",2020-10-15T11:30:35+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",giorgiasampo,"The possible combinations are: I read, You read, I write, You write",2020-10-15T14:06:30+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",vanessabonanno,"Considering that we have two terminals (""I"" and  ""you"") and two non-terminals that can be replaced with ""read"" and ""write"" to create a sentence, the resulting sentences will be ""I read"", ""you read"", ""I write"", ""you write"".",2020-10-15T14:47:18+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",alicebordignon,"We have two pronouns and two verbs so there are 4 possible combinations: I read, You read, I write, You write",2020-10-15T16:14:46+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",falcon1982,"I write, you write, I read, you read",2020-10-15T16:17:34+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",DeniseBas,"Since regular grammar is the least expressive grammar out of the four listed by Noam Chomsky in his hierarchization, the possible syntactic structures that can be originated by its rules are quite simple (1 pronoun and 1 verb). Therefore there are four possible combinations: I write, I read, You write, You read.",2020-10-15T20:17:34+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",Camillaneri,"With the terminals given in the example four combinations are possible: I write, you write, I read, you read.
But using differenti terminals and non-terminals almost an infinite number of  sentences cen be made, as long as we use the  <non-terminal> ::= ""terminal""
Or <non-terminal> ::= ""terminal"" <non-terminal> template. ",2020-10-16T06:00:29+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",Camillaneri,"* <non-terminal> ::= ""terminal""
and <non-terminal> ::= ""terminal"" <non-terminal> ",2020-10-16T06:10:49+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",Camillaneri,"I meant:  non-terminal ::= ""terminal""
and non-terminal ::= ""terminal"" non-terminal (my tablet has some issue with angular brackets) ",2020-10-16T06:26:05+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",essepuntato,"Hi all,

Thanks for your answer. Please, notice that the exercise asked you to simply list all the sentences that can be produced, not the rationale behind the regular grammar - even if that was appreciated anyway in answering the question. 

The solution has been linked in the section linking the chapter in the main page of the course.",2020-10-16T07:30:49+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",enri-ca,"According to the example:
I write
I read 
You write
You read
According to the rule: every sentence that is composed by a succession of a ""terminal"" and <non-terminal>.",2020-10-16T07:43:27+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",Maedeam,It will be 4 possible sentences: I write / I read / You write / You read,2020-10-16T09:01:06+00:00
comp-think/2020-2021,"Lecture ""Introduction to Computational Thinking"", exercise 1",edoardodalborgo,"Regular grammar production allow you to create sentences by replace a non-terminal symbol with a terminal symbol, or with a terminal symbol followed by another non-terminal (variable). The number of combinations that you can create depends on the number of terminal that you can use for the replace. In our example we have used two pronoun and two verbs and the possible combination are four:
sentence ::= ""I"" x | ""You"" x
x ::= ""write"" -> I write / You write
x ::= ""read"" -> I read / You read",2020-10-16T10:09:57+00:00
